<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="一、算法描述：1.简介：Diffie-Hellman:一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm).这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密">
<meta property="og:type" content="article">
<meta property="og:title" content="转载:[JAVA加解密]DH算法">
<meta property="og:url" content="https://bloodorange2017.github.io/archives/2017/11/08/hdAlgorithm/index.html">
<meta property="og:site_name" content="XueCheng Notes">
<meta property="og:description" content="一、算法描述：1.简介：Diffie-Hellman:一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm).这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密">
<meta property="og:updated_time" content="2017-11-08T09:10:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="转载:[JAVA加解密]DH算法">
<meta name="twitter:description" content="一、算法描述：1.简介：Diffie-Hellman:一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm).这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bloodorange2017.github.io/archives/2017/11/08/hdAlgorithm/"/>





  <title>转载:[JAVA加解密]DH算法 | XueCheng Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XueCheng Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Where there is a will, there is a way.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/11/08/hdAlgorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">转载:[JAVA加解密]DH算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-08T17:05:44+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <div id="article_content" class="article_content csdn-tracking-statistics" data-mod="popu_519" data-dsm="post"><br><br><p>一、算法描述：</p><br><p>1.简介：</p><br><p>Diffie-Hellman:一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm).这个机制的巧妙在于需要安全通信的双方可以<span style="color:#ff0000">用这个方法确定<strong>对称密钥</strong></span>。然后可以用这个密钥进行加密和解密。但是注意，<span style="color:#ff0000">这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密</span>。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。<br><br></p><br><p>就是说，DH算法是用来安全地交换密钥的</p><br><p>2.算法描述：</p><br><p>基于原根的定义及性质，可以定义Diffie-Hellman密钥交换算法.该算法描述如下：<br><br>1，有两个全局公开的参数，一个素数q和一个整数a,a是q的一个原根.<br><br>2，假设用户A和B希望交换一个密钥，用户A选择一个作为私有密钥的随机数XA(XA&lt;q)，并计算公开密钥YA=a^XA mod q。A对XA的&#20540;保密存放而使YA能被B公开获得。类&#20284;地，用户B选择一个私有的随机数XB&lt;q，并计算公开密钥YB=a^XB mod q。B对XB的&#20540;保密存放而使YB能被A公开获得.<br><br>3，用户A产生共享秘密密钥的计算方式是K = (YB)^XA mod q.同样，用户B产生共享秘密密钥的计算是K = (YA)^XB mod q.这两个计算产生相同的结果： K = (YB)^XA mod q = (a^XB mod q)^XA mod q = (a^XB)^XA mod q （根据取模运算规则得到） = a^(XBXA) mod q = (a^XA)^XB mod q = (a^XA mod q)^XB mod q = (YA)^XB mod q 因此相当于双方已经交换了一个相同的秘密密钥.<br><br>4，因为XA和XB是保密的，一个敌对方可以利用的参数只有q,a,YA和YB.因而敌对方被迫取离散对数来确定密钥.例如，要获取用户B的秘密密钥，敌对方必须先计算 XB = inda,q(YB) 然后再使用用户B采用的同样方法计算其秘密密钥K. Diffie-Hellman密钥交换算法的安全性依赖于这样一个事实：<span style="color:#ff0000">虽然计算以一个素数为模的指数相对容易，但计算离散对数却很困难</span>.对于大的素数，计算出离散对数几乎是不可能的. 下面给出例子.密钥交换基于素数q<br> = 97和97的一个原根a = 5.A和B分别选择私有密钥XA = 36和XB = 58.每人计算其公开密钥 YA = 5^36 = 50 mod 97 YB = 5^58 = 44 mod 97 在他们相互获取了公开密钥之后，各自通过计算得到双方共享的秘密密钥如下： K = (YB)^XA mod 97 = 44^36 = 75 mod 97 K = (YA)^XB mod 97 = 50^58 = 75 mod 97 从|50,44|出发，攻击者要计算出75很不容易. 下图给出了一个利用Diffie-Hellman计算的简单协议.<br><br></p><br><p><br><br></p><br><p>二、算法JAVA实现：</p><br><p>开始之前声明一下有一点还是不太明白：</p><br><p>假设甲方给乙方传数据，算法的实现要求乙方构建密钥时必须用甲方公钥构建乙方密钥。我自己是这样理解的：在实际实现的过程中，很难传递双方共享素数q及其元根α，因此采取这样的措施。</p><br><p>那么我们在接下的实现约定以下几个原则：</p><br><p>1.本地密钥：加密数据用的密钥</p><br><p>2.密钥=公钥&#43;私钥，甲乙有自己的不相同的密钥，用来加密本地密钥</p><br><p>3.一方的密钥由Init()直接产生，另一方的密钥构建需用到已构建方的公钥</p><br><p><br><br></p><br><p>首先，对全局变量声明：</p><br><p><pre name="code" class="java">&lt;span style=&quot;white-space:pre&quot;&gt;    &lt;/span&gt;private static final String KEY_ALGORITHM = &quot;DH&quot;;<br>    private static final String SECRET_ALGORITHM = &quot;AES&quot;;<br>    private static final int KEY_SIZE=512;<br>    private static final String PUBLIC_KEY=&quot;DHPublicKey&quot;;<br>    private static final String PRIVATE_KEY=&quot;DHPrivateKey&quot;;</pre><br><br></p><br><p>复习一下对称加密中产生密钥的三种方法：</p><br><p><pre name="code" class="plain">产生secretKey的三种方法：<br>a.凭空产生：KeyGenerator类对象获得SecretKey类对象：init()-&gt;generatorKey()<br>b.通过byte[]数组产生：密钥工厂利用密钥材料生成SecretKey：secretKeyFactory.generateSecretKey(dks);<br>c.通过byte[]数组产生：密钥材料类初始化成父类SecretKey</pre><br><br><br><br></p><br><p>构建DH甲方密钥对：凭空产生：<strong><span style="color:#ff0000">keyGenerator </span></strong>-&gt; keyPair -&gt;publicKey,privateKey. 最后用map对象返回，分别对应键: PUBLIC_KEY,PRIVATE_KEY</p><br><p><pre name="code" class="java">&lt;span style=&quot;white-space:pre&quot;&gt;    &lt;/span&gt;public static Map&lt;String,Object&gt; initKey() throws NoSuchAlgorithmException{<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM);<br>        keyPairGenerator.initialize(KEY_SIZE);<br>        KeyPair keyPair = keyPairGenerator.generateKeyPair();<br>        PublicKey publicKey = keyPair.getPublic();<br>        PrivateKey privateKey = keyPair.getPrivate();<br>        Map&lt;String,Object&gt; keyMap = new HashMap&lt;String,Object&gt;(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }</pre><br><br>构建DH乙方密钥对：由甲方公钥产生：由byte[]-&gt;密钥材料-&gt;密钥工厂还原甲方公钥-&gt;-&gt;密钥材料DHParameterSpec-&gt;keyPariGenerator初始化成keyPairGenerator</p><br><p>就是一个byte[]-&gt;材料-&gt;密钥-&gt;材料-&gt;密钥；2.3步为还原甲密钥，4.5步产生乙密钥</p><br><p><strong><span style="color:#ff0000">至此得出一个结论：密钥共厂可以把密钥材料转换成密钥</span></strong></p><br><p><strong><span style="color:#ff0000"><em>Spec这样的材料类可以把byte[]或密钥转成密钥材料</em></span></strong></p><br><p><pre name="code" class="java">public static Map&lt;String,Object&gt; initKey(byte[] key) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidAlgorithmParameterException{<br>        //拿到传进来的公钥<br>        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(key);<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        PublicKey pubKey = keyFactory.generatePublic(x509EncodedKeySpec);//Cannot make a static reference to the non-static method generatePublic(KeySpec) from the type KeyFactory<br><br>        //传进来的公钥构造密钥材料<br>        DHParameterSpec dhParameter = ((DHPublicKey)pubKey).getParams();<br><br>        //产生乙方公钥，私钥<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyFactory.getAlgorithm());<br>        keyPairGenerator.initialize(dhParameter);<br>        KeyPair keyPair = keyPairGenerator.genKeyPair();<br>        DHPublicKey publicKey = (DHPublicKey)keyPair.getPublic();<br>        DHPrivateKey privateKey = (DHPrivateKey)keyPair.getPrivate();<br><br>        Map&lt;String,Object&gt; keyMap = new HashMap&lt;String,Object&gt;(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }</pre><br><br>构建本地密钥代码：</p><br><p><pre name="code" class="java">&lt;span style=&quot;white-space:pre&quot;&gt;    &lt;/span&gt;public static byte[] getSecretKey(byte[] publicKey,byte[] privateKey) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException{<br>        //通过KeyFactory还原密钥，注意公私钥的材料类<br>        //byte[] -&gt;密钥材料-&gt;密钥<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(publicKey);<br>        PublicKey pubKey = keyFactory.generatePublic(x509EncodedKeySpec);<br><br>        PKCS8EncodedKeySpec  pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKey);<br>        PrivateKey priKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec);<br><br>        //实例化<br>        KeyAgreement keyAgree = KeyAgreement.getInstance(KEY_ALGORITHM);<br>        keyAgree.init(priKey);<br>        keyAgree.doPhase(pubKey, true);<br><br>        SecretKey secretKey = keyAgree.generateSecret(SECRET_ALGORITHM);<br>        return secretKey.getEncoded();<br>    }</pre><br><br>keyAgreement类实现公钥密码学产生本地密钥SecretKey</p><br><p>keyAgree,init(私钥)-&gt;doPhase(公钥，true)-&gt;generateSecretKey()</p><br><p><br><br></p><br><p>DHCoder实现：</p><br><p><pre name="code" class="java">public abstract class DHCoder {<br>    private static final String KEY_ALGORITHM = &quot;DH&quot;;<br>    private static final String SECRET_ALGORITHM = &quot;AES&quot;;<br>    private static final int KEY_SIZE=512;<br>    private static final String PUBLIC_KEY=&quot;DHPublicKey&quot;;<br>    private static final String PRIVATE_KEY=&quot;DHPrivateKey&quot;;<br><br>    public static Map&lt;String,Object&gt; initKey() throws NoSuchAlgorithmException{<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM);<br>        keyPairGenerator.initialize(KEY_SIZE);<br>        KeyPair keyPair = keyPairGenerator.generateKeyPair();<br>        PublicKey publicKey = keyPair.getPublic();<br>        PrivateKey privateKey = keyPair.getPrivate();<br>        Map&lt;String,Object&gt; keyMap = new HashMap&lt;String,Object&gt;(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }<br><br>    public static Map&lt;String,Object&gt; initKey(byte[] key) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidAlgorithmParameterException{<br>        //拿到传进来的公钥<br>        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(key);<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        PublicKey pubKey = keyFactory.generatePublic(x509EncodedKeySpec);//Cannot make a static reference to the non-static method generatePublic(KeySpec) from the type KeyFactory<br><br>        //传进来的公钥构造密钥材料<br>        DHParameterSpec dhParameter = ((DHPublicKey)pubKey).getParams();<br><br>        //产生乙方公钥，私钥<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyFactory.getAlgorithm());<br>        keyPairGenerator.initialize(dhParameter);<br>        KeyPair keyPair = keyPairGenerator.genKeyPair();<br>        DHPublicKey publicKey = (DHPublicKey)keyPair.getPublic();<br>        DHPrivateKey privateKey = (DHPrivateKey)keyPair.getPrivate();<br><br>        Map&lt;String,Object&gt; keyMap = new HashMap&lt;String,Object&gt;(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br><br><br>    }<br><br><br>    public static byte[] encrypt(byte[] data,byte[]key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{<br>        SecretKey secretKey = new SecretKeySpec(key,SECRET_ALGORITHM);<br>        Cipher cipher = Cipher.getInstance(SECRET_ALGORITHM);<br>        cipher.init(Cipher.ENCRYPT_MODE, secretKey);<br>        return cipher.doFinal(data);<br>    }<br><br>    public static byte[] decrypt(byte[] data,byte[]key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{<br>        SecretKey secretKey = new SecretKeySpec(key,SECRET_ALGORITHM);<br>        Cipher cipher = Cipher.getInstance(SECRET_ALGORITHM);<br>        cipher.init(Cipher.DECRYPT_MODE, secretKey);<br>        return cipher.doFinal(data);<br>    }<br><br>    public static byte[] getSecretKey(byte[] publicKey,byte[] privateKey) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException{<br>        //通过KeyFactory还原密钥，注意公私钥的材料类<br>        //byte[] -&gt;密钥材料-&gt;密钥<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(publicKey);<br>        PublicKey pubKey = keyFactory.generatePublic(x509EncodedKeySpec);<br><br>        PKCS8EncodedKeySpec  pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKey);<br>        PrivateKey priKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec);<br><br>        //实例化<br>        KeyAgreement keyAgree = KeyAgreement.getInstance(KEY_ALGORITHM);<br>        keyAgree.init(priKey);<br>        keyAgree.doPhase(pubKey, true);<br><br>        SecretKey secretKey = keyAgree.generateSecret(SECRET_ALGORITHM);<br>        return secretKey.getEncoded();<br>    }<br><br>    public static byte[] getPrivateKey(Map&lt;String,Object&gt; keyMap){<br>        Key key = (Key)keyMap.get(PRIVATE_KEY);<br>        return key.getEncoded();<br>    }<br><br>    public static byte[] getPublicKey(Map&lt;String,Object&gt; keyMap){<br>        Key key = (Key)keyMap.get(PUBLIC_KEY);<br>        return key.getEncoded();<br>    }<br><br><br><br>}</pre><br><br><br><br></p><br><p>三、DH算法测试用例：</p><br><p>测试两个东西：</p><br><p>1.甲乙方本地密钥应相同；</p><br><p>2.加解密能否互相实现；</p><br><p><pre name="code" class="java">public class DHCoderTest {<br>    private byte[] publicKey1;<br>    private byte[] privateKey1;<br>    private byte[] key1;<br>    private byte[] publicKey2;<br>    private byte[] privateKey2;<br>    private byte[] key2;<br><br>    @Before<br>    public final void initKey() throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidAlgorithmParameterException, InvalidKeyException{<br>        Map&lt;String,Object&gt; keyMap1 = DHCoder.initKey();<br>        publicKey1 = DHCoder.getPublicKey(keyMap1);<br>        privateKey1 = DHCoder.getPrivateKey(keyMap1);<br>        System.err.println(&quot;甲方公钥：\n&quot;+Base64.encodeBase64String(publicKey1));<br>        System.err.println(&quot;甲方私钥：\n&quot;+Base64.encodeBase64String(privateKey1));<br><br>        //甲方公钥产生乙方公私钥<br>        Map&lt;String,Object&gt; keyMap2 = DHCoder.initKey(publicKey1);<br>        publicKey2 = DHCoder.getPublicKey(keyMap2);<br>        privateKey2 = DHCoder.getPrivateKey(keyMap2);<br>        System.err.println(&quot;乙方公钥：\n&quot;+Base64.encodeBase64String(publicKey2));<br>        System.err.println(&quot;乙方私钥：\n&quot;+Base64.encodeBase64String(privateKey2));<br><br>        key1 = DHCoder.getSecretKey(publicKey2, privateKey1);<br>        key2 = DHCoder.getSecretKey(publicKey1, privateKey2);<br>        System.err.println(&quot;甲方本地密钥：\n&quot;+Base64.encodeBase64String(key1));<br>        System.err.println(&quot;乙方本地密钥：\n&quot;+Base64.encodeBase64String(key2));<br><br>        assertArrayEquals(key1,key2);<br><br>    }<br><br>    @Test<br>    public final void test() throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {<br>        System.err.println(&quot;\n=====甲方向乙方发送加密数据=====&quot;);<br>        String input1=&quot;密钥交换算法&quot;;<br>        System.err.println(&quot;原文： &quot;+input1);<br>        System.err.println(&quot;—使用甲方密钥对本地数据加密—&quot;);<br><br>        byte[] code1=DHCoder.encrypt(input1.getBytes(), key1);<br>        System.err.println(&quot;加密： &quot;+Base64.encodeBase64String(code1));<br>        System.err.println(&quot;—使用乙方密钥对本地数据解密—&quot;);<br><br>        byte[] decode1 = DHCoder.decrypt(code1, key2);<br>        String output1= new String(decode1);<br>        System.err.println(&quot;解密：  &quot;+output1);<br><br>        assertEquals(input1,output1);<br><br>        System.err.println(&quot;\n=====乙方向甲方发送加密数据=====&quot;);<br>        String input2=&quot;DH&quot;;<br>        System.err.println(&quot;原文： &quot;+input2);<br>        System.err.println(&quot;—使用乙方密钥对本地数据加密—&quot;);<br><br>        byte[] code2=DHCoder.encrypt(input2.getBytes(), key2);<br>        System.err.println(&quot;加密： &quot;+Base64.encodeBase64String(code2));<br>        System.err.println(&quot;—使用甲方密钥对本地数据解密—&quot;);<br><br>        byte[] decode2 = DHCoder.decrypt(code2, key1);<br>        String output2= new String(decode2);<br>        System.err.println(&quot;解密：  &quot;+output2);<br><br>        assertEquals(input2,output2);<br><br>    }<br></pre><br><br><strong>输出：</strong></p><br><p>甲方公钥：<br><br>MIHgMIGXBgkqhkiG9w0BAwEwgYkCQQD8poLOjhLKuibvzPcRDlJtsHiwXt7LzR60ogjzrhYXrgHzW5Gkfm32NBPF4S7QiZvNEyrNUNmRUb3EPuc3WS4XAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC&#43;eUykAgIBgANEAAJBAJv7XJrlaOYCIPZ1vZc2Ol5GnvYQNWWcoeNPjNbzPW5keT5p1rl3mwLJdDnOI1Qwh9pw3vmQirNsBMhacKvu0I4=<br><br>甲方私钥：<br><br>MIHSAgEAMIGXBgkqhkiG9w0BAwEwgYkCQQD8poLOjhLKuibvzPcRDlJtsHiwXt7LzR60ogjzrhYXrgHzW5Gkfm32NBPF4S7QiZvNEyrNUNmRUb3EPuc3WS4XAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC&#43;eUykAgIBgAQzAjEA9dZOTVebQERSfblRNYIRob8g6g24V2DINCnEXwJTlYVdHIV5PLyjbWzn48eb2NIg<br><br>乙方公钥：<br><br>MIHgMIGXBgkqhkiG9w0BAwEwgYkCQQD8poLOjhLKuibvzPcRDlJtsHiwXt7LzR60ogjzrhYXrgHzW5Gkfm32NBPF4S7QiZvNEyrNUNmRUb3EPuc3WS4XAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC&#43;eUykAgIBgANEAAJBAJZ304pW1u5XRkEgyasNNV3Vy74yPPjTCNU5tbqbSnGDKKsBhjagSoMdJ21HiAPeU0NFIeZdPPYI2vu55ETQJOA=<br><br>乙方私钥：<br><br>MIHSAgEAMIGXBgkqhkiG9w0BAwEwgYkCQQD8poLOjhLKuibvzPcRDlJtsHiwXt7LzR60ogjzrhYXrgHzW5Gkfm32NBPF4S7QiZvNEyrNUNmRUb3EPuc3WS4XAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC&#43;eUykAgIBgAQzAjEA2jSKn/s21Yirb9HBIxrH2l9B6HI59s7Nvk5FOafpr0VqpigbdFV6fLUDURUUWOdb<br><br>甲方本地密钥：<br><br>gJyxRUpxSSxl6ibLr6LfIs9rTr7k9XxFKwhGqaOFy5U=<br><br>乙方本地密钥：<br><br>gJyxRUpxSSxl6ibLr6LfIs9rTr7k9XxFKwhGqaOFy5U=<br><br><br><br><br><br>=====甲方向乙方发送加密数据=====<br><br>原文： 密钥交换算法<br><br>—使用甲方密钥对本地数据加密—<br><br>加密： VqM0WkF0M8j1UURMOd9QRg==<br><br>—使用乙方密钥对本地数据解密—<br><br>解密： &nbsp;密钥交换算法<br><br><br><br><br><br>=====乙方向甲方发送加密数据=====<br><br>原文： DH<br><br>—使用乙方密钥对本地数据加密—<br><br>加密： faq8AO4Joy1s6k6/k3JVUw==<br><br>—使用甲方密钥对本地数据解密—<br><br>解密： &nbsp;DH<br><br></p><br><p><br><br></p><br><p>这里选择的密钥长度是512位，若选择1024位就更长了</p><br><p>DH算法支持密钥长度为64倍数，512~1024.长度与安全强度正比，运算时间反比</p><br><p>对称加密算法可选择DES，DESede,AES 等</p><br><p>合理选择密钥长度及算法是构建DH算法密码系统关键。</p><br><p><br><br></p><br><p>四、System.out.println()与System.err.println();</p><br><p>System.out.println();是标准输出，输出黑色<br><br>System.err.println();是标准错误输出，输出红色<br><br><br><br><br><br>默认的话都是写往控制台，从操作系统的实现上讲<br><br>标准输出 一般有默认有缓存<br><br>标准错误输出 一般没有缓存<br><br></p><br><p><br><br></p><br><p>System.out.println 能重定向到别的输出流，这样的话你在屏幕上将看不到打印的东西了，<br><br>而System.err.println只能在屏幕上实现打印，即使你重定向了也一样。<br><br></p><br><link rel="stylesheet" href="http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0"><br>            </div><br>        <br>        <div class="readall_box csdn-tracking-statistics" data-mod="popu_376"><br>            <div class="read_more_mask"></div><br>            <a class="btn btn-large btn-gray-fred read_more_btn" target="_self">阅读全文</a><br>        </div><br>        <div class="article_copyright"><br>            <h4>实例代码</h4><br>    DHCoder.java<br>    <pre name="code" class="java"><br>      package com.dtb.member.test;<br><br>import java.security.Key;<br>import java.security.KeyFactory;<br>import java.security.KeyPair;<br>import java.security.KeyPairGenerator;<br>import java.security.PrivateKey;<br>import java.security.PublicKey;<br>import java.security.spec.PKCS8EncodedKeySpec;<br>import java.security.spec.X509EncodedKeySpec;<br>import java.util.HashMap;<br>import java.util.Map;<br><br>import javax.crypto.Cipher;<br>import javax.crypto.KeyAgreement;<br>import javax.crypto.SecretKey;<br>import javax.crypto.interfaces.DHPrivateKey;<br>import javax.crypto.interfaces.DHPublicKey;<br>import javax.crypto.spec.DHParameterSpec;<br>import javax.crypto.spec.SecretKeySpec;<br><br>import com.sun.org.apache.xml.internal.security.utils.Base64;<br><br>public class DHCoder {<br>    /<strong><br>     <em> 非对称加密密钥算法 
     </em>/<br>    private static final String KEY_ALGORITHM = “DH”;<br>    /</strong><br>     <em> 本地密钥算法，即对称加密密钥算法 
     </em> 可选DES、DESede或者AES<br>     <em>/<br>    private static final String SELECT_ALGORITHM = “AES”;<br>    /** 
     </em> 密钥长度<br>     <em>/<br>    private static final int KEY_SIZE = 512;<br>    //公钥<br>    private static final String PUBLIC_KEY = “DHPublicKey”;<br>    //私钥<br>    private static final String PRIVATE_KEY = “DHPrivateKey”;<br><br>    /** 
     </em> 初始化甲方密钥<br>     <em> @return Map 甲方密钥Map 
     </em> @throws Exception<br>     <em>/<br>    public static Map<string, object=""> initKey() throws Exception{<br>        //实例化密钥对生成器<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM);<br>        //初始化密钥对生成器<br>        keyPairGenerator.initialize(KEY_SIZE);<br>        //生成密钥对<br>        KeyPair keyPair = keyPairGenerator.generateKeyPair();<br>        //甲方公钥<br>        DHPublicKey publicKey = (DHPublicKey)keyPair.getPublic();<br>        //甲方私钥<br>        DHPrivateKey privateKey = (DHPrivateKey)keyPair.getPrivate();<br>        //将密钥对存储在Map中<br>        Map<string, object=""> keyMap = new HashMap<string, object="">(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }<br><br>    /** 
     </string,></string,></string,></em> 初始化乙方密钥<br>     <em> @param key 甲方公钥 
     </em> @return Map 乙方密钥Map<br>     <em> @throws Exception 
     </em>/<br>    public static Map<string, object=""> initKey(byte[] key) throws Exception{<br>        //解析甲方公钥<br>        //转换公钥材料<br>        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(key);<br>        //实例化密钥工厂<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        //产生公钥<br>        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);<br>        //由甲方公钥构建乙方密钥<br>        DHParameterSpec dhParameterSpec = ((DHPublicKey)pubKey).getParams();<br>        //实例化密钥对生成器<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM);<br>        //初始化密钥对生成器<br>        keyPairGenerator.initialize(dhParameterSpec);<br>        //产生密钥对<br>        KeyPair keyPair = keyPairGenerator.generateKeyPair();<br>        //乙方公钥<br>        DHPublicKey publicKey = (DHPublicKey) keyPair.getPublic();<br>        //乙方私约<br>        DHPrivateKey privateKey = (DHPrivateKey) keyPair.getPrivate();<br>        //将密钥对存储在Map中<br>        Map<string, object=""> keyMap = new HashMap<string, object="">(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }<br><br>    /<strong><br>     <em> 加密 
     </em> @param data 待加密数据<br>     <em> @param key 密钥 
     </em> @return byte[] 加密数据<br>     <em> @throws Exception 
     </em>/<br>    public static byte[] encrypt(byte[] data, byte[] key) throws Exception{<br>        //生成本地密钥<br>        SecretKey secretKey = new SecretKeySpec(key, SELECT_ALGORITHM);<br>        //数据加密  -这里使用到加密算法超长，所以简单用代码演示加密解密 ，其重点在于 双方都能使用同一个密匙<br>//        Cipher cipher = Cipher.getInstance(SELECT_ALGORITHM);<br>//        cipher.init(Cipher.ENCRYPT_MODE, secretKey);<br>//        return cipher.doFinal(data);<br>        return (new String(data)+Base64.encode(key)).getBytes();<br>    }<br><br>    /</strong><br>     <em> 解密 
     </em> @param data 待解密数据<br>     <em> @param key 密钥 
     </em> @return byte[] 解密数据<br>     <em> @throws Exception 
     </em>/<br>    public static byte[] decrypt(byte[] data, byte[] key) throws Exception{<br>        //生成本地密钥<br>        SecretKey secretKey = new SecretKeySpec(key, SELECT_ALGORITHM);<br>        //数据揭秘  -这里使用到加密算法超长，所以简单用代码演示加密解密 ，其重点在于 双方都能使用同一个密匙<br>//        Cipher cipher = Cipher.getInstance(secretKey.getAlgorithm());<br>//        cipher.init(Cipher.DECRYPT_MODE, secretKey);<br>//        return cipher.doFinal(data);<br>        String encode = Base64.encode(key);<br>        String dataStr = new String(data);<br>        String resultStr = dataStr.split(encode)[0];<br>        return resultStr.getBytes();<br>    }<br><br>    /<strong><br>     <em> 构建密钥 
     </em> @param publicKey 公钥<br>     <em> @param privateKey 私钥 
     </em> @return byte[] 本地密钥<br>     <em> @throws Exception 
     </em>/<br>    public static byte[] getSecretKey(byte[] publicKey, byte[] privateKey) throws Exception{<br>        //实例化密钥工厂<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        //初始化公钥<br>        //密钥材料转换<br>        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKey);<br>        //产生公钥<br>        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);<br>        //初始化私钥<br>        //密钥材料转换<br>        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(privateKey);<br>        //产生私钥<br>        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);<br>        //实例化<br>        KeyAgreement keyAgree = KeyAgreement.getInstance(keyFactory.getAlgorithm());<br>        //初始化<br>        keyAgree.init(priKey);<br>        keyAgree.doPhase(pubKey, true);<br>        //生成本地密钥<br>        SecretKey secretKey = keyAgree.generateSecret(SELECT_ALGORITHM);<br>        return secretKey.getEncoded();<br>    }<br><br>    /</strong><br>     <em> 取得私钥 
     </em> @param keyMap 密钥Map<br>     <em> @return byte[] 私钥 
     </em> @throws Exception<br>     <em>/<br>    public static byte[] getPrivateKey(Map<string, object=""> keyMap) throws Exception{<br>        Key key = (Key) keyMap.get(PRIVATE_KEY);<br>        return key.getEncoded();<br>    }<br><br>    /** 
     </string,></em> 取得公钥<br>     <em> @param keyMap 密钥Map 
     </em> @return byte[] 公钥<br>     <em> @throws Exception 
     </em>/<br>    public static byte[] getPublicKey(Map<string, object=""> keyMap) throws Exception{<br>        Key key = (Key) keyMap.get(PUBLIC_KEY);<br>        return key.getEncoded();<br>    }<br>}<br><br>    </string,></string,></string,></string,></pre><br>    DHTest.java<br>    <pre name="code" class="java"><br>    package com.dtb.member.test;<br><br>import java.util.Map;<br><br>import com.sun.org.apache.xml.internal.security.utils.Base64;<br><br><br>public class DHTest {<br>    //甲方公钥<br>    private static byte[] publicKey1;<br>    //甲方私钥<br>    private static byte[] privateKey1;<br>    //甲方本地密钥<br>    private static byte[] key1;<br>    //乙方公钥<br>    private static byte[] publicKey2;<br>    //乙方私钥<br>    private static byte[] privateKey2;<br>    //乙方本地密钥<br>    private static byte[] key2;<br><br>    /<strong><br>     <em> 初始化密钥 
     </em> @throws Exception<br>     */<br>    public static final void initKey() throws Exception{<br>        //生成甲方密钥对<br>        Map<string, object=""> keyMap1 = DHCoder.initKey();<br>        publicKey1 = DHCoder.getPublicKey(keyMap1);<br>        privateKey1 = DHCoder.getPrivateKey(keyMap1);<br>//        System.out.println(“甲方公钥:\n” + Base64.encodeBase64String(publicKey1));<br>//        System.out.println(“甲方私钥:\n” + Base64.encodeBase64String(privateKey1));<br>        System.out.println(“甲方公钥:\n” + Base64.encode(publicKey1));<br>        System.out.println(“甲方私钥:\n” + Base64.encode(privateKey1));<br>        //由甲方公钥产生本地密钥对<br>        Map<string, object=""> keyMap2 = DHCoder.initKey(publicKey1);<br>        publicKey2 = DHCoder.getPublicKey(keyMap2);<br>        privateKey2 = DHCoder.getPrivateKey(keyMap2);<br>        System.out.println(“乙方公钥:\n” + Base64.encode(publicKey2));<br>        System.out.println(“乙方私钥:\n” + Base64.encode(privateKey2));<br>        key1 = DHCoder.getSecretKey(publicKey2, privateKey1);<br>        System.out.println(“甲方本地密钥:\n” + Base64.encode(key1));<br>        key2 = DHCoder.getSecretKey(publicKey1, privateKey2);<br>        System.out.println(“乙方本地密钥:\n” + Base64.encode(key2));<br>    }<br><br>    /</string,></string,></strong><br>     <em> 主方法 
     </em> @param args<br>     <em> @throws Exception 
     </em>/<br>    public static void main(String[] args) throws Exception {<br>        // TODO Auto-generated method stub<br>        initKey();<br>        System.out.println();<br>        System.out.println(“===甲方向乙方发送加密数据===”);<br>        String input1 = “求知若饥，虚心若愚。”;<br>        System.out.println(“原文:\n” + input1);<br>        System.out.println(“—使用甲方本地密钥对数据进行加密—“);<br>        //使用甲方本地密钥对数据加密<br>        byte[] encode1 = DHCoder.encrypt(input1.getBytes(), key1);<br>        System.out.println(“加密:\n” + Base64.encode(encode1));<br>        System.out.println(“—使用乙方本地密钥对数据库进行解密—“);<br>        //使用乙方本地密钥对数据进行解密<br>        byte[] decode1 = DHCoder.decrypt(encode1, key2);<br>        String output1 = new String(decode1);<br>        System.out.println(“解密:\n” + output1);<br><br>        System.out.println(“/~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~..~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~/“);<br>        initKey();<br>        System.out.println(“===乙方向甲方发送加密数据===”);<br>        String input2 = “好好学习，天天向上。”;<br>        System.out.println(“原文:\n” + input2);<br>        System.out.println(“—使用乙方本地密钥对数据进行加密—“);<br>        //使用乙方本地密钥对数据进行加密<br>        byte[] encode2 = DHCoder.encrypt(input2.getBytes(), key2);<br>        System.out.println(“加密:\n” + Base64.encode(encode2));<br>        System.out.println(“—使用甲方本地密钥对数据进行解密—“);<br>        //使用甲方本地密钥对数据进行解密<br>        byte[] decode2 = DHCoder.decrypt(encode2, key1);<br>        String output2 = new String(decode2);<br>        System.out.println(“解密:\n” + output2);<br>    }<br>}<br><br>    </pre><br>        </div>


      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/13/zookeeper-01/" rel="next" title="基于Zookeeper的Redis Cache 高可用易扩容集群方案设计">
                <i class="fa fa-chevron-left"></i> 基于Zookeeper的Redis Cache 高可用易扩容集群方案设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/28/encryptionAlgorithm-01/" rel="prev" title="常见加密算法">
                常见加密算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://bloodorange2017.github.io/images/img_head_001.jpg"
               alt="XueCheng" />
          <p class="site-author-name" itemprop="name">XueCheng</p>
           
              <p class="site-description motion-element" itemprop="description">Do one thing at a time, and do well.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">64</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">实例代码</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XueCheng</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

<script type="text/javascript"
color="160,160,233" opacity='0.4' zIndex="-2" count="16" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
