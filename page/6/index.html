<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Do one thing at a time, and do well.">
<meta property="og:type" content="website">
<meta property="og:title" content="XueCheng Notes">
<meta property="og:url" content="https://bloodorange2017.github.io/archives/page/6/index.html">
<meta property="og:site_name" content="XueCheng Notes">
<meta property="og:description" content="Do one thing at a time, and do well.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XueCheng Notes">
<meta name="twitter:description" content="Do one thing at a time, and do well.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bloodorange2017.github.io/archives/page/6/"/>





  <title>XueCheng Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XueCheng Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Where there is a will, there is a way.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/06/01/guavaCache-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/01/guavaCache-01/" itemprop="url">转载:Guava Cache高速本地缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-01T15:03:48+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <div class="post_content"><br>      <p><a href="http://code.google.com/p/guava-libraries/wiki/CachesExplained" target="_blank">原文地址</a>  <a href="http://ifeve.com/google-guava-cachesexplained/" target="_blank">译文地址</a>    译者：许巧辉  校对：沈义扬</p><br><h2>范例</h2><br><pre class="brush: java; title: ; notranslate" title=""><br>LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()<br>        .maximumSize(1000)<br>        .expireAfterWrite(10, TimeUnit.MINUTES)<br>        .removalListener(MY_LISTENER)<br>        .build(<br>            new CacheLoader&lt;Key, Graph&gt;() {<br>                public Graph load(Key key) throws AnyException {<br>                    return createExpensiveGraph(key);<br>                }<br>        });<br></pre><br><p><span id="more-8711"></span></p><br><h2>适用性</h2><br><p>缓存在很多场景下都是相当有用的。例如，计算或检索一个值的代价很高，并且对同样的输入需要不止一次获取值的时候，就应当考虑使用缓存。</p><br><p align="left"><tt></tt><tt>Guava Cache与ConcurrentMap很相似，但也不完全一样。最基本的区别是ConcurrentMap会一直保存所有添加的元素，直到显式地移除。相对地，Guava Cache为了限制内存占用，通常都设定为自动回收元素。在某些场景下，尽管LoadingCache 不回收元素，它也是很有用的，因为它会自动加载缓存。</tt></p><br><p><tt>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/01/guavaCache-01/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/23/jvm-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/jvm-03/" itemprop="url">转载:03-jvm中堆栈以及内存区域分配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-23T14:45:12+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br><br><p><span style="white-space:pre"></span>堆栈这个概念存在于数据结构中，也存在于jvm虚拟机中，在这两个环境中是截然不同的意思。</p><br><p><span style="white-space:pre"></span>在数据结构中，堆栈是：堆 和栈两种数据结构，堆是完全二叉树，堆中各元素是有序的。在这个二叉树中所有的双亲节点和孩子节点存在着大小关系，如所有的双亲节点都大于孩子节点则 为大头堆，如果所有的双亲节点都小于其孩子节点说明这是一个小头堆，建堆的过程就是一个排序的过程，堆得查询效率也很高。栈是一种先进后出的线性表。</p><br><p><span style="white-space:pre"></span>在jvm虚拟机中得堆栈对应内存的不同区域，和数据结构中所说的堆栈是两码事。</p><br><p><span style="white-space:pre"></span>下面介绍jvm中得堆栈以及jvm内存分配：</p><br><p><span style="color:rgb(54,54,54); font-family:微软雅黑,Arial,Verdana,sans-serif; background-color:rgb(212,212,212)"></span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">JVM的体系结构如下：</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>如下图所示，JVM的体系结构包含几个主要的子系统和内存区：</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">类装载子系统</span>&nbsp;，负责把类从文件系统中装入内存</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">GC子系统</span>&nbsp;，垃圾收集器的主要工作室自动回收不再运行的程序引用对象所占用的内存，此外，它还可能负责那些还在使用的对象，以减少的堆碎片。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">内存区</span>&nbsp;，用于存储字节码，程序运行时创建的对象，传递给方法的参数，返回&#20540;，局部变量和中间计算结果。</p><br><div class="blog_content" style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">执行引擎：&nbsp;</span><br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>1、最简单的：一次性解释字节码。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>2、快，但消耗内存的：“即时编译器”，第一次被执行的字节码会被编译成机器代码，放入缓存，以后调用可以重用。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>3、自适应优化器，虚拟机开始的时候会解释字节码，但是会监视运行中程序的活动，并记录下使用最频繁的代码段。程序运行的时候，虚拟机只把使用最频繁的代码编译成本地代码，其他的代码由于使用的并不频繁，继续保留为字节码–由虚拟机继续解释他们。一般可以使java虚拟机80%~90%的时间里执行被优化过的本地代码，只需要编译10%~20%对性能优影响的代码。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>4、由硬件芯片组成，他用本地方法执行java字节码，这种执行引擎实际上是内嵌在芯片里的。</div><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><img src="http://i.imgur.com/ETKsm.jpg" alt="" width="500" height="390" style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; border-top-width:medium; border-right-width:medium; border-bottom-width:medium; border-left-width:medium; border-top-style:none; border-right-style:none; border-bottom-style:none; border-left-style:none; border-color:initial; vertical-align:middle"></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">2. Java的内存分配</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>在Java程序运行过程中，JVM定义了各种区域用于存储运行时数据。其中的有些数据区域在JVM启动时创建，并只在JVM退出时销毁。其它的数据区域与每个线程相关。这些数据区域，在线程创建时创建，在线程退出时销毁。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">2.1 程序计数器寄存器（The&nbsp;<code style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">pc</code>&nbsp;Register）</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>JVM支持多个线程同时运行。每个JVM都有自己的程序计数器。在任何一个点，每个JVM线程执行单个方法的代码，这个方法是线程的当前方法。如果方法不是native的，程序计数器寄存器包含了当前执行的JVM指令的地址，如果方法是 native的，程序计数器寄存器的&#20540;不会被定义。 JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">2.2 栈</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">1）栈与线程</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>JVM是基于栈的虚拟机.JVM为每个新创建的线程都分配一个栈.也就是说,对于一个Java程序来说，它的运行就是通过对栈的操作来完成的。栈以帧为单位保存线程的状态。JVM对栈只进行两种操作:以帧为单位的压栈和出栈操作。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的.</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>从Java的这种分配机制来看,堆栈又可以这样理解:栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">2）栈中的方法调用</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">嵌套方法的出栈和入栈示意图：</span></span>&nbsp;</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><img src="http://i.imgur.com/r4BpF.jpg" alt="" width="311" height="425" style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; border-top-width:medium; border-right-width:medium; border-bottom-width:medium; border-left-width:medium; border-top-style:none; border-right-style:none; border-bottom-style:none; border-left-style:none; border-color:initial; vertical-align:middle"></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>上图中描述了嵌套方法时，stack的内存分配图，由上面可以知道，当嵌套方法调用时，嵌套越深，stack的内存就越晚才能释放，因此，在实际开发过程中，不推荐大家使用递归来进行方法的调用，递归很容易导致stack flow。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">非嵌套方法的出栈入栈过程：</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><img src="http://i.imgur.com/NCQzk.jpg" alt="" width="500" height="325" style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; border-top-width:medium; border-right-width:medium; border-bottom-width:medium; border-left-width:medium; border-top-style:none; border-right-style:none; border-bottom-style:none; border-left-style:none; border-color:initial; vertical-align:middle"></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">2.3 堆</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C&#43;&#43;不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">2.4 堆和栈的区别</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">【下面的部分属于摘抄，描述比较好】</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方</span>&nbsp;。与C&#43;&#43;不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">2. 栈的优势是，存取速度比堆要快</span>&nbsp;，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">3. Java中的数据类型有两种：</span>&nbsp;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">一种是基本类型(primitive types),</span>&nbsp;共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int<br> a = 3; long b = 255L;的形式来定义的，称为自动变量。&#20540;得注意的是，自动变量存的是字面&#20540;，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面&#20540;。这些字面&#20540;的数据，由于大小可知，生存期可知(这些字面&#20540;固定定义在某个程序块里面，程序块退出后，字段&#20540;就消失了)，出于追求速度的原因，就存在于栈中。<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; int a = 3;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; int b = 3；<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面&#20540;为3的地址，没找到，就开辟一个存放3这个字面&#20540;的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面&#20540;，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; 特别注意的是，这种字面&#20540;的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面&#20540;的引用来修改其&#20540;，不会导致另一个指向此字面&#20540;的引用的&#20540;也跟着改变的情况。如上例，我们定义完a与b的&#20540;后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面&#20540;，如果没有，重新开辟地址存放4的&#20540;；如果已经有了，则直接将a指向这个地址。因此a&#20540;的改变不会影响到b的&#20540;。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp;&nbsp;<span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">另一种是包装类数据</span>&nbsp;，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">4. String是一个特殊的包装类数据</span>&nbsp;。即可以用String str = new String(&quot;abc&quot;);的形式来创建，也可以用String str = &quot;abc&quot;；的形式来创建(作为对比，在JDK<br> 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面&#20540;是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，&#20284;乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String<br> str = &quot;abc&quot;；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>5. 关于String str = &quot;abc&quot;的内部工作。<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>Java内部将此语句转化为以下几个步骤：&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>(1)先定义一个名为str的对String类的对象引用变量：String str；&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>(2)在栈中查找有没有存放&#20540;为&quot;abc&quot;的地址，如果没有，则开辟一个存放字面&#20540;为&quot;abc&quot;的地址，接着创建一个新的String类的对象o，并将o的字符串&#20540;指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了&#20540;为&quot;abc&quot;的地址，则查找对象o，并返回o的地址。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>(3)将str指向对象o的地址。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; &#20540;得注意的是，一般String类中字符串&#20540;都是直接存&#20540;的。但像String str = &quot;abc&quot;；这种场合下，其字符串&#20540;却是保存了一个指向存在栈中数据的引用！&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp;为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp;String str1 = &quot;abc&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp;String str2 = &quot;abc&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp;System.out.println(str1==str2); //true&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>注意，我们这里并不用str1.equals(str2)；的方式，因为这将比较两个字符串的&#20540;是否相等。“==”号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真&#20540;。而我们在这里要看的是，str1与str2是否都指向了同一个对象。结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; 我们再来更进一步，将以上代码改成：&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; String str1 = &quot;abc&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; String str2 = &quot;abc&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; str1 = &quot;bcd&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; System.out.println(str1 &#43; &quot;,&quot; &#43; str2); //bcd, abc&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; System.out.println(str1==str2); //false&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>这就是说，赋&#20540;的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的&#20540;改为&quot;bcd&quot;时，JVM发现在栈中没有存放该&#20540;的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的&#20540;指向这个地址。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其&#20540;，可以，但JVM在运行时根据新&#20540;悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; 再修改原来代码：&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; String str1 = &quot;abc&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; String str2 = &quot;abc&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; str1 = &quot;bcd&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; String str3 = str1;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; System.out.println(str3); //bcd&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; String str4 = &quot;bcd&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; System.out.println(str1 == str4); //true&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>str3这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其&#20540;后，再创建一个String的引用str4，并指向因str1修改&#20540;而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; 我们再接着看以下的代码。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; String str1 = new String(&quot;abc&quot;);&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; String str2 = &quot;abc&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>&nbsp; &nbsp; System.out.println(str1==str2); //false&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>String str1 = &quot;abc&quot;;&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>String str2 = new String(&quot;abc&quot;);&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>System.out.println(str1==str2); //false&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>以上两段代码说明，只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存&#20540;的，即使与栈中的数据相同，也不会与栈中的数据共享。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>6. 数据类型包装类的&#20540;不可修改。不仅仅是String类的&#20540;不可修改，所有的数据类型包装类都不能更改其内部的&#20540;。<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>7. 结论与建议：<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>(1)我们在使用诸如String str = &quot;abc&quot;；的&#26684;式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个&#20540;为&quot;abc&quot;的String类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>(2)使用String str = &quot;abc&quot;；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(&quot;abc&quot;)；的代码，则一概在堆中创建新对象，而不管其字符串&#20540;是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>(3)当比较包装类里面的数&#20540;是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用“==”。&nbsp;<br style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"><br>(4)由于String类的immutable性质，当String变量需要经常变换其&#20540;时，应该考虑使用StringBuffer类，以提高程序效率。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">2.5 方法区</span></p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>JVM有一个被所有的线程共享方法区。方法区类&#20284;于传统语言的编译后代码的存储区，或者UNIX进程中的text段。它存储每个类结构例如常量池（constant pool),成员字段域和方法和构造函数，包含类和实例初始化和接口类型类型中用到的特殊方法的代码。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>方法区在虚拟机启动时创建。尽管方法区在逻辑上时heap的一部分，简单的实现仍然可以选择对它既不回收也不压缩。</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br>The Java virtual machine has a&nbsp;<span style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">method area</span>&nbsp;that is shared among all Java virtual machine threads.<br> The method area is analogous to the storage area for compiled code of a conventional language or analogous to the &quot;text&quot; segment in a UNIX process. It stores per-class structures such as the runtime constant pool, field and method data, and the code for methods<br> and constructors, including the special methods&nbsp;(§3.9)&nbsp;used in class and instance initialization and interface type initialization.</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><a name="21952" style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; color:rgb(190,7,0); text-decoration:underline"></a>The method area is created on virtual machine<br> start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This version of the Java virtual machine specification does not mandate the location of the method area or the<br> policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.</p><br><p style="margin-top:1.12em; margin-bottom:1.12em; padding-top:0px; padding-bottom:0px"><br><a name="22992" style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; color:rgb(190,7,0); text-decoration:underline"></a>A Java virtual machine implementation may<br> provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.</p><br><p><br><br></p><br><p><span style="color:rgb(51,51,51); font-family:Arial,sans-serif; line-height:16px; background-color:rgb(0,0,0)"></span></p><br><p style="margin-bottom:24px">Java中变量分为静态变量，实例变量，临时变量。那么各种变量具体保存在JVM中的何处呢？</p><br><p style="margin-bottom:24px">1 静态变量：位于方法区。</p><br><p style="margin-bottom:24px">2 实例变量：作为对象的一部分，保存在堆中。</p><br><p style="margin-bottom:24px">3 临时变量：保存于栈中，栈随线程的创建而被分配。</p><br><p style="margin-bottom:24px">注：常量：位于常量池，而常量池位于方法区，若JVM采用的是分代垃圾回收，则方法区就是Perm区（永久存储区）。</p><br><br><br><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/23/jvm-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/jvm-02/" itemprop="url">转载:02-JVM原理和优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-23T14:42:00+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br><br><p>JVM工作原理和特点主要是指操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境. </p><br><p>1.创建JVM装载环境和配置 </p><br><p>2.装载JVM.dll </p><br><p>3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例 </p><br><p>4.调用JNIEnv实例装载并处理class类。 </p><br><p></p><br><p>在我们运行和调试Java程序的时候,经常会提到一个JVM的概念.JVM是Java程序运行的环境,但是他同时一个操作系统的一个应用程序一个进程,因此他也有他自己的运行的生命周期,也有自己的代码和数据空间.<br></p><br><p>首先来说一下JVM工作原理中的jdk这个东西,不管你是初学者还是高手,是j2ee程序员还是j2se程序员,jdk总是在帮我们做一些事情.我们在了解Java之前首先大师们会给我们提供说jdk这个东西.它在Java整个体系中充当着什么角色呢?我很惊叹sun大师们设计天才,能把一个如此完整的体系结构化的如此完美.jdk在这个体系中充当一个生产加工中心,产生所有的数据输出,是所有指令和战略的执行中心.本身它提供了Java的完整方案,可以开发目前Java能支持的所有应用和系统程序.这里说一个问题,大家会问,那为什么还有j2me,j2ee这些东西,这两个东西目的很简单,分别用来简化各自领域内的开发和构建过程.jdk除了JVM之外,还有一些核心的API,集成API,用户工具,开发技术,开发工具和API等组成<br></p><br><p>好了,废话说了那么多,来点于主题相关的东西吧.JVM在整个jdk中处于最底层,负责于操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也就虚拟计算机. 操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境.<br></p><br><p>1.创建JVM装载环境和配置 </p><br><p>2.装载JVM.dll </p><br><p>3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例 </p><br><p>4.调用JNIEnv实例装载并处理class类。 </p><br><p><strong>一．JVM装入环境，JVM提供的方式是操作系统的动态连接文件．</strong>既然是文件那就一个装入路径的问题，Java是怎么找这个路径的呢？当你在调用Java test的时候，操作系统会在path下在你的Java.exe程序，Java.exe就通过下面一个过程来确定JVM的路径和相关的参数配置了．下面基于Windows的实现的分析．<br></p><br><p>首先查找jre路径，Java是通过GetApplicationHome api来获得当前的Java.exe绝对路径，c:\j2sdk1.4.2_09\bin\Java.exe,那么它会截取到绝对路径c:\j2sdk1.4.2_09\，判断c:\j2sdk1.4.2_09\bin\Java.dll文件是否存在，如果存在就把c:\j2sdk1.4.2_09\作为jre路径，如果不存在则判断c:\j2sdk1.4.2_09\jre\bin\Java.dll是否存在，如果存在这c:\j2sdk1.4.2_09\jre作为jre路径．如果不存在调用GetPublicJREHome查HKEY_LOCAL_MACHINE\Software\JavaSoft\Java<br> Runtime Environment\“当前JRE版本号”\JavaHome的路径为jre路径。 </p><br><p>然后装载JVM.cfg文件JRE路径&#43;\lib&#43;\ARCH（CPU构架）&#43;\JVM.cfgARCH（CPU构架）的判断是通过Java_md.c中GetArch函数判断的，该函数中windows平台只有两种情况：WIN64的‘ia64’，其他情况都为‘i386’。以我的为例：C:\j2sdk1.4.2_09\jre\lib\i386\JVM.cfg.主要的内容如下：<br></p><br><pre><ol class="dp-xml"><li class="alt"><span>-client&nbsp;KNOWN&nbsp; &nbsp;</span></li><li><span>-server&nbsp;KNOWN&nbsp; &nbsp;</span></li><li class="alt"><span>-hotspot&nbsp;ALIASED_TO&nbsp;-client&nbsp; &nbsp;</span></li><li><span>-classic&nbsp;WARN&nbsp; &nbsp;</span></li><li class="alt"><span>-native&nbsp;ERROR&nbsp; &nbsp;</span></li><li><span>-green&nbsp;ERROR&nbsp;&nbsp;</span></li></ol></pre><br><p>在我们的jdk目录中jre\bin\server和jre\bin\client都有JVM.dll文件存在，而Java正是通过JVM.cfg配置文件来管理这些不同版本的JVM.dll的．通过文件我们可以定义目前jdk中支持那些JVM,前面部分（client）是JVM名称，后面是参数，KNOWN表示JVM存在，ALIASED_TO表示给别的JVM取一个别名，WARN表示不存在时找一个JVM替代，ERROR表示不存在抛出异常．在运行Java XXX是，Java.exe会通过CheckJVMType来检查当前的JVM类型，Java可以通过两种参数的方式来指定具体的JVM类型，一种按照JVM.cfg文件中的JVM名称指定，第二种方法是直接指定，它们执行的方法分别是“Java<br> -J”、“Java -XXaltJVM=”或“Java -J-XXaltJVM=”。如果是第一种参数传递方式，CheckJVMType函数会取参数‘-J’后面的JVM名称，然后从已知的JVM配置参数中查找如果找到同名的则去掉该JVM名称前的‘-’直接返回该&#20540;；而第二种方法，会直接返回“-XXaltJVM=”或“-J-XXaltJVM=”后面的JVM类型名称；如果在运行Java时未指定上面两种方法中的任一一种参数，CheckJVMType会取配置文件中第一个配置中的JVM名称，去掉名称前面的‘-’返回该&#20540;。CheckJVMType函数的这个返回&#20540;会在下面的函数中汇同jre路径组合成JVM.dll的绝对路径。如果没有指定这会使用JVM.cfg中第一个定义的JVM.可以通过set<br> _Java_LAUNCHER_DEBUG=1在控制台上测试． </p><br><p>最后获得JVM.dll的路径，JRE路径&#43;\bin&#43;\JVM类型字符串&#43;\JVM.dll就是JVM的文件路径了，但是如果在调用Java程序时用-XXaltJVM=参数指定的路径path,就直接用path&#43;\JVM.dll文件做为JVM.dll的文件路径．<br></p><br><p><strong>二：装载JVM.dll</strong> </p><br><p>通过第一步已经找到了JVM的路径，Java通过LoadJavaVM来装入JVM.dll文件．装入工作很简单就是调用Windows API函数： </p><br><p>LoadLibrary装载JVM.dll动态连接库．然后把JVM.dll中的导出函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMInitArgs挂接到InvocationFunctions变量的CreateJavaVM和GetDefaultJavaVMInitArgs函数指针变量上。JVM.dll的装载工作宣告完成。<br></p><br><p><strong>三：初始化JVM，获得本地调用接口，</strong>这样就可以在Java中调用JVM的函数了．调用InvocationFunctions－&gt;CreateJavaVM也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例．<br></p><br><p><strong>四：运行Java程序．</strong> </p><br><p>Java程序有两种方式一种是jar包，一种是class. 运行jar,Java -jar XXX.jar运行的时候，Java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用Java类Java.util.jar.JarFileJNIEnv中方法getManifest()并从返回的Manifest对象中取getAttributes(&quot;Main-Class&quot;)的&#20540;即jar包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。main函数直接调用Java.c中LoadClass方法装载该类。如果是执行class方法。main函数直接调用Java.c中LoadClass方法装载该类。<br></p><br><p>然后main函数调用JNIEnv实例的GetStaticMethodID方法查找装载的class主类中 </p><br><p>“public static void main(String[] args)”方法，并判断该方法是否为public方法，然后调用JNIEnv实例的 </p><br><p>CallStaticVoidMethod方法调用该Java类的main方法。&nbsp; </p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br>以下转自：<a target="_blank" href="http://blog.csdn.net/cnhzgb/article/details/7179419">http://blog.csdn.net/cnhzgb/article/details/7179419</a><span style="font-size:24px"><strong></strong></span></p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br><span style="font-size:24px"><strong>= GC 基础 =====================</strong></span></p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; font-size:12px; padding-top:2px"><br><br><br></p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; font-size:12px; padding-top:2px"><br>JAVA堆的描述如下：</p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; font-size:12px; padding-top:2px"><br><img alt="" src="http://hi.csdn.net/attachment/201201/6/0_1325814932X3Ts.gif"><br style="line-height:normal"><br>内存由 Perm 和 Heap 组成. 其中<br><br>Heap = {Old &#43; NEW = { Eden , from, to } }<br><br>JVM内存模型中分两大块，一块是 NEW Generation, 另一块是Old Generation. 在New Generation中，有一个叫Eden的空间，主要是用来存放新生的对象，还有两个Survivor Spaces（from,to）, 它们用来存放每次垃圾回收后存活下来的对象。在Old Generation中，主要存放应用程序中生命周期长的内存对象，还有个Permanent Generation，主要用来放JVM自己的反射对象，比如类对象和方法对象等。<br><br>垃圾回收描述：<br><br>在New Generation块中，垃圾回收一般用Copying的算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个Survivor Space, 当Survivor Space空间满了后, 剩下的live对象就被直接拷贝到Old Generation中去。因此，每次GC后，Eden内存块会被清空。在Old Generation块中，垃圾回收一般用mark-compact的算法，速度慢些，但减少内存要求.<br><br>垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收NEW中的垃圾，内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。<br><br><br><br><br><br>当一个URL被访问时，内存申请过程如下：<br><br>A. JVM会试图为相关Java对象在Eden中初始化一块内存区域<br><br>B. 当Eden空间足够时，内存申请结束。否则到下一步<br><br>C. JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）, 释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区<br><br>D. Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区<br><br>E. 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级）<br><br>F. 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”<br><br>JVM调优建议:<br><br>ms/mx：定义YOUNG&#43;OLD段的总尺寸，ms为JVM启动时YOUNG&#43;OLD的内存大小；mx为最大可占用的YOUNG&#43;OLD内存大小。在用户生产环境上一般将这两个&#20540;设为相同，以减少运行期间系统在内存申请上所花的开销。<br><br>NewSize/MaxNewSize：定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小；MaxNewSize为最大可占用的YOUNG内存大小。在用户生产环境上一般将这两个&#20540;设为相同，以减少运行期间系统在内存申请上所花的开销。<br><br>PermSize/MaxPermSize：定义Perm段的尺寸，PermSize为JVM启动时Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个&#20540;设为相同，以减少运行期间系统在内存申请上所花的开销。<br><br>SurvivorRatio：设置Survivor空间和Eden空间的比例<br><br>内存溢出的可能性<br><br><br><br><br><br>1. OLD段溢出<br><br>这种内存溢出是最常见的情况之一，产生的原因可能是：<br><br>1) 设置的内存参数过小(ms/mx, NewSize/MaxNewSize)<br><br>2) 程序问题<br><br>单个程序持续进行消耗内存的处理，如循环几千次的字符串处理，对字符串处理应建议使用StringBuffer。此时不会报内存溢出错，却会使系统持续垃圾收集，无法处理其它请求，相关问题程序可通过Thread Dump获取（见系统问题诊断一章）单个程序所申请内存过大，有的程序会申请几十乃至几百兆内存，此时JVM也会因无法申请到资源而出现内存溢出，对此首先要找到相关功能，然后交予程序员修改，要找到相关程序，必须在Apache日志中寻找。<br><br>当Java对象使用完毕后，其所引用的对象却没有销毁，使得JVM认为他还是活跃的对象而不进行回收，这样累计占用了大量内存而无法释放。由于目前市面上还没有对系统影响小的内存分析工具，故此时只能和程序员一起定位。<br><br>2. Perm段溢出<br><br>通常由于Perm段装载了大量的Servlet类而导致溢出，目前的解决办法：<br><br>1) 将PermSize扩大，一般256M能够满足要求<br><br>2) 若别无选择，则只能将servlet的路径加到CLASSPATH中，但一般不建议这么处理<br><br><br><br><br><br>3. C Heap溢出<br><br>系统对C Heap没有限制，故C Heap发生问题时，Java进程所占内存会持续增长，直到占用所有可用系统内存<br><br>其他：<br><br>JVM有2个GC线程。第一个线程负责回收Heap的Young区。第二个线程在Heap不足时，遍历Heap，将Young 区升级为Older区。Older区的大小等于-Xmx减去-Xmn，不能将-Xms的&#20540;设的过大，因为第二个线程被迫运行会降低JVM的性能。<br><br>为什么一些程序频繁发生GC？有如下原因：<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; 程序内调用了System.gc()或Runtime.gc()。<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; 一些中间件软件调用自己的GC方法，此时需要设置参数禁止这些GC。<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; Java的Heap太小，一般默认的Heap&#20540;都很小。<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; 频繁实例化对象，Release对象。此时尽量保存并重用对象，例如使用StringBuffer()和String()。<br><br>如果你发现每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态。许多Server端的Java程序每次GC后最好能有65%的剩余空间。<br><br>经验之谈：<br><br>1．Server端JVM最好将-Xms和-Xmx设为相同&#20540;。为了优化GC，最好让-Xmn&#20540;约等于-Xmx的1/3[2]。<br><br>2．一个GUI程序最好是每10到20秒间运行一次GC，每次在半秒之内完成[2]。<br><br>注意：<br><br>1．增加Heap的大小虽然会降低GC的频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。<br><br>2．Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的&#20540;，因为Java为其他任务分配内存，例如每个线程的Stack等。<br><br>2．Stack的设定<br><br>每个线程都有他自己的Stack。<br><br></p><br><div style="line-height:normal; background-color:white; zoom:1!important; word-wrap:break-word; visibility:visible!important; font-size:12px; word-break:break-all"><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><table border="1" cellspacing="0" cellpadding="0" width="90%" style="line-height:normal; background-color:rgb(238,204,255); width:856px; table-layout:auto!important"><br><tbody style="line-height:normal"><br><tr style="line-height:normal"><br><td style="padding-bottom:1.5pt; line-height:normal; padding-left:1.5pt; padding-right:1.5pt; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:12px; word-break:break-all; padding-top:1.5pt"><br><div align="left" style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><span style="line-height:normal; font-size:12pt">-Xss</span></div><br></td><br><td style="padding-bottom:1.5pt; line-height:normal; padding-left:1.5pt; padding-right:1.5pt; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:12px; word-break:break-all; padding-top:1.5pt"><br><div align="left" style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><span style="line-height:normal; font-size:12pt">每个线程的</span><span style="line-height:normal; font-size:12pt">Stack</span><span style="line-height:normal; font-size:12pt">大小</span></div><br></td><br></tr><br></tbody><br></table><br></p><br><div style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br>Stack的大小限制着线程的数量。如果Stack过大就好导致内存溢漏。-Xss参数决定Stack大小，例如-Xss1024K。如果Stack太小，也会导致Stack溢漏。<br><br>3．硬件环境<br><br>硬件环境也影响GC的效率，例如机器的种类，内存，swap空间，和CPU的数量。<br><br>如果你的程序需要频繁创建很多transient对象，会导致JVM频繁GC。这种情况你可以增加机器的内存，来减少Swap空间的使用[2]。<br><br>4．4种GC<br><br>第一种为单线程GC，也是默认的GC。，该GC适用于单CPU机器。<br><br>第二种为Throughput GC，是多线程的GC，适用于多CPU，使用大量线程的程序。第二种GC与第一种GC相&#20284;，不同在于GC在收集Young区是多线程的，但在Old区和第一种一样，仍然采用单线程。-XX:&#43;UseParallelGC参数启动该GC。<br><br>第三种为Concurrent Low Pause GC，类&#20284;于第一种，适用于多CPU，并要求缩短因GC造成程序停滞的时间。这种GC可以在Old区的回收同时，运行应用程序。-XX:&#43;UseConcMarkSweepGC参数启动该GC。<br><br>第四种为Incremental Low Pause GC，适用于要求缩短因GC造成程序停滞的时间。这种GC可以在Young区回收的同时，回收一部分Old区对象。-Xincgc参数启动该GC。<br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px"></span><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br><strong>按照基本回收策略分</strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">引用计数（Reference Counting）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">标记-清除（Mark-Sweep）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;<img alt="标记清楚" src="http://hi.csdn.net/attachment/201003/6/1981948_1267862317X1a1.png" width="573" height="230" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">复制（Copying）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><img alt="复制" src="http://hi.csdn.net/attachment/201003/6/1981948_1267862317ZvYy.png" width="573" height="230" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none">&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">标记-整理（Mark-Compact）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;<img alt="标记整理" src="http://hi.csdn.net/attachment/201003/6/1981948_1267862317X1a1.png" width="573" height="230" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p><br><h2 style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:0px"><br><a target="_blank" name="t0"></a><br><br>&nbsp;</h2><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br><strong>按分区对待的方式分</strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>增量收集（Incremental Collecting）:</strong></span>实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>分代收集（Generational Collecting）:</strong></span>基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br><strong>按系统线程分</strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">串行收集:</span></strong>串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">并行收集:</span></strong>并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。（串型收集的并发版本，需要暂停jvm） 并行paralise指的是多个任务在多个cpu中一起并行执行，最后将结果合并。效率是N倍。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>并发收集:</strong></span>相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。（和并行收集不同，并发只有在开头和结尾会暂停jvm）并发concurrent指的是多个任务在一个cpu伪同步执行，但其实是串行调度的，效率并非直接是N倍。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; padding-top:2px"><br><strong><span style="font-size:13px">分代垃圾回收</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp;&nbsp; 分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="font-size:16px"><img alt="jvm分代" src="http://hi.csdn.net/attachment/201003/6/1981948_12678645142BKS.png" width="574" height="318" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>如图所示：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;虚拟机中的共划分为三个代：<strong>年轻代（Young Generation）、年老点（Old Generation）和持久代（Permanent Generation）</strong>。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">年轻代:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来<br> 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">年老代:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>持久代:</strong></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=&lt;N&gt;进行设置。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; padding-top:2px"><br><strong><span style="font-size:13px">什么情况下触发垃圾回收&nbsp;</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<strong>Scavenge GC</strong>和<strong>Full GC</strong>。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">Scavenge GC</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">Full GC</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><br><blockquote style="font-family:Arial; font-size:14px"><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>· 年老代（Tenured）被写满</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>· 持久代（Perm）被写满&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>· System.gc()被显示调用&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>·上一次GC之后Heap的各域分配策略动态变化</p><br></blockquote><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程1" src="http://hi.csdn.net/attachment/201004/18/1981948_1271591242sfBp.jpg" width="482" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程2" src="http://hi.csdn.net/attachment/201004/18/1981948_12715912450bkp.png" width="413" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程3" src="http://hi.csdn.net/attachment/201004/18/1981948_1271591246383f.png" width="413" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程" src="http://hi.csdn.net/attachment/201004/18/1981948_1271591249sb6K.png" width="415" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><h2><a target="_blank" name="t1"></a><strong><span style="font-size:16px">= G1 ===================================</span></strong></h2><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>传说中的G1，传说中的low-pause垃圾收集。Java SE 6的update14版本中已经包含测试版，可以在启动时加JVM参数来启用</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'">-XX:&#43;UnlockExperimentalVMOptions -XX:&#43;UseG1GC</span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><a target="_blank" href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html">http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html</a><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'">本文摘自《构建高性能的大型分布式Java应用》一书，Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率，将作为CMS的替代者在JDK 7中闪亮登场，其最大的特色在于允许指定在某个时间段内GC所导致的应用暂停的时间最大为多少，例如在100秒内最多允许GC导致的应用暂停时间为1秒，这个特性对于准实时响应的系统而言非常的吸引人，这样就再也不用担心系统突然会暂停个两三秒了。</span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>G1要做到这样的效果，也是有前提的，一方面是硬件环境的要求，必须是多核的CPU以及较大的内存（从规范来看，512M以上就满足条件了），另外一方面是需要接受吞吐量的稍微降低，对于实时性要求高的系统而言，这点应该是可以接受的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>为了能够达到这样的效果，G1在原有的各种GC策略上进行了吸收和改进，在G1中可以看到增量收集器和CMS的影子，但它不仅仅是吸收原有GC策略的优点，并在此基础上做出了很多的改进，简单来说，G1吸收了增量GC以及CMS的精髓，将整个jvm Heap划分为多个固定大小的region，扫描时采用Snapshot-at-the-beginning的并发marking算法（具体在后面内容详细解释）对整个heap中的region进行mark，回收时根据region中活跃对象的bytes进行排序，首先回收活跃对象bytes小以及回收耗时短（预估出来的时间）的region，回收的方法为将此region中的活跃对象复制到另外的region中，根据指定的GC所能占用的时间来估算能回收多少region，这点和以前版本的Full<br> GC时得处理整个heap非常不同，这样就做到了能够尽量短时间的暂停应用，又能回收内存，由于这种策略在回收时首先回收的是垃圾对象所占空间最多的region，因此称为Garbage First。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>看完上面对于G1策略的简短描述，并不能清楚的掌握G1，在继续详细看G1的步骤之前，必须先明白G1对于JVM Heap的改造，这些对于习惯了划分为new generation、old generation的大家来说都有不少的新意。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>G1将Heap划分为多个固定大小的region，这也是G1能够实现控制GC导致的应用暂停时间的前提，region之间的对象引用通过remembered set来维护，每个region都有一个remembered set，remembered set中包含了引用当前region中对象的region的对象的pointer，由于同时应用也会造成这些region中对象的引用关系不断的发生改变，G1采用了Card Table来用于应用通知region修改remembered sets，Card Table由多个512字节的Card构成，这些Card在Card<br> Table中以1个字节来标识，每个应用的线程都有一个关联的remembered set log，用于缓存和顺序化线程运行时造成的对于card的修改，另外，还有一个全局的filled RS buffers，当应用线程执行时修改了card后，如果造成的改变仅为同一region中的对象之间的关联，则不记录remembered set log，如造成的改变为跨region中的对象的关联，则记录到线程的remembered set log，如线程的remembered set log满了，则放入全局的filled RS<br> buffers中，线程自身则重新创建一个新的remembered set log，remembered set本身也是一个由一堆cards构成的哈希表。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>尽管G1将Heap划分为了多个region，但其默认采用的仍然是分代的方式，只是仅简单的划分为了年轻代（young）和非年轻代，这也是由于G1仍然坚信大多数新创建的对象都是不需要长的生命周期的，对于应用新创建的对象，G1将其放入标识为young的region中，对于这些region，并不记录remembered set logs，扫描时只需扫描活跃的对象，G1在分代的方式上还可更细的划分为：fully young或partially young，fully young方式暂停的时候仅处理young regions，partially同样处理所有的young<br> regions，但它还会根据允许的GC的暂停时间来决定是否要加入其他的非young regions，G1是运行到fully-young方式还是partially young方式，外部是不能决定的，在启动时，G1采用的为fully-young方式，当G1完成一次Concurrent Marking后，则切换为partially young方式，随后G1跟踪每次回收的效率，如果回收fully-young中的regions已经可以满足内存需要的话，那么就切换回fully young方式，但当heap size的大小接近满的情况下，G1会切换到partially<br> young方式，以保证能提供足够的内存空间给应用使用。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>除了分代方式的划分外，G1还支持另外一种pure G1的方式，也就是不进行代的划分，pure方式和分代方式的具体不同在下面的具体执行步骤中进行描述。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>掌握了这些概念后，继续来看G1的具体执行步骤：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initial Marking</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>G1对于每个region都保存了两个标识用的bitmap，一个为previous marking bitmap，一个为next marking bitmap，bitmap中包含了一个bit的地址信息来指向对象的起始点。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>开始Initial Marking之前，首先并发的清空next marking bitmap，然后停止所有应用线程，并扫描标识出每个region中root可直接访问到的对象，将region中top的&#20540;放入next top at mark start（TAMS）中，之后恢复所有应用线程。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>触发这个步骤执行的条件为：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;G1定义了一个JVM Heap大小的百分比的阀&#20540;，称为h，另外还有一个H，H的&#20540;为(1-h)<em>Heap Size，目前这个h的&#20540;是固定的，后续G1也许会将其改为动态的，根据jvm的运行情况来动态的调整，在分代方式下，G1还定义了一个u以及soft limit，soft limit的&#20540;为H-u</em>Heap Size，当Heap中使用的内存超过了soft limit&#20540;时，就会在一次clean up执行完毕后在应用允许的GC暂停时间范围内尽快的执行此步骤；</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;在pure方式下，G1将marking与clean up组成一个环，以便clean up能充分的使用marking的信息，当clean up开始回收时，首先回收能够带来最多内存空间的regions，当经过多次的clean up，回收到没多少空间的regions时，G1重新初始化一个新的marking与clean up构成的环。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concurrent Marking</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>按照之前Initial Marking扫描到的对象进行遍历，以识别这些对象的下层对象的活跃状态，对于在此期间应用线程并发修改的对象的以来关系则记录到remembered set logs中，新创建的对象则放入比top&#20540;更高的地址区间中，这些新创建的对象默认状态即为活跃的，同时修改top&#20540;。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Final Marking Pause</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>当应用线程的remembered set logs未满时，是不会放入filled RS buffers中的，在这样的情况下，这些remebered set logs中记录的card的修改就会被更新了，因此需要这一步，这一步要做的就是把应用线程中存在的remembered set logs的内容进行处理，并相应的修改remembered sets，这一步需要暂停应用，并行的运行。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Live Data Counting and Cleanup</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>&#20540;得注意的是，在G1中，并不是说Final Marking Pause执行完了，就肯定执行Cleanup这步的，由于这步需要暂停应用，G1为了能够达到准实时的要求，需要根据用户指定的最大的GC造成的暂停时间来合理的规划什么时候执行Cleanup，另外还有几种情况也是会触发这个步骤的执行的：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;G1采用的是复制方法来进行收集，必须保证每次的”to space”的空间都是够的，因此G1采取的策略是当已经使用的内存空间达到了H时，就执行Cleanup这个步骤；</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;对于full-young和partially-young的分代模式的G1而言，则还有情况会触发Cleanup的执行，full-young模式下，G1根据应用可接受的暂停时间、回收young regions需要消耗的时间来估算出一个yound regions的数量&#20540;，当JVM中分配对象的young regions的数量达到此&#20540;时，Cleanup就会执行；partially-young模式下，则会尽量频繁的在应用可接受的暂停时间范围内执行Cleanup，并最大限度的去执行non-young regions的Cleanup。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>这一步中GC线程并行的扫描所有region，计算每个region中低于next TAMS&#20540;中marked data的大小，然后根据应用所期望的GC的短延时以及G1对于region回收所需的耗时的预估，排序region，将其中活跃的对象复制到其他region中。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><span style="font-size:14px">G1为了能够尽量的做到准实时的响应，例如估算暂停时间的算法、对于经常被引用的对象的特殊处理等，G1为了能够让GC既能够充分的回收内存，又能够尽量少的导致应用的暂停，可谓费尽心思，从G1的论文中的性能评测来看效果也是不错的，不过如果G1能允许开发人员在编写代码时指定哪些对象是不用mark的就更完美了，这对于有巨大缓存的应用而言，会有很大的帮助，G1将随JDK 6 Update 14&nbsp;beta发布。</span><br><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><h2><a target="_blank" name="t2"></a><span style="font-family:'Courier New'">= CMS ==================================</span></h2><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><a target="_blank" href="http://www.iteye.com/topic/1119491">http://www.iteye.com/topic/1119491</a><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><span></span></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><span style="font-size:13px"><strong>1.总体介绍：</strong></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。并发意味着除了开头和结束阶段，需要暂停JVM，其它时间gc和应用一起执行。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上<span style="color:#ff00">-XX:&#43;UseConcMarkSweepGC</span>&nbsp;，这个参数表示对于老年代的回收采用CMS。CMS采用的基础算法是：标记—清除。默认会开启 -XX :&#43;UseParNewGC，在年轻代使用并行复制收集。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><strong><span style="font-size:13px">2.CMS过程：</span></strong></p><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>初始标记(STW initial mark) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发标记(Concurrent marking) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发预清理(Concurrent precleaning) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>重新标记(STW remark) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发清理(Concurrent sweeping) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发重置(Concurrent reset)</li></ul><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>初始标记</strong>&nbsp;</span>：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的&quot;根对象&quot;开始，只扫描到能够和&quot;根对象&quot;直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>并发标记</strong>&nbsp;</span>：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><strong><span style="color:#3366ff">并发预清理</span>&nbsp;</strong>：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段&quot;重新标记&quot;的工作，因为下一个阶段会Stop The World。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>重新标记</strong>&nbsp;</span>：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从&quot;跟对象&quot;开始向下追溯，并处理对象关联。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><strong><span style="color:#3366ff">并发清理</span>&nbsp;</strong>：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>并发重置</strong>&nbsp;</span>：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>&nbsp;</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#ff00">CSM执行过程：</span>&nbsp;<br><br><img class="magplus" title="点击查看原始大小图片" alt="" src="http://dl.iteye.com/upload/attachment/612577/2b525609-ce63-3a42-bf19-b2fbcd42f26c.png" width="700" height="151" style="border-right-width:0px; border-top-width:0px; border-bottom-width:0px; border-left-width:0px"></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><strong><span style="font-size:13px">3.CMS缺点</span></strong></p><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>CMS回收器采用的基础算法是Mark-Sweep。所有CMS不会整理、压缩堆空间。这样就会有一个问题：经过CMS收集的堆会产生空间碎片。 CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空 间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。</li></ul><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>需要更多的CPU资源。从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。并且，重新标记阶段，为空保证STW快速完成，也要用到更多的甚至所有的CPU资源。当然，多核多CPU也是未来的趋势！</li></ul><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回 收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，已 避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用68%的时候，CMS就开始行动了。 – XX:CMSInitiatingOccupancyFraction =n 来设置这个阀&#20540;。</li></ul><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>总得来说，CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><span style="font-size:13px"><strong>4.啥时候用CMS</strong></span></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>如果你的应用程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU(也就是硬件牛&#36924;)，那么使用CMS来收集会给你带来好处。还有，如果在JVM中，有相对较多存活时间较长的对象(老年代比较大)会更适合使用CMS。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><h2><a target="_blank" name="t3"></a>= 调试工具 ==================================</h2><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px"><br><strong><span style="font-size:13px">jmap</span></strong></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jmap -heap pid &nbsp;(不能观察G1模式）</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>using parallel threads in the new generation.<br><br>using thread-local object allocation.<br><br>Concurrent Mark-Sweep GC<br><br><br><br>Heap Configuration:<br><br>&nbsp; &nbsp;MinHeapFreeRatio = 40<br><br>&nbsp; &nbsp;MaxHeapFreeRatio = 70<br><br>&nbsp; &nbsp;MaxHeapSize &nbsp; &nbsp; &nbsp;= 2147483648 (2048.0MB)<br><br>&nbsp; &nbsp;NewSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 268435456 (256.0MB)<br><br>&nbsp; &nbsp;MaxNewSize &nbsp; &nbsp; &nbsp; = 268435456 (256.0MB)<br><br>&nbsp; &nbsp;OldSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 805306368 (768.0MB)<br><br>&nbsp; &nbsp;NewRatio &nbsp; &nbsp; &nbsp; &nbsp; = 7<br><br>&nbsp; &nbsp;SurvivorRatio &nbsp; &nbsp;= 8<br><br>&nbsp; &nbsp;PermSize &nbsp; &nbsp; &nbsp; &nbsp; = 134217728 (128.0MB)<br><br>&nbsp; &nbsp;MaxPermSize &nbsp; &nbsp; &nbsp;= 134217728 (128.0MB)<br><br><br><br>Heap Usage:<br><br>New Generation (Eden &#43; 1 Survivor Space):<br><br>&nbsp; &nbsp;capacity = 241631232 (230.4375MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 145793088 (139.03912353515625MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 95838144 (91.39837646484375MB)<br><br>&nbsp; &nbsp;60.33702133340114% used<br><br>Eden Space:<br><br>&nbsp; &nbsp;capacity = 214827008 (204.875MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 132689456 (126.54252624511719MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 82137552 (78.33247375488281MB)<br><br>&nbsp; &nbsp;61.7657236095752% used<br><br>From Space:<br><br>&nbsp; &nbsp;capacity = 26804224 (25.5625MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 13103632 (12.496597290039062MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 13700592 (13.065902709960938MB)<br><br>&nbsp; &nbsp;48.886444166411984% used<br><br>To Space:<br><br>&nbsp; &nbsp;capacity = 26804224 (25.5625MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 0 (0.0MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 26804224 (25.5625MB)<br><br>&nbsp; &nbsp;0.0% used<br><br>concurrent mark-sweep generation: （old区）<br><br>&nbsp; &nbsp;capacity = 1879048192 (1792.0MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 1360638440 (1297.6059341430664MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 518409752 (494.3940658569336MB)<br><br>&nbsp; &nbsp;72.41104543209076% used<br><br>Perm Generation:<br><br>&nbsp; &nbsp;capacity = 134217728 (128.0MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 65435064 (62.40373992919922MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 68782664 (65.59626007080078MB)<br><br>&nbsp; &nbsp;48.75292181968689% used<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jmap -histo:live pid</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>num &nbsp; &nbsp; #instances &nbsp; &nbsp; &nbsp; &nbsp; #bytes &nbsp;class name<br><br>———————————————-<br><br>&nbsp; &nbsp;1: &nbsp; &nbsp; &nbsp; 3148147 &nbsp; &nbsp; &nbsp;209172848 &nbsp;[B<br><br>&nbsp; &nbsp;2: &nbsp; &nbsp; &nbsp; 2584345 &nbsp; &nbsp; &nbsp;144723320 &nbsp;java.lang.ref.SoftReference<br><br>&nbsp; &nbsp;3: &nbsp; &nbsp; &nbsp; 2578827 &nbsp; &nbsp; &nbsp;123783696 &nbsp;sun.misc.CacheEntry<br><br>&nbsp; &nbsp;4: &nbsp; &nbsp; &nbsp; &nbsp;781560 &nbsp; &nbsp; &nbsp;112544640 &nbsp;com.sun.net.ssl.internal.ssl.SSLSessionImpl<br><br>&nbsp; &nbsp;5: &nbsp; &nbsp; &nbsp; 1385200 &nbsp; &nbsp; &nbsp; 89970592 &nbsp;[C<br><br>&nbsp; &nbsp;6: &nbsp; &nbsp; &nbsp; &nbsp;783287 &nbsp; &nbsp; &nbsp; 87807200 &nbsp;[Ljava.util.Hashtable$Entry;<br><br>&nbsp; &nbsp;7: &nbsp; &nbsp; &nbsp; 1421399 &nbsp; &nbsp; &nbsp; 56855960 &nbsp;java.lang.String<br><br>&nbsp; &nbsp;8: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 &nbsp; &nbsp; &nbsp; 56828880 &nbsp;[Lsun.misc.CacheEntry;<br><br>&nbsp; &nbsp;9: &nbsp; &nbsp; &nbsp; 2343358 &nbsp; &nbsp; &nbsp; 56240592 &nbsp;com.sun.net.ssl.internal.ssl.SessionId<br><br>&nbsp; 10: &nbsp; &nbsp; &nbsp; &nbsp;783185 &nbsp; &nbsp; &nbsp; 50123840 &nbsp;java.util.Hashtable<br><br>&nbsp; 11: &nbsp; &nbsp; &nbsp; &nbsp;783094 &nbsp; &nbsp; &nbsp; 50118016 &nbsp;java.lang.ref.Finalizer<br><br>&nbsp; 12: &nbsp; &nbsp; &nbsp; &nbsp;287243 &nbsp; &nbsp; &nbsp; 36086720 &nbsp;[Ljava.lang.Object;<br><br>&nbsp; 13: &nbsp; &nbsp; &nbsp; &nbsp;263376 &nbsp; &nbsp; &nbsp; 33712128 &nbsp;org.apache.commons.pool.impl.GenericObjectPool<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><strong>jstat</strong></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jstat -gccause 31169 60000 1000<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>(sweep 1,2) (Eden) (Old) (Perm) (Young GC, GCTime)(Full GC, GCTime)</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>&nbsp; S0 &nbsp; &nbsp; &nbsp; &nbsp; S1 &nbsp; &nbsp; E &nbsp; &nbsp; &nbsp; &nbsp; O &nbsp; &nbsp; &nbsp; &nbsp; P &nbsp; &nbsp; YGC &nbsp; &nbsp; YGCT &nbsp; &nbsp; FGC &nbsp; &nbsp;FGCT &nbsp; &nbsp; &nbsp;GCT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LGCC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GCC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp;48.80 &nbsp; 0.00 &nbsp;68.94 &nbsp;69.55 &nbsp;48.86 &nbsp;30202 &nbsp;725.319 51835 5083.298 5808.616 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp;47.98 &nbsp; 0.00 &nbsp;37.47 &nbsp;69.61 &nbsp;48.86 &nbsp;30206 &nbsp;725.385 51835 5083.298 5808.682 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp;50.73 &nbsp; 0.00 &nbsp;51.72 &nbsp;69.65 &nbsp;48.86 &nbsp;30210 &nbsp;725.459 51835 5083.298 5808.757 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp; 0.00 &nbsp;50.02 &nbsp;82.67 &nbsp;69.60 &nbsp;48.84 &nbsp;30213 &nbsp;725.508 51836 5091.572 5817.081 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jstat -gcutil $pid</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>&nbsp; S0 &nbsp; &nbsp; &nbsp; &nbsp; S1 &nbsp; &nbsp; E &nbsp; &nbsp; &nbsp; &nbsp; O &nbsp; &nbsp; &nbsp; P &nbsp; &nbsp; &nbsp; YGC &nbsp; &nbsp; YGCT &nbsp; &nbsp;FGC &nbsp; &nbsp;FGCT &nbsp; &nbsp; GCT &nbsp;&nbsp;<br><br>&nbsp;74.79 &nbsp; 0.00 &nbsp;95.15 &nbsp; 0.86 &nbsp;37.35 &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp;0.112 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;0.000 &nbsp; &nbsp; &nbsp;0.112<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>O = old occupied</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>YGC = young gc time ( new part )</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>YGCT = young gc total cost time</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>FGC = full gc time ( old part )</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>FGCT = full gc total cost time</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>GCT = all gc cost time</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px"></span></p><br><p><strong>jvisualvm</strong></p><br><p>window下启动远程监控，并在被监控服务端，启动jstatd服务。</p><br><p><br><br></p><br><p><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px">创建安全策略文件，并命名为jstatd.all.policy<br style="line-height:25px"><br>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {<br style="line-height:25px"><br>&nbsp;&nbsp;&nbsp; permission java.security.AllPermission;<br style="line-height:25px"><br>};</span><br><br></p><br><p><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px"><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px">jstatd -J-Djava.security.policy=jstatd.all.policy -p 8080 &amp;</span></span></p><br><br><br><strong>======================== Tunning =================</strong></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>典型配置：</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><pre>-server -Xmx2g -Xms2g -Xmn512m -XX:PermSize=128m -Xss256k -XX:&#43;DisableExplicitGC -XX:&#43;UseConcMarkSweepGC -XX:&#43;UseParNewGC -XX:&#43;CMSParallelRemarkEnabled -XX:&#43;UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:&#43;UseFastAccessorMethods -XX:&#43;UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true<br></pre><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><a target="_blank" href="http://java.sun.com/performance/reference/whitepapers/tuning.html">http://java.sun.com/performance/reference/whitepapers/tuning.html</a><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><a target="_blank" href="http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html">http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html</a><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>&#43;AggressiveOpts 激进优化，默认开启，使用java新特性优化</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>1. 默认使用串行收集器， 单个cpu时适用</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>2. 吞吐收集器（throughput collector）：命令行参数：-XX:&#43;UseParallelGC。在新生代使用并行清除收集策略，在旧生代和默认收集器相同。</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>适用：a、拥有2个以上cpu， b、临时对象较多的程序</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><span style="font-family:Arial,Verdana,sans-serif">-XX:ParallelGCThreads 并行收集线程数量，最好和cpu数量相当</span><br><br><br><br>3. 并发收集器（concurrent low pause collector）：命令行参数：-XX:&#43;UseConcMarkSweepGC。在旧生代使用并发收集策略，大部分收集工作都是和应用并发进行的，在进行收集的时候，应用的暂停时间很短。默认配套打开 -XX:&#43;UseParNewGC，会在新生代使用并行复制收集。</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>适用：a、拥有多个cpu， b、老对象较多的程序</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>如果使用了UseParNewGC，那么同时使用CMSParallelRemarkEnabled参数可以降低标识暂停</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:&#43;UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片<br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:&#43;UseFastAccessorMethods 原始类型的快速优化</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:SurvivorRatio 新生区中，eden&amp;survivor的比例，设置为8</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:TargetSurvivorRatio 生存区需要做垃圾回收的比例&#20540;，默认为50%，设置高些可以更好的利用该区</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><img alt="" src="http://img.my.csdn.net/uploads/201207/09/1341820867_5296.gif"><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>各个垃圾收集器之间的区别：</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><a target="_blank" href="http://www.javaperformancetuning.com/news/qotm026.shtml">http://www.javaperformancetuning.com/news/qotm026.shtml</a><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>新生代，单独区域单独收集，不会影响老生代，因为区域小，且允许漏收集，采用复制清除的方法，更快。</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br></div><br><span style="font-family:Arial,'Liberation Sans','DejaVu Sans',sans-serif; font-size:14px; line-height:18px; border-collapse:collapse"></span><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>The&nbsp;<span style="font-size:14px; padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px; padding-left:0px; padding-right:0px; border-top-width:0px; border-bottom-width:0px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><em>(original)<br> copying collector</em></span>&nbsp;(Enabled by default). When this collector kicks in, all application threads are stopped, and the copying collection proceeds using one thread (which means only one CPU even if on a multi-CPU machine). This is known as a stop-the-world<br> collection, because basically the JVM pauses everything else until the collection is completed.</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>The&nbsp;<span style="font-size:14px; padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px; padding-left:0px; padding-right:0px; border-top-width:0px; border-bottom-width:0px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><em>parallel<br> copying collector</em></span>&nbsp;(Enabled using -XX:&#43;UseParNewGC). Like the original copying collector, this is a stop-the-world collector. However this collector parallelizes the copying collection over multiple threads, which is more efficient than the original<br> single-thread copying collector for multi-CPU machines (though not for single-CPU machines). This algorithm potentially speeds up young generation collection by a factor equal to the number of CPUs available, when compared to the original singly-threaded copying<br> collector.</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>The&nbsp;<span style="font-size:14px; padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px; padding-left:0px; padding-right:0px; border-top-width:0px; border-bottom-width:0px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><em>parallel<br> scavenge collector</em></span>&nbsp;(Enabled using -XX:UseParallelGC). This is like the previous parallel copying collector, but the algorithm is tuned for gigabyte heaps (over 10GB) on multi-CPU machines. This collection algorithm is designed to maximize throughput<br> while minimizing pauses. It has an optional adaptive tuning policy which will automatically resize heap spaces. If you use this collector, you can only use the the original mark-sweep collector in the old generation (i.e. the newer old generation concurrent<br> collector cannot work with this young generation collector).</p><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br></p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>UserParallelGC使用了更高效的算法，用于处理大规模内存&gt;10G场景，提供了大吞吐量功能。但是，同时在老生代，只能使用串行的标记清除方法。</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>老生代，必须做fullgc，必须从root开始全面标识收集。</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br></p><br><ul style="font-family:Simsun; font-size:16px"><br><li>The&nbsp;<em>(original) mark-sweep collector</em>&nbsp;(Enabled by default). This uses a stop-the-world mark-and-sweep collection algorithm. The collector is single-threaded, the entire JVM is paused and the collector uses only one CPU until completed.</li><li>The&nbsp;<em>concurrent collector</em>&nbsp;(Enabled using -XX:&#43;UseConcMarkSweepGC). This collector tries to allow application processing to continue as much as possible during the collection. Splitting the collection into six phases described shortly, four are concurrent<br> while two are stop-the-world:<br><br>1. the initial-mark phase (stop-the-world, snapshot the old generation so that we can run most of the rest of the collection concurrent to the application threads);<br><br>2. the mark phase (concurrent, mark the live objects traversing the object graph from the roots);<br><br>3. the pre-cleaning phase (concurrent);<br><br>4. the re-mark phase (stop-the-world, another snapshot to capture any changes to live objects since the collection started);<br><br>5. the sweep phase (concurrent, recycles memory by clearing unreferenced objects);<br><br>6. the reset phase (concurrent).<br><br>If &quot;the rate of creation&quot; of objects is too high, and the concurrent collector is not able to keep up with the concurrent collection, it falls back to the traditional mark-sweep collector.</li><li>The&nbsp;<em>incremental collector</em>&nbsp;(Enabled using -Xincgc). The incremental collector uses a &quot;train&quot; algorithm to collect small portions of the old generation at a time. This collector has higher overheads than the mark-sweep collector, but because small<br> numbers of objects are collected each time, the (stop-the-world) garbage collection pause is minimized at the cost of total garbage collection taking longer. The &quot;train&quot; algorithm does not guarantee a maximum pause time, but pause times are typically less<br> than ten milliseconds.</li></ul><br><br><br><p></p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br><br><br></p><br></div><br></div>

<p></p></div><p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/17/clover-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/17/clover-01/" itemprop="url">转载:clover分布式任务调度系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-17T17:36:39+08:00">
                2017-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content"><br><br><p><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong>1、clover</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>分布式调度介绍</strong></span></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">c</span><span style="font-family:Arial">lover</span><span style="font-family:宋体">分布式任务调度是完全使用</span><span style="font-family:Arial">Java</span><span style="font-family:宋体">技术自主开发</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">特点如下</span><span style="font-family:Arial">:</span><span style="font-family:Arial"></span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">1</span><span style="font-family:宋体">、防</span><span style="font-family:宋体">单点故障</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">2</span><span style="font-family:宋体">、</span><span style="font-family:Arial">job</span><span style="font-family:宋体">可部署多台</span><span style="font-family:宋体">，但任务调度</span><span style="font-family:宋体">时，只有一台</span><span style="font-family:宋体">参执行</span><span style="font-family:宋体">。如果一台下线，</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">clover</span><span style="font-family:宋体">选择其他已在</span><span style="font-family:Arial">zookeeper</span><span style="font-family:宋体">注册</span><span style="font-family:Arial">job</span><span style="font-family:宋体">来执行。</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">3</span><span style="font-family:宋体">、可</span><span style="font-family:宋体">管理</span><span style="font-family:宋体">监控程序 ，相关负责人的</span><span style="font-family:Arial">job</span><span style="font-family:宋体">不可用会发送邮件通知</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">4</span><span style="font-family:宋体">、提供</span><span style="font-family:宋体">管理后台，</span><span style="font-family:宋体">可手动停止任务，设置任务执行</span><span style="font-family:宋体">频率、恢复策</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">略。人工干预指定</span><span style="font-family:宋体">哪些</span><span style="font-family:Arial">job</span><span style="font-family:宋体">来</span><span style="font-family:宋体">工作，可</span><span style="font-family:宋体">查看任务执行进度、任务执行</span><span style="font-family:宋体">失败时会收到</span><span style="font-family:宋体">报警并记录日志。</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">5</span><span style="font-family:宋体">、执行中的任务，但未执行完成，不会再次调度任务</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">6</span><span style="font-family:宋体">、支持灾难重现，</span><span style="font-family:Arial">server</span><span style="font-family:宋体">端不可用，但</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端注册</span><span style="font-family:Arial">job</span><span style="font-family:宋体">信息会存储到临时</span><span style="font-family:Arial">DB</span><span style="font-family:宋体">中，当</span><span style="font-family:Arial">server</span><span style="font-family:宋体">重启后立即去读临时</span><span style="font-family:Arial">DB</span><span style="font-family:宋体">并执行相应</span><span style="font-family:Arial">job</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">7</span><span style="font-family:宋体">、</span><span style="font-family:Arial">job</span><span style="font-family:宋体">支持</span><span style="font-family:Arial">LOCAL</span><span style="font-family:宋体">、</span><span style="font-family:Arial">REMOTE</span><span style="font-family:宋体">模式以及</span><span style="font-family:Arial">ADD</span><span style="font-family:宋体">、</span><span style="font-family:Arial">UPDATE</span><span style="font-family:宋体">、</span><span style="font-family:Arial">DELETE</span><span style="font-family:宋体">操作</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">8</span><span style="font-family:宋体">、支持动态创建</span><span style="font-family:Arial">job</span><span style="font-family:宋体">、</span><span style="font-family:Arial">spring</span><span style="font-family:宋体">配置文件和注解方式注册</span><span style="font-family:Arial">job</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">9</span><span style="font-family:宋体">、可以查询所有运行报错日志查询</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">10</span><span style="font-family:宋体">、管理后台可以创建、修改、删除</span><span style="font-family:Arial">job</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial"><br><br></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial"></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong>2、&nbsp;</strong></span><span style="font-family:微软雅黑"><strong>总体</strong></span><span style="font-family:微软雅黑"><strong>框架分析</strong></span></span></span><span style="font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong><br><br></strong></span></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203135721930?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203135740926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong>3、&nbsp;</strong></span><span style="font-family:微软雅黑"><strong>总体框架分析</strong></span><span style="font-family:微软雅黑"><strong>-</strong></span><span style="font-family:微软雅黑"><strong>系统流程图</strong></span></span></span><span style="font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong><br><br></strong></span></span></span></p><br><img src="http://img.blog.csdn.net/20150203135912753?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="http://img.blog.csdn.net/20150203135929128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong>4、&nbsp;</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>技术</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>-</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>项目结构</strong></span></span><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203140331474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong>5、&nbsp;</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>涉及技术</strong></span></span><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">MongoDB</span><span style="font-family:宋体">集群</span><span style="font-family:Arial">:</span><span style="font-family:宋体">负责存储</span><span style="font-family:Arial">clover</span><span style="font-family:宋体">所有数据信息，当初想考虑使用</span><span style="font-family:Arial">LevelDB</span><span style="font-family:宋体">，但不方便管理，</span><span style="font-family:Arial">Redis</span><span style="font-family:宋体">完全放弃了，理由是对于频繁写操作性能下降、总有连接超时</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">ZK</span><span style="font-family:宋体">集群</span><span style="font-family:Arial">:</span><span style="font-family:宋体">负责</span><span style="font-family:Arial">server</span><span style="font-family:宋体">和</span><span style="font-family:Arial">client</span><span style="font-family:宋体">启动注册信息，所有</span><span style="font-family:Arial">server</span><span style="font-family:宋体">、</span><span style="font-family:Arial">client</span><span style="font-family:宋体">信息都是有读写操作权限，目的防止被他人或程序修改</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">ZeroMQ</span><span style="font-family:Arial">:</span><span style="font-family:宋体">负责</span><span style="font-family:Arial">server</span><span style="font-family:宋体">和</span><span style="font-family:Arial">client</span><span style="font-family:宋体">消息通信</span><span style="font-family:Arial">&amp;</span><span style="font-family:宋体">后台管理页面创建、修改、删除</span><span style="font-family:Arial">job</span><span style="font-family:宋体">通信</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">使用</span><span style="font-family:Arial">ZeroMQ</span><span style="font-family:宋体">的理由</span><span style="font-family:Arial">:</span><span style="font-family:宋体">就是快，就是那么任性，流式技术框架</span><span style="font-family:Arial">storm</span><span style="font-family:宋体">使用，未来会考虑使用</span><span style="font-family:Arial">Spark</span><span style="font-family:宋体">的</span><span style="font-family:Arial">akka</span><span style="font-family:宋体">消息通信框架</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Monitor:</span><span style="font-family:宋体">负责死亡心跳检测，监控</span><span style="font-family:Arial">server</span><span style="font-family:宋体">、</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端，使用</span><span style="font-family:Arial">Java<br> Timer</span><span style="font-family:宋体">实现</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">后台管理页面</span><span style="font-family:Arial">:bootstrap &#43;</span><span style="font-family:Arial">jsp&#43;highcharts</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Spring:</span><span style="font-family:宋体">重新定义</span><span style="font-family:Arial">spring</span><span style="font-family:宋体">的</span><span style="font-family:Arial">xsd</span><span style="font-family:宋体">标签以及</span><span style="font-family:Arial">Annotation</span><span style="font-family:宋体">注解方式，注册</span><span style="font-family:Arial">job</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Snappy:</span><span style="font-family:宋体">通信消息压缩方式，减少网络数据传输带宽</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Curator</span><span style="font-family:宋体">：监听</span><span style="font-family:Arial">ZK</span><span style="font-family:宋体">数据包变更，并保持到内存中，方便程序快速获取</span><span style="font-family:Arial">server</span><span style="font-family:宋体">和</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端信息</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Quartz</span><span style="font-family:宋体">：基于</span><span style="font-family:Arial">quartz</span><span style="font-family:宋体">重写底层定时任务调度，考虑处理各种任务执行规则问题，而选择</span><span style="font-family:Arial">quartz</span><span style="font-family:宋体">来调度任务</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><br><br></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ff0000">6、clover使用</span></strong></span><br><br></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203140708147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><span style="font-size:24px"><span style="font-family:微软雅黑"><strong>6.3、&nbsp;</strong></span><span style="font-family:微软雅黑"><strong>项目中定义</strong></span><span style="font-family:微软雅黑"><strong>Client</strong></span><span style="font-family:微软雅黑"><strong>JobClass</strong></span></span><br><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141102023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><span style="font-weight:bold"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong><span style="line-height:40px">6.4</span><span style="line-height:150%">、&nbsp;</span></strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>非</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>spring</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>项目使用</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>-</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>启动</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>clover-client</strong></span></span><br><br></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141252253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141331545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><img src="http://img.blog.csdn.net/20150203141429733?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141515971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="font-family:微软雅黑; font-size:27px; line-height:40px"><strong>6.</strong></span>5、&nbsp;</strong></span><span style="font-family:微软雅黑"><strong>非</strong></span><span style="font-family:微软雅黑"><strong>spring</strong></span><span style="font-family:微软雅黑"><strong>项目</strong></span><span style="font-family:微软雅黑"><strong>使用</strong></span><span style="font-family:微软雅黑"><strong>-</strong></span><span style="font-family:微软雅黑"><strong>启动</strong></span><span style="font-family:微软雅黑"><strong>job</strong></span><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141826952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong></strong></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑; font-size:27px; line-height:40px"><strong>6.</strong></span>6、 spring</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>项目</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>使用</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>-</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>启动</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>clover-client</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203142007224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p><img src="http://img.blog.csdn.net/20150203142101704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><br><p><br><br></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong></strong></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:24px"><span style="font-family:微软雅黑"><strong><span style="font-family:微软雅黑; line-height:40px"><strong>6.</strong></span>7、spring</strong></span><span style="font-family:微软雅黑"><strong>项目使用</strong></span><span style="font-family:微软雅黑"><strong>-</strong></span><span style="font-family:微软雅黑"><strong>启动</strong></span><span style="font-family:微软雅黑"><strong>clover-client</strong></span></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203142212560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203142358000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="font-family:微软雅黑; font-size:27px; font-weight:bold"><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203142635482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="color:#ff0000">7、后台管理页面</span></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="color:#ff0000"><br><br></span></strong></span></strong></span></p><br><p><span style="font-family:微软雅黑; color:#ff9900"><span style="font-size:27px"><strong>7.1、主页面</strong></span></span></p><br><p><span style="font-family:微软雅黑"><span style="font-size:27px"><strong><img src="http://img.blog.csdn.net/20150203142908456?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></span></p><br><p><span style="font-family:微软雅黑"><span style="font-size:27px"><strong><br><br></strong></span></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="color:#ffcc66">7.2、zk管理页面</span></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143040590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="color:#ff9900">7.3、job管理页面</span></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143138321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ffcc66">7.4、联系人管理页面</span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143230055?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ffcc33">7.5、日志管理页面</span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143333563?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ff0000">8、性能分析</span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ff0000"><br><br></span></strong></span></p><br><p><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.1、</strong></span><span style="line-height:150%; font-family:微软雅黑; font-size:20pt"><strong>clover server</strong></span><span style="line-height:150%; font-family:微软雅黑; font-size:20pt"><strong>压力</strong></span></span></p><br><p><span style="line-height:150%; font-family:微软雅黑; font-size:20pt"><strong></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Server</span><span style="font-family:宋体">端只负责任务定时执行和分发到指定</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端，由于使用了</span><span style="font-family:Arial">quartz</span><span style="font-family:宋体">，</span><span style="font-family:Arial">server</span><span style="font-family:宋体">端在定时轮训执行任务以及解析定时任务时间方面，对性能压力减少了很多</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Server</span><span style="font-family:宋体">端分发消息，使用</span><span style="font-family:Arial">zeromq</span><span style="font-family:Arial"></span><span style="font-family:宋体">非阻塞方式发送消息给指定</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端，目前部署两台服务器完全胜任所有性能压力</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Server</span><span style="font-family:宋体">端支持集群部署，每次</span><span style="font-family:Arial">client</span><span style="font-family:宋体">发送消息随机</span><span style="font-family:Arial">Hash</span><span style="font-family:宋体">到某一台</span><span style="font-family:Arial">server</span><span style="font-family:宋体">服务器</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">当所有的</span><span style="font-family:Arial">server</span><span style="font-family:宋体">都不可用，为了不影响</span><span style="font-family:Arial">client</span><span style="font-family:宋体">的使用，将会把</span><span style="font-family:Arial">clientjob</span><span style="font-family:宋体">信息存储到临时</span><span style="font-family:Arial">DB</span><span style="font-family:宋体">中，此刻还会发送邮件报警给相关</span><span style="font-family:Arial">server</span><span style="font-family:宋体">负责人，</span><span style="font-family:Arial">server</span><span style="font-family:宋体">立即重启后，会把所有临时</span><span style="font-family:Arial">DB</span><span style="font-family:宋体">中数据读取并执行，此刻</span><span style="font-family:Arial">client</span><span style="font-family:宋体">可以继续收到消息并执行业务逻辑</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Server</span><span style="font-family:宋体">端监听所有</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端</span><span style="font-family:Arial">ZK</span><span style="font-family:宋体">消息后放入内存中，当</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端</span><span style="font-family:Arial">zk</span><span style="font-family:宋体">数据信息发送变化后，才修改内存数据，这样可以提供</span><span style="font-family:Arial">server</span><span style="font-family:宋体">端获取</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端</span><span style="font-family:Arial">zk</span><span style="font-family:宋体">信息速度，也减轻了</span><span style="font-family:Arial">zk</span><span style="font-family:宋体">不断被访问的压力</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><br><br></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>2</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>zk</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>压力</strong></span></span><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:24pt; font-family:宋体">俺真心没啥压力，俺是一个大集群，你们这些大爷和土豪就每次启动容器时候将初始化信息放到我这边，而当你们数据信息发生变化（修改节点数据、节点数据不可用），监听者才会访问俺，其实想想你们没事 肯定不会经常变更数据滴，</span><span style="font-size:24pt; font-family:Arial">(<em>^__^</em>)</span><span style="font-size:24pt; font-family:宋体">，不过<br> 当你们挂了 或者关闭应用程序时候，我会把你们全部删除滴，这就会浪费伦家点时间和力气吧</span><span style="font-size:24pt; font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:24pt; font-family:宋体"><br><br></span></p><br><img src="" alt=""><br><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>3</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>MongoDB</strong></span></span><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143542539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>4</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>zeromq</strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143631465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>5</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>zeromq</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong><br> push/pull</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>模式</strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><img src="http://img.blog.csdn.net/20150203143700529?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></p><br><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/16/subscribe-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/subscribe-02/" itemprop="url">转载:简述观察者(订阅/发布)模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T11:53:57+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content"><br><br><h1><span style="font-size:24px">1.定义</span></h1><br><h1><span style="font-size:18px; font-weight:normal">&nbsp; &nbsp; 定义对象间的一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</span></h1><br><div><span style="font-size:24px"><strong>2.解决的问题</strong></span></div><br><div><span style="font-size:24px"><strong>&nbsp; &nbsp;&nbsp;</strong></span><span style="font-size:18px">现状：有时我们会将一个系统分割成一系列相互协作的类，但是这样会有一个副作用—需要维护相关对象间的一致性。这样的话我们为了维持一致性而使得各个类之间紧密耦合，导致可重用性的降低，会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</span></div><br><div><span style="font-size:18px">&nbsp; &nbsp; &nbsp;观察者模式使得任意树木的观察者不必知道彼此的存在，且主题发生变化时都可以得到主题的通知，而同步改变状态。是一种松散耦合，且有更好的可重用性。</span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:24px"><span style="line-height:18px"><strong>3.模式的组成结构</strong></span></span></div><br><div>&nbsp; &nbsp; &nbsp;<span style="font-size:18px">&nbsp; &nbsp;抽象主题（Subject）：它把所有观察者对象的引用保存到一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</span><br><br></div><br><div><span style="font-size:18px">&nbsp; &nbsp; &nbsp; 具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。<br><br></span></div><br><div><span style="font-size:18px">&nbsp; &nbsp; &nbsp;&nbsp;抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><strong>&nbsp;</strong>&nbsp; 具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><strong><span style="font-size:24px">4.模式的类图</span></strong></span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><strong><span style="font-size:24px"><br><br></span></strong></span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px">&nbsp; 由于自己还不会画类图，就网上找了一张</span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><img src="http://img.blog.csdn.net/20160109191634902?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><strong><span style="font-size:24px">5.具体实现代码</span></strong></span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><span style="font-size:14px">5.1.<span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><strong>IPrettyGirl.java&nbsp;</strong></span></span></span></div><br><div><pre name="code" class="java">package com.example.design.observer;<br>/<em>
 </em> 抽象主题角色<br> <em> 类型是接口或者抽象类
 </em>/<br>public interface IPrettyGirl {<br>    public void addObservers(IObserver observers);//添加观察者<br><br>    public void deleteObservers(IObserver observers);//删除观察者<br><br>    public void notifyAllObservers(String msg);//通知所有的观察者<br>}<br>//public abstract class IPrettyGirl{<br>//    public abstract void addObservers(IObserver observers);//添加观察者<br>//<br>//    public abstract void deleteObservers(IObserver observers);//删除观察者<br>//<br>//    public abstract void notifyAllObservers(String msg);//通知所有的观察者<br>//<br>//}</pre><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px"><span style="font-size:14px">5.2.<span style="background-color:rgb(240,240,240)">IObserver.java</span></span></span></span></span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px"><span style="font-size:14px"><span style="background-color:rgb(240,240,240)"></span></span></span></span></span><pre name="code" class="java">package com.example.design.observer;<br>/<strong><br> <em> 
 </em> 抽象观察者<br> <em>
 </em>/<br>public interface IObserver {<br>   public void UpdateMsg(String msg);<br>}</strong></pre></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px">5.3&nbsp;Angelababy.java</span><br><br></span></span></span></span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px"></span></span></span></span></span><pre name="code" class="java">package com.example.design.observer;<br><br>import java.util.ArrayList;<br>import java.util.List;<br><br>/<em>
 </em> 具体主题<br> <em> 这里选取众多屌丝追女神的例子
 </em>/<br>public class Angelababy implements IPrettyGirl {<br><br>    // 观察者集合<br>    private List&lt;IObserver&gt; mList = new ArrayList&lt;IObserver&gt;();// 注意这里集合的泛型用的是接口类型<br><br>    public void addObservers(IObserver observers) {<br>        mList.add(observers);<br>    }<br><br>    @Override<br>    public void deleteObservers(IObserver observers) {<br>        mList.remove(observers);<br>    }<br><br>    @Override<br>    public void notifyAllObservers(String msg) {<br>        for (IObserver list : mList) {<br>            list.UpdateMsg(msg);<br>        }<br>    }<br><br>}</pre></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px">5.4.</span><span style="font-family:Arial; font-size:14px; line-height:26px; background-color:rgb(240,240,240)">Observers.java</span><br><br></span></span></span></span></span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px; background-color:rgb(240,240,240)"></span></span></span></span></span></span><pre name="code" class="java">package com.example.design.observer;<br>/<br> <em> 
 </em> 具体观察者<br> <em> 屌丝男一 
 </em>/<br>public class Observers implements IObserver {<br>    private String name;<br><br>    public  Observers(String name) {<br>        this.name = name;<br>    }<br><br>    @Override<br>    public void UpdateMsg(String msg) {<br>        // TODO 自动生成的方法存根<br>        if (&quot;我不开心&quot;.equals(msg)) {<br>            System.out.println(name+&quot;说： 多喝热水&quot;);<br>        }<br>    }<br><br>}</pre></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px; background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px">然后多写几个观察者(屌丝)类，这里就不贴代码了，同4。</span></span></span></span></span></span></span><br><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><br></p><br><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; line-height:25px"><br><span style="font-size:14px">5.5 测试主方法</span></p><br><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-size:14px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; line-height:25px"><br></p><br><pre name="code" class="java">package com.example.design.observer;<br><br>/<em>*
 </em> —-观察者模式—-<br> <em> 
 </em>/<br>public class TestMain {<br><br>    public static void main(String[] args) {<br>        // TODO 自动生成的方法存根<br>        Observers observers1 = new Observers(&quot;王大锤&quot;);<br>        Observers2 observers2 = new Observers2(&quot;黄晓明&quot;);<br>        Observers3 observers3 = new Observers3(&quot;郑恺&quot;);<br>        Observers4 observers4 = new Observers4(&quot;邓超&quot;);<br><br>        Angelababy angelababy = new Angelababy();<br><br>        // 注册添加观察者<br>        angelababy.addObservers(observers1);<br>        angelababy.addObservers(observers2);<br>        angelababy.addObservers(observers3);<br>        angelababy.addObservers(observers4);<br><br>        // 发出通知消息<br>        angelababy.notifyAllObservers(&quot;我不开心&quot;);<br>        //删除观察者<br>        angelababy.deleteObservers(observers1);<br>        System.out.println(&quot;———————&quot;);<br>        angelababy.notifyAllObservers(&quot;我不开心&quot;);<br>    }<br>}</pre><span style="font-size:14px">5.6.输出结果</span><br><p></p><br><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-size:14px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; line-height:25px"><br></p><br><pre name="code" class="java">王大锤说： 多喝热水<br>黄晓明说：多喝热水,么么哒<br>郑恺说：走，带你去看电影<br>邓超说：走，带你去吃缙云烧饼<br>———————<br>黄晓明说：多喝热水,么么哒<br>郑恺说：走，带你去看电影<br>邓超说：走，带你去吃缙云烧饼</pre><br><p><span style="font-size:18px">6.模式的总结</span></p><br><p><span style="font-size:18px">&nbsp; &nbsp;6.1 优点<br><br>　　 &nbsp;观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。<br><br>&nbsp; &nbsp;6.2 缺点<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。<br><br>&nbsp; &nbsp;6.3 适用场景<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。<br><br><span style="color:rgb(255,0,0)">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。<br><br></span></p><br><p><strong><span style="font-size:18px; color:#ff0000">如果上面有什么不妥的地方，欢迎留言指正</span></strong></p><br></div>

<p></p></div><p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/16/subscribe-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/subscribe-01/" itemprop="url">转载:订阅发布模式(Subscribe/Publish)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T11:19:45+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content"><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 订阅发布模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。</p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相应对象间的一致性，这样会给维护、扩展和重用都带来不便。当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变时，就可以使用订阅发布模式了。</p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个抽象模型有两个方面，其中一方面依赖于另一方面，这时订阅发布模式可以将这两者封装在独立的对象中，使它们各自独立地改变和复用。订阅发布模式所做的工作其实就是在解耦合。让耦合的双方都依赖于抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。</p><br>    <p>在我们日常写程序时，经常遇到下面这种情况：</p><br>    <blockquote><br>    <p>public void 有告警信息产生() <br>{ <br>&nbsp;&nbsp;&nbsp; 刷新界面(); <br>&nbsp;&nbsp;&nbsp; 更新数据库(); <br>&nbsp;&nbsp;&nbsp; 给管理员发Mail(); <br>&nbsp;&nbsp;&nbsp; &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; <br>}</p><br>    </blockquote><br>    <p>当有告警信息产生时，依次要去执行：刷新界面()、更新数据库()、给管理员发Mail()等操作。表面上看代码写得很工整，其实这里面问题多多：</p><br>    <ul><br>    <li>首先，这完全是面向过程开发，根本不适合大型项目。 </li><br>    <li>第二，代码维护量太大。设想一下，如果产生告警后要执行10多个操作，那这将是个多么大，多少复杂的类呀，时间一长，可能连开发者自己都不知道如何去维护了。 </li><br>    <li>第三，扩展性差。如果产生告警后，要增加一个声音提示()功能，怎么办呢？没错，只能加在有告警信息产生()这个函数中，这样一来，就违反了&ldquo;开放-关闭原则&rdquo;。而且修改了原有的函数，那么在测试时，除了要测新增功能外，还要做原功能的回归测试；在一个大型项目中，做一次回归测试可能要花费大约两周左右的时间，而且前提是新增功能没有影响原来功能及产生新的bug。 </li><br>    </ul><br>    <p>那么如何把有告警信息产生()函数同其他函数进行解耦合呢？别着急，下面就介绍今天的主角—-订阅发布模式。见下图：</p><br>    <p><img style="display: inline; border: 0px;" src="http://hi.csdn.net/attachment/201001/22/32139_1264124155jcyK.png" alt="订阅发布模式1" width="313" height="243"> </p><br>    <p>上面的流程就是对有告警信息产生()这个函数的描述。我们要做的，就是把产生告警和它需要通知的事件进行解耦，让它们之间没有相互依赖的关系，解耦合图如下：</p><br>    <p><img style="display: inline; border: 0px;" src="http://hi.csdn.net/attachment/201001/22/32139_12641241575302.png" alt="订阅发布模式2" width="521" height="207"> </p><br>    <p>事件触发者被抽象出来，称为消息发布者，即图中的P。事件接受都被抽象出来，称为消息订阅者，即图中的S。P与S之间通过S.P（即订阅器）连接。这样就实现了P与S的解耦。首先，P就把消息发送到指定的订阅器上，从始至终，它并不知道也不关心要把消息发向哪个S。S如果想接收消息，就要向订阅器进行订阅，订阅成功后，S就可以接收来自S.P的消息了，从始至终，S并不知道也不关心消息来源于哪个具体的P。同理，S还可以向S.P进行退订操作，成功退订后，S就无法接收到来自指定S.P的消息了。这样就完美的解决了P与S之间的解耦。</p><br>    <p>等等，好像还有一个问题。从图上看，虽然P与S之间完成了解耦，但是P与S.P，S与S.P之间不就又耦合上了吗？其实这个问题好解决，想想我们上篇的<a href="http://blog.csdn.net/tjvictor/archive/2010/01/20/5218401.aspx" target="_blank"><span style="color: #006bad;">装饰模式</span></a>是怎么解耦的？对，就接口。这里我们同样使用接口来解决P与S.P和S与S.P之间的解耦，同时，使用delegate来解决多订阅多发布的机制。</p><br>    <p>下面给出实现代码。由于订阅发布模式涉及P, S.P和S三部份内容，所以代码比较多，也比较长。请大家耐心阅读。</p><br>    <p>首先，为了实现P与S.P, S与S.P之间的解耦，我们需要定义两个接口文件</p><br>    <blockquote><br>    <p>ISubscribe.cs<br>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; //定义订阅事件<br>&nbsp;&nbsp;&nbsp; public delegate void SubscribeHandle(string str);<br>&nbsp;&nbsp;&nbsp; //定义订阅接口<br>&nbsp;&nbsp;&nbsp; public interface ISubscribe<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event SubscribeHandle SubscribeEvent;<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    <blockquote><br>    <p>IPublish<br>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; //定义发布事件<br>&nbsp;&nbsp;&nbsp; public delegate void PublishHandle(string str);<br>&nbsp;&nbsp;&nbsp; //定义发布接口<br>&nbsp;&nbsp;&nbsp; public interface IPublish<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event PublishHandle PublishEvent; </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Notify(string str);<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    <p>然后我们来设计订阅器。显然订阅器要实现双向解耦，就一定要继承上面两个接口，这也是我为什么用接口不用抽象类的原因(类是单继承)。</p><br>    <code><br>    <blockquote><br>    <p>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; public class SubPubComponet : ISubscribe, IPublish<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private string _subName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public SubPubComponet(string subName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._subName = subName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PublishEvent += new PublishHandle(Notify);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region ISubscribe Members<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event SubscribeHandle subscribeEvent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event SubscribeHandle ISubscribe.SubscribeEvent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add { subscribeEvent += value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove { subscribeEvent -= value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region IPublish Members<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public PublishHandle PublishEvent; </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event PublishHandle IPublish.PublishEvent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add { PublishEvent += value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove { PublishEvent -= value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Notify(string str)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (subscribeEvent != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscribeEvent.Invoke(string.Format(“消息来源{0}:消息内容:{1}”, _subName, str));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    </code><br>    <p>接下来是设计订阅者S。S类中使用了ISubscribe来与S.P进行解耦。代码如下： </p><br>    <code><br>    <blockquote><br>    <p>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; public class Subscriber<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private string _subscriberName; </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Subscriber(string subscriberName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._subscriberName = subscriberName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ISubscribe AddSubscribe { set { value.SubscribeEvent += Show; } }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ISubscribe RemoveSubscribe { set { value.SubscribeEvent -= Show; } } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void Show(string str)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(string.Format(“我是{0}，我收到订阅的消息是:{1}”, _subscriberName, str));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    </code><br>    <p>最后是发布者P，继承IPublish来对S.P发布消息通知。 </p><br>    <code><br>    <blockquote><br>    <p>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; public class Publisher:IPublish<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private string _publisherName; </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Publisher(string publisherName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._publisherName = publisherName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private event PublishHandle PublishEvent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event PublishHandle IPublish.PublishEvent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add { PublishEvent += value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove { PublishEvent -= value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Notify(string str)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PublishEvent != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PublishEvent.Invoke(string.Format(“我是{0},我发布{1}消息”, _publisherName, str));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    </code><br>    <p>至此，一个简单的订阅发布模式已经完成了。下面是调用代码及运行结果。调用代码模拟了图2中的订阅发布关系，大家可以从代码，运行结果和示例图三方面对照着看。</p><br>    <code><br>    <blockquote><br>    <p>#region TJVictor.DesignPattern.SubscribePublish<br>//新建两个订阅器<br>SubPubComponet subPubComponet1 = new SubPubComponet(“订阅器1”);<br>SubPubComponet subPubComponet2 = new SubPubComponet(“订阅器2”);<br>//新建两个发布者<br>IPublish publisher1 = new Publisher(“TJVictor1”);<br>IPublish publisher2 = new Publisher(“TJVictor2”);<br>//与订阅器关联<br>publisher1.PublishEvent += subPubComponet1.PublishEvent;<br>publisher1.PublishEvent += subPubComponet2.PublishEvent;<br>publisher2.PublishEvent += subPubComponet2.PublishEvent;<br>//新建两个订阅者<br>Subscriber s1 = new Subscriber(“订阅人1”);<br>Subscriber s2 = new Subscriber(“订阅人2”);<br>//进行订阅<br>s1.AddSubscribe = subPubComponet1;<br>s1.AddSubscribe = subPubComponet2;<br>s2.AddSubscribe = subPubComponet2;<br>//发布者发布消息<br>publisher1.Notify(“博客1”);<br>publisher2.Notify(“博客2”);<br>//发送结束符号<br>Console.WriteLine(“”.PadRight(50,’-‘));<br>//s1取消对订阅器2的订阅<br>s1.RemoveSubscribe = subPubComponet2;<br>//发布者发布消息<br>publisher1.Notify(“博客1”);<br>publisher2.Notify(“博客2”);<br>//发送结束符号<br>Console.WriteLine(“”.PadRight(50, ‘-‘));<br>#endregion </p><br>    <p>#region Console.ReadLine();<br>Console.ReadLine();<br>#endregion</p><br>    </blockquote><br>    </code><br>    <p>&nbsp;运行结果图：</p><br>    <p><img src="http://hi.csdn.net/attachment/201001/22/32139_12641261136vbM.png" alt="订阅发布模式3" width="740" height="210"></p><br>    <p>&nbsp;</p><br>    <p>&nbsp;</p><br>    <p>如需转载，请注明本文原创自CSDN TJVictor专栏：<a href="http://blog.csdn.net/tjvictor" target="_blank" rel="external"><span style="color: #006bad;">http://blog.csdn.net/tjvictor</span></a></p><br>    </div> 


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/16/aop-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/aop-01/" itemprop="url">转载:Java动态代理的两种实现方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T09:04:51+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="article_c"><br><br>&nbsp;AOP的拦截功能是由java中的动态代理来实现的。说白了，就是在目标类的基础上增加切面逻辑，生成增强的目标类（该切面逻辑或者在目标类函数执行之前，或者目标类函数执行之后，或者在目标类函数抛出异常时候执行。不同的切入时机对应不同的Interceptor的种类，如BeforeAdviseInterceptor，AfterAdviseInterceptor以及ThrowsAdviseInterceptor等）。<br><br><p><br><br></p><br><p>那么动态代理是如何实现将切面逻辑（advise）织入到目标类方法中去的呢？下面我们就来详细介绍并实现AOP中用到的两种动态代理。<br><br></p><br><p>AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。<span style="color:#FF0000">jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。</span>由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。。<br><br></p><br><h1>1、定义接口和实现</h1><br><p></p><br><pre name="code" class="java">package com.meituan.hyt.test3.service;<br><br><br>public interface UserService {<br>    public String getName(int id);<br><br>    public Integer getAge(int id);<br>}<br></pre><br><p></p><br><p><br><br></p><br><p></p><br><pre name="code" class="java">package com.meituan.hyt.test3.service.impl;<br><br>import com.meituan.hyt.test3.service.UserService;<br><br><br>public class UserServiceImpl implements UserService {<br>    @Override<br>    public String getName(int id) {<br>        System.out.println(&quot;——getName——&quot;);<br>        return &quot;Tom&quot;;<br>    }<br><br>    @Override<br>    public Integer getAge(int id) {<br>        System.out.println(&quot;——getAge——&quot;);<br>        return 10;<br>    }<br>}<br></pre><br><br><p></p><br><h1>2、jdk动态代理实现</h1><br><p></p><br><pre name="code" class="java">package com.meituan.hyt.test3.jdk;<br><br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br><br><br>public class MyInvocationHandler implements InvocationHandler {<br>    private Object target;<br><br>    MyInvocationHandler() {<br>        super();<br>    }<br><br>    MyInvocationHandler(Object target) {<br>        super();<br>        this.target = target;<br>    }<br><br>    @Override<br>    public Object invoke(Object o, Method method, Object[] args) throws Throwable {<br>        if(&quot;getName&quot;.equals(method.getName())){<br>            System.out.println(&quot;++++++before &quot; + method.getName() + &quot;++++++&quot;);<br>            Object result = method.invoke(target, args);<br>            System.out.println(&quot;++++++after &quot; + method.getName() + &quot;++++++&quot;);<br>            return result;<br>        }else{<br>            Object result = method.invoke(target, args);<br>            return result;<br>        }<br><br>    }<br>}<br></pre><br><br><pre name="code" class="java">package com.meituan.hyt.test3.jdk;<br><br>import com.meituan.hyt.test3.service.UserService;<br>import com.meituan.hyt.test3.service.impl.UserServiceImpl;<br><br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Proxy;<br><br><br>public class Main1 {<br>    public static void main(String[] args) {<br>        UserService userService = new UserServiceImpl();<br>        InvocationHandler invocationHandler = new MyInvocationHandler(userService);<br>        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),<br>                userService.getClass().getInterfaces(), invocationHandler);<br>        System.out.println(userServiceProxy.getName(1));<br>        System.out.println(userServiceProxy.getAge(1));<br>    }<br>}</pre><br><br>运行结果<br><p></p><br><p>&#43;&#43;&#43;&#43;&#43;&#43;before getName&#43;&#43;&#43;&#43;&#43;&#43;<br><br>——getName——<br><br>&#43;&#43;&#43;&#43;&#43;&#43;after getName&#43;&#43;&#43;&#43;&#43;&#43;<br><br>Tom<br><br>——getAge——<br><br>10</p><br><h1>3、cglib动态代理实现<br><br></h1><br><p>Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：<br><br><br><br>CGLIB的核心类：<br><br>&nbsp;&nbsp;&nbsp; net.sf.cglib.proxy.Enhancer – 主要的增强类<br><br>&nbsp;&nbsp;&nbsp; net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现<br><br>&nbsp;&nbsp;&nbsp; net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：<br><br>&nbsp;&nbsp;&nbsp; Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。<br><br><br><br>net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法<br><br>public Object intercept(Object object, java.lang.reflect.Method method,<br><br>Object[] args, MethodProxy proxy) throws Throwable;<br><br><br><br>第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。</p><br><p></p><br><pre name="code" class="java">package com.meituan.hyt.test3.cglib;<br><br><br>import net.sf.cglib.proxy.MethodInterceptor;<br>import net.sf.cglib.proxy.MethodProxy;<br><br>import java.lang.reflect.Method;<br><br><br>public class CglibProxy implements MethodInterceptor {<br>    @Override<br>    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {<br>        System.out.println(&quot;++++++before &quot; + methodProxy.getSuperName() + &quot;++++++&quot;);<br>        System.out.println(method.getName());<br>        Object o1 = methodProxy.invokeSuper(o, args);<br>        System.out.println(&quot;++++++before &quot; + methodProxy.getSuperName() + &quot;++++++&quot;);<br>        return o1;<br>    }<br>}<br></pre><br><br><br><br><pre name="code" class="java">package com.meituan.hyt.test3.cglib;<br><br>import com.meituan.hyt.test3.service.UserService;<br>import com.meituan.hyt.test3.service.impl.UserServiceImpl;<br>import net.sf.cglib.proxy.Enhancer;<br><br><br><br>public class Main2 {<br>    public static void main(String[] args) {<br>        CglibProxy cglibProxy = new CglibProxy();<br><br>        Enhancer enhancer = new Enhancer();<br>        enhancer.setSuperclass(UserServiceImpl.class);<br>        enhancer.setCallback(cglibProxy);<br><br>        UserService o = (UserService)enhancer.create();<br>        o.getName(1);<br>        o.getAge(1);<br>    }<br>}</pre><br><br>运行结果：<br><p></p><br><p>&#43;&#43;&#43;&#43;&#43;&#43;before CGLIB$getName$0&#43;&#43;&#43;&#43;&#43;&#43;<br><br>getName<br><br>——getName——<br><br>&#43;&#43;&#43;&#43;&#43;&#43;before CGLIB$getName$0&#43;&#43;&#43;&#43;&#43;&#43;<br><br>&#43;&#43;&#43;&#43;&#43;&#43;before CGLIB$getAge$1&#43;&#43;&#43;&#43;&#43;&#43;<br><br>getAge<br><br>——getAge——<br><br>&#43;&#43;&#43;&#43;&#43;&#43;before CGLIB$getAge$1&#43;&#43;&#43;&#43;&#43;&#43;<br><br></p><br><div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd"></div><br><div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd"></div><br><div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd"></div><br> </div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://bloodorange2017.github.io/images/img_head_001.jpg"
               alt="XueCheng" />
          <p class="site-author-name" itemprop="name">XueCheng</p>
           
              <p class="site-description motion-element" itemprop="description">Do one thing at a time, and do well.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">64</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XueCheng</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

<script type="text/javascript"
color="160,160,233" opacity='0.4' zIndex="-2" count="16" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
