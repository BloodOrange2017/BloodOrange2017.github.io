<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Do one thing at a time, and do well.">
<meta property="og:type" content="website">
<meta property="og:title" content="XueCheng Notes">
<meta property="og:url" content="https://bloodorange2017.github.io/archives/page/3/index.html">
<meta property="og:site_name" content="XueCheng Notes">
<meta property="og:description" content="Do one thing at a time, and do well.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XueCheng Notes">
<meta name="twitter:description" content="Do one thing at a time, and do well.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bloodorange2017.github.io/archives/page/3/"/>





  <title>XueCheng Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XueCheng Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Where there is a will, there is a way.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/07/31/aop-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/31/aop-04/" itemprop="url">转载:Spring实现AOP的4种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-31T15:51:08+08:00">
                2017-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br><br><blockquote><br><h1 align="left"><strong>Spring实现AOP的4种方式</strong></h1><br><p align="left">&nbsp;</p><br><p align="left">&nbsp; <span style="font-family:宋体">先了解</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">的相关术语</span><span style="font-family:Calibri">:</span><br><br><strong>1.<span style="font-family:宋体">通知</span><span style="font-family:Calibri">(Advice):</span></strong><br><br><span style="font-family:宋体">通知定义了切面是什么以及何时使用。描述了切面要完成的工作和何时需要执行这个工作。</span><br><br><strong>2.<span style="font-family:宋体">连接点</span><span style="font-family:Calibri">(</span><a target="_blank" name="OLE_LINK1">Joinpoint</a>):</strong><br><br><span style="font-family:宋体">程序能够应用通知的一</span> <span style="font-family:宋体">个</span>“<span style="font-family:宋体">时机</span><span style="font-family:Calibri">”</span><span style="font-family:宋体">，这些</span><span style="font-family:Calibri">“</span><span style="font-family:宋体">时机</span><span style="font-family:Calibri">”</span><span style="font-family:宋体">就是连接点，例如方法被调用时、异常被抛出时等等。</span><br><br><strong>3.<span style="font-family:宋体">切入点</span><span style="font-family:Calibri">(Pointcut)</span></strong><br><br><span style="font-family:宋体">通知定义了切面要发生的</span>“<span style="font-family:宋体">故事</span><span style="font-family:Calibri">”</span><span style="font-family:宋体">和时间，那么切入点就定义了</span><span style="font-family:Calibri">“</span><span style="font-family:宋体">故事</span><span style="font-family:Calibri">”</span><span style="font-family:宋体">发生的地点，例如某个类或方法的名称，</span><a target="_blank" href="http://lib.csdn.net/base/javaee" title="Java EE知识库"><strong><u><span style="color:#df3434">spring</span></u></strong></a><span style="font-family:宋体">中允许我们方便的用正则表达式来指定</span><br><br><strong>4.<span style="font-family:宋体">切面</span><span style="font-family:Calibri">(Aspect)</span></strong><br><br><span style="font-family:宋体">通知和切入点共同组成了切面：时间、地点和要发生的</span>“<span style="font-family:宋体">故事</span><span style="font-family:Calibri">”</span><br><br><strong>5.<span style="font-family:宋体">引入</span><span style="font-family:Calibri">(Introduction)</span></strong><br><br><span style="font-family:宋体">引入允许我们向现有的类添加新的方法和属性</span>(Spring<span style="font-family:宋体">提供了一个方法注入的功能）</span><br><br><strong>6.<span style="font-family:宋体">目标</span><span style="font-family:Calibri">(Target)</span></strong><br><br><span style="font-family:宋体">即被通知的对象，如果没有</span>AOP,<span style="font-family:宋体">那么它的逻辑将要交叉别的事务逻辑，有了</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">之后它可以只关注自己要做的事（</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">让他做爱做的事）</span><br><br><strong>7.<span style="font-family:宋体">代理</span><span style="font-family:Calibri">(proxy)</span></strong><br><br><span style="font-family:宋体">应用通知的对象，详细内容参见设计模式里面的代理模式</span><br><br><strong>8.<span style="font-family:宋体">织入</span><span style="font-family:Calibri">(Weaving)</span></strong><br><br><span style="font-family:宋体">把切面应用到目标对象来创建新的代理对象的过程，织入一般发生在如下几个时机</span>:<br><br>(1)<span style="font-family:宋体">编译时：当一个类文件被编译时进行织入，这需要特殊的编译器才可以做的到，例如</span><span style="font-family:Calibri">AspectJ</span><span style="font-family:宋体">的织入编译器</span><br><br>(2)<span style="font-family:宋体">类加载时：使用特殊的</span><span style="font-family:Calibri">ClassLoader</span><span style="font-family:宋体">在目标类被加载到程序之前增强类的字节代码</span><br><br>(3)<span style="font-family:宋体">运行时：切面在运行的某个时刻被织入</span><span style="font-family:Calibri">,SpringAOP</span><span style="font-family:宋体">就是以这种方式织入切面的，原理应该是使用了</span><span style="font-family:Calibri">JDK</span><span style="font-family:宋体">的动态代理技术</span><br><br><strong><br><br>Spring<span style="font-family:宋体">提供了</span><span style="font-family:Calibri">4</span><span style="font-family:宋体">种实现</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">的方式：</span><br><br>1.<span style="font-family:宋体">经典的基于代理的</span><span style="font-family:Calibri">AOP</span><br><br>2.@AspectJ<span style="font-family:宋体">注解驱动的切面</span><br><br>3.<span style="font-family:宋体">纯</span><span style="font-family:Calibri">POJO</span><span style="font-family:宋体">切面</span><br><br>4.<span style="font-family:宋体">注入式</span><span style="font-family:Calibri">AspectJ</span><span style="font-family:宋体">切面</span></strong><br><br><br><br><span style="font-family:宋体">首先看经典的基于代理的</span>AOP:<br><br>Spring<span style="font-family:宋体">支持五种类型的通知：</span><br><br>Before(<span style="font-family:宋体">前</span><span style="font-family:Calibri">)&nbsp; org.apringframework.aop.MethodBeforeAdvice</span><br><br>After-returning(<span style="font-family:宋体">返回后</span><span style="font-family:Calibri">) org.springframework.aop.AfterReturningAdvice</span><br><br>After-throwing(<span style="font-family:宋体">抛出后</span><span style="font-family:Calibri">) org.springframework.aop.ThrowsAdvice</span><br><br>Arround(<span style="font-family:宋体">周围</span><span style="font-family:Calibri">) org.aopaliance.intercept.MethodInterceptor</span><br><br>Introduction(<span style="font-family:宋体">引入</span><span style="font-family:Calibri">) org.springframework.aop.IntroductionInterceptor</span><br><br><br><br><span style="font-family:宋体">&#20540;的说明的是周围通知，他是由</span>AOP Alliance<span style="font-family:宋体">中的接口定义的而非</span><span style="font-family:Calibri">Spring,</span><span style="font-family:宋体">周围通知相当于前通知、返回后通知、抛出后通知的结合（传说中的完全体？好吧，我看日和看多</span><br><br><br><br><span style="font-family:宋体">了）还有引入通知怎么玩我还没搞清楚，等心无杂念的时候玩玩</span><br><br><br><br><span style="font-family:宋体">这东西怎么玩？这么几个步骤：</span><br><br>1.<span style="font-family:宋体">创建通知：实现这几个接口，把其中的方法实现了</span><br><br>2.<span style="font-family:宋体">定义切点和通知者：在</span><span style="font-family:Calibri">Spring</span><span style="font-family:宋体">配制文件中配置这些信息</span><br><br>3.<span style="font-family:宋体">使用</span><span style="font-family:Calibri">ProxyFactoryBean</span><span style="font-family:宋体">来生成代理</span><br><br><br><br><span style="font-family:宋体">具体做法。。。大晚上的就举个睡觉的例子吧</span>:<br><br><br><br><span style="font-family:宋体">首先写一个接口叫</span>Sleepable,<span style="font-family:宋体">这是一个牛</span><span style="font-family:Calibri">X</span><span style="font-family:宋体">的接口</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">所有具有睡觉能力的东西都可以实现该接口（不光生物，包括关机选项里面的休眠）</span><br><br><br><br>package test.spring.aop.bean<br><br>public interface Sleepable{<br><br>&nbsp;&nbsp;&nbsp; void sleep();&nbsp;<br><br>}</p><br><p align="left"><span style="font-family:宋体">然后写一个</span>Human<span style="font-family:宋体">类，他实现了这个接口</span><br><br>package test.spring.aop.bean<br><br>public Human implements Sleepable{<br><br>&nbsp;&nbsp; /<em><span style="font-family:宋体">这人莫非跟寡人差不多？</span><br><br>&nbsp;&nbsp;&nbsp; </em><span style="font-family:宋体">除了睡觉睡的比较好之外其余的什么也不会做？</span><span style="font-family:Calibri"><em>/</em></span><br><br>&nbsp;&nbsp; public void sleep(){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;<span style="font-family:宋体">睡觉了！梦中自有颜如玉！</span><span style="font-family:Calibri">&quot;);</span><br><br>&nbsp;&nbsp; }<br><br>}<br><br><br><br><br><br><span style="font-family:宋体">好了，这是主角，不过睡觉前后要做些辅助工作的，最基本的是脱穿衣服，失眠的人还要吃安眠药什么的</span>,<span style="font-family:宋体">但是这些动作与纯粹的睡觉这一</span><span style="font-family:Calibri">“</span><span style="font-family:宋体">业务逻辑</span><span style="font-family:Calibri">”</span><span style="font-family:宋体">是不相干的，如果把</span><br><br><br><br><span style="font-family:宋体">这些代码全部加入到</span>sleep<span style="font-family:宋体">方法中，是不是有违单一职责呢？，这时候我们就需要</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">了。</span><br><br><br><br><span style="font-family:宋体">编写一个</span>SleepHelper<span style="font-family:宋体">类，它里面包含了睡觉的辅助工作</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">用</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">术语来说它就应该是通知了，我们需要实现上面的接口</span><br><br><br><br>package test.spring.aop.bean;<br><br>import <a target="_blank" href="http://lib.csdn.net/base/javaee" title="Java EE知识库"><br><strong><u><span style="color:#df3434">Java</span></u></strong></a>.lang.reflect.Method;<br><br>import org.springframework.aop.AfterReturningAdvice;<br><br>import org.springframework.aop.MethodBeforeAdvice;<br><br>public class SleepHelper implements MethodBeforeAdvice,AfterReturningAdvice{<br><br>&nbsp;&nbsp;&nbsp; public void before(Method mtd, Object[] arg1, Object arg2)<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throws Throwable {<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;<span style="font-family:宋体">通常情况下睡觉之前要脱衣服！</span><span style="font-family:Calibri">&quot;);</span><br><br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public void afterReturning(Object arg0, Method arg1, Object[] arg2,<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Object arg3) throws Throwable {<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;<span style="font-family:宋体">起床后要先穿衣服！</span><span style="font-family:Calibri">&quot;);</span><br><br>&nbsp;&nbsp;&nbsp; }<br><br>}<br><br><span style="font-family:宋体; color:#009900">然后在</span><span style="color:#009900">spring<span style="font-family:宋体">配置文件中进行配置</span><span style="font-family:Calibri">:</span></span><br><br>&lt;bean id=&quot;sleepHelper&quot; class=&quot;test.spring.aop.bean.SleepHelper&quot;&gt;<br><br>&lt;/bean&gt;<br><br><span style="color:#009900">OK!<span style="font-family:宋体">现在创建通知的工作就完成了</span><span style="font-family:Calibri">.</span><br><br><span style="font-family:宋体">第二步是进行配置，这是很令人蛋疼的操作，尤其是这么热的天，</span>Spring<span style="font-family:宋体">又把东西的名字起的见&#39740;的长！它为啥不能像</span><span style="font-family:Calibri">usr</span><span style="font-family:宋体">这种风&#26684;呢？</span><br><br><span style="font-family:宋体">首先要做的是配置一个切点</span>,<span style="font-family:宋体">据说切点的表示方式在</span><span style="font-family:Calibri">Spring</span><span style="font-family:宋体">中有好几种，但是常用的只有两种：</span><span style="font-family:Calibri">1.</span><span style="font-family:宋体">使用正则表达式</span><span style="font-family:Calibri">2.</span><span style="font-family:宋体">使用</span><span style="font-family:Calibri">AspectJ</span><span style="font-family:宋体">表达式</span><span style="font-family:Calibri">AspectJ</span><span style="font-family:宋体">我不是很熟悉</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">我也是熟悉</span><br><br><span style="font-family:宋体">党</span> or <span style="font-family:宋体">精通党？</span><span style="font-family:Calibri">),</span><span style="font-family:宋体">我还是习惯用正则表达式</span></span><br><br>Spring<span style="font-family:宋体">使用</span><span style="font-family:Calibri">org.springframework.aop.support.JdkRegexpMethodPointcut</span><span style="font-family:宋体">来定义正则表达式切点</span><br><br>&lt;bean id=&quot;spleepPointcut&quot; class=&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot;&gt;<br><br>&nbsp; &lt;property name=&quot;pattern&quot; value=&quot;.sleep&quot;/&gt;<br><br>&lt;/bean&gt;<br><br>pattern<span style="font-family:宋体">属性指定了正则表达式，它匹配所有的</span><span style="font-family:Calibri">sleep</span><span style="font-family:宋体">方法</span><br><br><span style="font-family:宋体">切点仅仅是定义了故事发生的地点，还有故事发生的时间以及最重要的故事的内容</span>,<span style="font-family:宋体">就是通知了，我们需要把通知跟切点结合起来，我们要使用的通知者是</span><span style="font-family:Calibri">:</span><br><br>org.springframework.aop.support.DefaultPointcutAdvisor<br><br>&lt;bean id=&quot;sleepHelperAdvisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp; &lt;property name=&quot;advice&quot; ref=&quot;sleepHelper&quot;/&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp; &lt;property name=&quot;pointcut&quot; ref=&quot;sleepPointcut&quot;/&gt;<br><br>&lt;/bean&gt;<br><br><span style="font-family:宋体">切入点和通知都配置完成，接下来该调用</span>ProxyFactoryBean<span style="font-family:宋体">产生代理对象了</span><br><br>&lt;bean id=&quot;humanProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp; &lt;property name=&quot;target&quot; ref=&quot;human&quot;/&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp; &lt;property name=&quot;interceptorNames&quot; value=&quot;sleepHelperAdvisor&quot; /&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp; &lt;property name=&quot;proxyInterfaces&quot; value=&quot;test.spring.aop.bean.Sleepable&quot; /&gt;<br><br>&lt;/bean&gt;<br><br>ProxyFactoryBean<span style="font-family:宋体">是一个代理，我们可以把它转换为</span><span style="font-family:Calibri">proxyInterfaces</span><span style="font-family:宋体">中指定的实现该</span><span style="font-family:Calibri">interface</span><span style="font-family:宋体">的代理对象</span><span style="font-family:Calibri">:</span><br><br>import org.springframework.aop.framework.ProxyFactoryBean;<br><br>import org.springframework.context.ApplicationContext;<br><br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br><br>import test.spring.aop.bean.Sleepable;<br><br>public class Test {<br><br>&nbsp;&nbsp;&nbsp; public static void main(String[] args){<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ApplicationContext appCtx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sleepable sleeper = (Sleepable)appCtx.getBean(&quot;humanProxy&quot;);<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sleeper.sleep();<br><br>&nbsp;&nbsp;&nbsp; }<br><br>}<br><br><span style="font-family:宋体">程序运行产生结果：</span><br><br><span style="font-family:宋体">通常情况下睡觉之前要脱衣服！</span><br><br><span style="font-family:宋体">睡觉啦</span>~<span style="font-family:宋体">梦中自有颜如玉</span><span style="font-family:Calibri">!</span><br><br><span style="font-family:宋体">起床后要先穿衣服！</span><br><br>OK!<span style="font-family:宋体">这是我们想要的结果，但是上面这个过程貌&#20284;有点复杂，尤其是配置切点跟通知</span><span style="font-family:Calibri">,Spring</span><span style="font-family:宋体">提供了一种自动代理的功能，能让切点跟通知自动进行匹配，修改配置文件如下</span><span style="font-family:Calibri">:</span><br><br>&nbsp;&lt;bean id=&quot;sleepHelper&quot; class=&quot;test.spring.aop.bean.SleepHelper&quot;&gt;<br><br>&nbsp; &lt;/bean&gt;<br><br>&nbsp; &lt;bean id=&quot;sleepAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt;<br><br>&nbsp;&nbsp;&nbsp; &lt;property name=&quot;advice&quot; ref=&quot;sleepHelper&quot;/&gt;<br><br>&nbsp;&nbsp;&nbsp; &lt;property name=&quot;pattern&quot; value=&quot;.<em>sleep&quot;/&gt;<br><br>&nbsp; &lt;/bean&gt;<br><br>&nbsp; &lt;bean id=&quot;human&quot; class=&quot;test.spring.aop.bean.Human&quot;&gt;<br><br>&nbsp; &lt;/bean&gt;<br><br>&nbsp; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;/&gt;<br><br><span style="font-family:宋体">执行程序：</span><br><br>public class Test {<br><br>&nbsp;&nbsp;&nbsp; public static void main(String[] args){<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ApplicationContext appCtx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sleepable sleeper = (Sleepable)appCtx.getBean(&quot;human&quot;);<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sleeper.sleep();<br><br>&nbsp;&nbsp;&nbsp; }<br><br>}<br><br><span style="font-family:宋体">成功输出结果跟前面一样</span>!<br><br><span style="font-family:宋体">只要我们声明了</span>org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator(<span style="font-family:宋体">我勒个去的，名太长了</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">就能为方法匹配的</span><span style="font-family:Calibri">bean</span><span style="font-family:宋体">自动创建代理！</span><br><br><span style="font-family:宋体">但是这样还是要有很多工作要做</span>,<span style="font-family:宋体">有更简单的方式吗</span><span style="font-family:Calibri">?</span><span style="font-family:宋体">有！</span><br><br><span style="font-family:宋体">一种方式是使用</span>AspectJ<span style="font-family:宋体">提供的注解</span><span style="font-family:Calibri">:</span><br><br>package test.mine.spring.bean;<br><br>import org.aspectj.lang.annotation.AfterReturning;<br><br>import org.aspectj.lang.annotation.Aspect;<br><br>import org.aspectj.lang.annotation.Before;<br><br>import org.aspectj.lang.annotation.Pointcut;<br><br>@Aspect<br><br>public class SleepHelper {<br><br>&nbsp;&nbsp;&nbsp; public SleepHelper(){<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; @Pointcut(&quot;execution(</em> <em>.sleep())&quot;)<br><br>&nbsp;&nbsp;&nbsp; public void sleeppoint(){}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp; @Before(&quot;sleeppoint()&quot;)<br><br>&nbsp;&nbsp;&nbsp; public void beforeSleep(){<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;<span style="font-family:宋体">睡觉前要脱衣服</span><span style="font-family:Calibri">!&quot;);</span><br><br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; @AfterReturning(&quot;sleeppoint()&quot;)<br><br>&nbsp;&nbsp;&nbsp; public void afterSleep(){<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;<span style="font-family:宋体">睡醒了要穿衣服！</span><span style="font-family:Calibri">&quot;);</span><br><br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; <br><br>}<br><br><span style="font-family:宋体; color:#009900">用</span><span style="color:#009900">@Aspect<span style="font-family:宋体">的注解来标识切面</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">注意不要把它漏了，否则</span><span style="font-family:Calibri">Spring</span><span style="font-family:宋体">创建代理的时候会找不到它</span><span style="font-family:Calibri">,@Pointcut</span><span style="font-family:宋体">注解指定了切点，</span><span style="font-family:Calibri">@Before</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">@AfterReturning</span><span style="font-family:宋体">指定了运行时的通知，注</span><span style="font-family:宋体">意的是要在注解中传入切点的名称</span><br><br><span style="font-family:宋体">然后我们在</span>Spring<span style="font-family:宋体">配置文件上下点功夫</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">首先是增加</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">XML</span><span style="font-family:宋体">命名空间和声明相关</span><span style="font-family:Calibri">schema</span><br><br><span style="font-family:宋体">命名空间</span>:</span><br><br>xmlns:aop=&quot;<a href="http://www.springframework.org/schema/aop&amp;quot" target="_blank" rel="external">http://www.springframework.org/schema/aop&amp;quot</a>;<br><br>schema<span style="font-family:宋体">声明</span><span style="font-family:Calibri">:</span><br><br><a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a><br><br><a href="http://www.springframework.org/schema/aop/spring-aop-2.0.xsd" target="_blank" rel="external">http://www.springframework.org/schema/aop/spring-aop-2.0.xsd</a><br><br><br><br><span style="font-family:宋体">然后加上这个标签</span>:<br><br>&lt;aop:aspectj-autoproxy/&gt; <span style="font-family:宋体">有了这个</span><span style="font-family:Calibri">Spring</span><span style="font-family:宋体">就能够自动扫描被</span><span style="font-family:Calibri">@Aspect</span><span style="font-family:宋体">标注的切面了</span><br><br><br><br><span style="font-family:宋体">最后是运行，很简单方便了：</span><br><br>public class Test {<br><br><br><br>&nbsp;&nbsp;&nbsp; public static void main(String[] args){<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ApplicationContext appCtx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sleepable human = (Sleepable)appCtx.getBean(&quot;human&quot;);<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; human.sleep();<br><br>&nbsp;&nbsp;&nbsp; }<br><br>}<br><br><span style="font-family:宋体">下面我们来看最后一种常用的实现</span>AOP<span style="font-family:宋体">的方式</span><span style="font-family:Calibri">:</span><span style="font-family:宋体">使用</span><span style="font-family:Calibri">Spring</span><span style="font-family:宋体">来定义纯粹的</span><span style="font-family:Calibri">POJO</span><span style="font-family:宋体">切面</span><br><br><span style="font-family:宋体">前面我们用到了</span>&lt;aop:aspectj-autoproxy/&gt;<span style="font-family:宋体">标签</span><span style="font-family:Calibri">,Spring</span><span style="font-family:宋体">在</span><span style="font-family:Calibri">aop</span><span style="font-family:宋体">的命名空间里面还提供了其他的配置元素</span><span style="font-family:Calibri">:</span><br><br>&lt;aop:advisor&gt; <span style="font-family:宋体">定义一个</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">通知者</span><br><br>&lt;aop:after&gt; <span style="font-family:宋体">后通知</span><br><br>&lt;aop:after-returning&gt; <span style="font-family:宋体">返回后通知</span><br><br>&lt;aop:after-throwing&gt; <span style="font-family:宋体">抛出后通知</span><br><br>&lt;aop:around&gt; <span style="font-family:宋体">周围通知</span><br><br>&lt;aop:aspect&gt;<span style="font-family:宋体">定义一个切面</span><br><br>&lt;aop:before&gt;<span style="font-family:宋体">前通知</span><br><br>&lt;aop:config&gt;<span style="font-family:宋体">顶级配置元素，类&#20284;于</span><span style="font-family:Calibri">&lt;beans&gt;</span><span style="font-family:宋体">这种东西</span><br><br>&lt;aop:pointcut&gt;<span style="font-family:宋体">定义一个切点</span><br><br><span style="font-family:宋体">我们用</span>AOP<span style="font-family:宋体">标签来实现睡觉这个过程</span><span style="font-family:Calibri">:</span><br><br><span style="font-family:宋体">代码不变，只是修改配置文件</span>,<span style="font-family:宋体">加入</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">配置即可</span><span style="font-family:Calibri">:</span><br><br>&lt;aop:config&gt;<br><br>&nbsp;&nbsp;&nbsp; &lt;aop:aspect ref=&quot;sleepHelper&quot;&gt;<br><br>&nbsp;&nbsp;&nbsp; &lt;aop:before method=&quot;beforeSleep&quot; pointcut=&quot;execution(</em> <em>.sleep(..))&quot;/&gt;<br><br>&nbsp;&nbsp;&nbsp; &lt;aop:after method=&quot;afterSleep&quot; pointcut=&quot;execution(</em> <em>.sleep(..))&quot;/&gt;<br><br>&nbsp;&nbsp;&nbsp; &lt;/aop:aspect&gt;<br><br>&lt;/aop:config&gt;</em></p><br><strong>spring<span style="font-family:宋体">对</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">的支持</span><span style="font-family:Calibri">2:</span></strong><br><p align="left"><strong>1<span style="font-family:宋体">、如果目标对象实现了接口，默认情况下会采用</span><span style="font-family:Calibri">JDK</span><span style="font-family:宋体">的动态代理实现</span><span style="font-family:Calibri">AOP</span><br><br>2<span style="font-family:宋体">、如果目标对象实现了接口，可以强制使用</span><span style="font-family:Calibri">CGLIB</span><span style="font-family:宋体">实现</span><span style="font-family:Calibri">AOP</span><br><br>3<span style="font-family:宋体">、如果目标对象没有实现了接口，必须采用</span><span style="font-family:Calibri">CGLIB</span><span style="font-family:宋体">库，</span><span style="font-family:Calibri">spring</span><span style="font-family:宋体">会自动在</span><span style="font-family:Calibri">JDK</span><span style="font-family:宋体">动态代理和</span><span style="font-family:Calibri">CGLIB</span><span style="font-family:宋体">之间转换</span></strong></p><br><p align="left"><strong><br><br><span style="font-family:宋体">在实现接口的情况下</span>,<span style="font-family:宋体">如何强制使用</span><span style="font-family:Calibri">CGLIB</span><span style="font-family:宋体">实现</span><span style="font-family:Calibri">AOP</span><span style="font-family:宋体">？</span><br><br>&nbsp; <span style="font-family:宋体">添加</span><span style="font-family:Calibri">CGLIB</span><span style="font-family:宋体">库，</span><span style="font-family:Calibri">SPRING_HOME/cglib/<em>.jar</em></span><br><br>&nbsp; <span style="font-family:宋体">在</span><span style="font-family:Calibri">spring</span><span style="font-family:宋体">配置文件中加入</span><span style="font-family:Calibri">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span><br><br>&nbsp;<br><br>JDK<span style="font-family:宋体">动态代理和</span><span style="font-family:Calibri">CGLIB</span><span style="font-family:宋体">字节码生成的区别？</span><br><br>&nbsp;<em> JDK<span style="font-family:宋体">动态代理只能对实现了接口的类生成代理，而不能针对类</span><br><br>&nbsp;</em> CGLIB<span style="font-family:宋体">是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法</span><br><br>&nbsp;&nbsp; <span style="font-family:宋体">因为是继承，所以该类或方法最好不要声明成</span><span style="font-family:Calibri">final&nbsp;</span></strong></p><br><p align="left">&nbsp;源码下篇</p><br><p align="left">&nbsp;</p><br></blockquote><br><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/07/31/aop-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/31/aop-03/" itemprop="url">转载：Spring AOP手动控制事务范例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-31T15:49:17+08:00">
                2017-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;div id=&quot;cnblogs_post_body&quot;&gt;&lt;div class=&quot;cnblogs_code&quot;&gt;
</code></pre><p><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> testDelete(String jobCode) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {<br>      </span><span style="color: #0000ff;">boolean</span> flag = <span style="color: #0000ff;">false</span><span style="color: #000000;">;<br>      </span><span style="color: #008000;">//</span><span style="color: #008000;">1.获取事务控制管理器</span><br>      DataSourceTransactionManager transactionManager =<span style="color: #000000;"> HqznContext.getBean(<br>           </span>“transactionManager”, DataSourceTransactionManager.<span style="color: #0000ff;">class</span><span style="color: #000000;">);//这里是spring手动注入bean,也可以使用自动注入 HqznContext是一个工具类:主要用于简化spring手动注入代码<br>      </span><span style="color: #008000;">//</span><span style="color: #008000;">2.获取事务定义</span><br>      DefaultTransactionDefinition def = <span style="color: #0000ff;">new</span><span style="color: #000000;"> DefaultTransactionDefinition();<br>      </span><span style="color: #008000;">//</span><span style="color: #008000;">3.设置事务隔离级别，开启新事务</span><br><span style="color: #000000;">      def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);<br>      </span><span style="color: #008000;">//</span><span style="color: #008000;">4.获得事务状态</span><br>      TransactionStatus status =<span style="color: #000000;"> transactionManager.getTransaction(def);<br>      </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {<br>        </span><span style="color: #008000;">//</span><span style="color: #008000;">5.具体的数据库操作（多个）</span><br>        BOBaseJob r = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BOBaseJob();<br>        r.setJobCode(</span>“SW001”<span style="color: #000000;">);<br>        r.setJobName(</span>“事务001”<span style="color: #000000;">);<br>        BOBaseJobMapper.deleteByPrimaryKey(jobCode);<br>        BOBaseJobMapper.insert(r);<br>        flag </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;<br>        transactionManager.commit(status);<br>      } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {<br>        transactionManager.rollback(status);<br>      }<br>      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> flag;<br>   }</span></pre><br></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/07/31/aop-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/31/aop-02/" itemprop="url">转载:Spring事务配置的五种方式和spring里面事务的传播属性和事务隔离级别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-31T15:42:33+08:00">
                2017-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br><p class="cnt"><strong style="color: black; background-color: #ffff66;"><span style="font-size: medium;">Spring事务配置的五种方式</span></strong></p><br><p class="cnt"><strong style="color: black; background-color: #ffff66;"></strong></p><br><div class="tit">前段时间对Spring的事务配置做了比较深入的研究，在此之间对Spring的事务配置虽说也配置过，但是一直没有一个清楚的认识。通过这次的学习发觉Spring的事务配置只要把思路理清，还是比较好掌握的。<br><p>&nbsp;&nbsp;&nbsp; 总结如下：</p><br><p>&nbsp;&nbsp;&nbsp; Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。</p><br><p>&nbsp;&nbsp;&nbsp; DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用Hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager。</p><br><p>&nbsp;&nbsp;&nbsp; 具体如下图：</p><br><p><a href="http://www.blogjava.net/images/blogjava_net/robbie/WindowsLiveWriter/Spring_9C9C/Spring%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%20(2).jpg" target="_blank" rel="external"><img src="http://hi.csdn.net/attachment/201105/12/0_1305203336U18K.gif" alt=""></a></p><br><p>&nbsp;</p><br><p>&nbsp;&nbsp;&nbsp; 根据代理机制的不同，总结了五种Spring事务的配置方式，配置文件如下：</p><br><p>&nbsp;&nbsp;&nbsp; 第一种方式：每个Bean都有一个代理</p><br><div style="padding-right: 5px; padding-left: 4px; font-size: 13px; padding-bottom: 4px; width: 98%; padding-top: 4px; background-color: #eeeeee; border: #cccccc 1px solid;"><!--<br />
<br />
Code highlighting produced by Actipro CodeHighlighter (freeware)<br />
http://www.CodeHighlighter.com/<br />
<br />
--><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version=”1.0” encoding=”UTF-8”</span><span style="color: #0000ff;">?&gt;</span><span style="color: #000000;"><br></span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:xsi</span><span style="color: #0000ff;">=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema-instance</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:context</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:aop</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a>“</span><span style="color: #ff0000;"><br></span><span style="color: #ff0000;">&nbsp;&nbsp;&nbsp; xsi:schemaLocation</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context/spring-context-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/context/spring-context-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a> <a href="http://www.springframework.org/schema/aop/spring-aop-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</a>“</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.LocalSessionFactoryBean”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configLocation”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”classpath:hibernate.cfg.xml”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configurationClass”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”org.hibernate.cfg.AnnotationConfiguration”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 定义事务管理器（声明式的事务） </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.HibernateTransactionManager”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 配置DAO </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”userDaoTarget”</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">=”com.bluesky.spring.dao.UserDaoImpl”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”userDao”</span><span style="color: #ff0000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.transaction.interceptor.TransactionProxyFactoryBean”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 配置事务管理器 </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”target”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”userDaoTarget”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”proxyInterfaces”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”com.bluesky.spring.dao.GeneratorDao”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 配置事务属性 </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”transactionAttributes”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">props</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">prop </span><span style="color: #ff0000;">key</span><span style="color: #0000ff;">=”<em>“</em></span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">PROPAGATION_REQUIRED</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">prop</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">props</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">property</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; </span><span style="color: #000000;"><br></span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></div><br><p>&nbsp;&nbsp;&nbsp; 第二种方式：所有Bean共享一个代理基类</p><br><div style="padding-right: 5px; padding-left: 4px; font-size: 13px; padding-bottom: 4px; width: 98%; padding-top: 4px; background-color: #eeeeee; border: #cccccc 1px solid;"><!--<br />
<br />
Code highlighting produced by Actipro CodeHighlighter (freeware)<br />
http://www.CodeHighlighter.com/<br />
<br />
--><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version=”1.0” encoding=”UTF-8”</span><span style="color: #0000ff;">?&gt;</span><span style="color: #000000;"><br></span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:xsi</span><span style="color: #0000ff;">=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema-instance</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:context</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:aop</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xsi:schemaLocation</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context/spring-context-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/context/spring-context-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a> <a href="http://www.springframework.org/schema/aop/spring-aop-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</a>“</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.LocalSessionFactoryBean”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configLocation”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”classpath:hibernate.cfg.xml”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configurationClass”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”org.hibernate.cfg.AnnotationConfiguration”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 定义事务管理器（声明式的事务） </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.HibernateTransactionManager”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”transactionBase”</span><span style="color: #ff0000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.transaction.interceptor.TransactionProxyFactoryBean”</span><span style="color: #ff0000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lazy-init</span><span style="color: #0000ff;">=”true”</span><span style="color: #ff0000;"> abstract</span><span style="color: #0000ff;">=”true”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 配置事务管理器 </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 配置事务属性 </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”transactionAttributes”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">props</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">prop </span><span style="color: #ff0000;">key</span><span style="color: #0000ff;">=”“</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">PROPAGATION_REQUIRED</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">prop</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">props</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">property</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsnbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 配置DAO </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”userDaoTarget”</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">=”com.bluesky.spring.dao.UserDaoImpl”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”userDao”</span><span style="color: #ff0000;"> parent</span><span style="color: #0000ff;">=”transactionBase”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”target”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”userDaoTarget”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br></span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></div><br><p>第三种方式：使用拦截器</p><br><div style="padding-right: 5px; padding-left: 4px; font-size: 13px; padding-bottom: 4px; width: 98%; padding-top: 4px; background-color: #eeeeee; border: #cccccc 1px solid;"><!--<br />
<br />
Code highlighting produced by Actipro CodeHighlighter (freeware)<br />
http://www.CodeHighlighter.com/<br />
<br />
--><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version=”1.0” encoding=”UTF-8”</span><span style="color: #0000ff;">?&gt;</span><span style="color: #000000;"><br></span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:xsi</span><span style="color: #0000ff;">=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema-instance</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:context</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:aop</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a>“</span><span style="color: #ff0000;"><br></span><span style="color: #ff0000;">&nbsp;&nbsp;&nbsp; xsi:schemaLocation</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context/spring-context-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/context/spring-context-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a> <a href="http://www.springframework.org/schema/aop/spring-aop-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</a>“</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.LocalSessionFactoryBean”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configLocation”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”classpath:hibernate.cfg.xml”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configurationClass”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”org.hibernate.cfg.AnnotationConfiguration”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 定义事务管理器（声明式的事务） </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.HibernateTransactionManager”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp;<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”transactionInterceptor”</span><span style="color: #ff0000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.transaction.interceptor.TransactionInterceptor”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 配置事务属性 </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”transactionAttributes”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">props</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">prop </span><span style="color: #ff0000;">key</span><span style="color: #0000ff;">=”<em>“</em></span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">PROPAGATION_REQUIRED</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">prop</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">props</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">property</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">class</span><span style="color: #0000ff;">=”org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”beanNames”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">list</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">value</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">Dao</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">value</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br></span><span style="color: #000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">list</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">property</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”interceptorNames”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">list</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">value</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">transactionInterceptor</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">value</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">list</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">property</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 配置DAO </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”userDao”</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">=”com.bluesky.spring.dao.UserDaoImpl”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br></span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></div><br><p>第四种方式：使用tx标签配置的拦截器</p><br><div style="padding-right: 5px; padding-left: 4px; font-size: 13px; padding-bottom: 4px; width: 98%; padding-top: 4px; background-color: #eeeeee; border: #cccccc 1px solid;"><!--<br />
<br />
Code highlighting produced by Actipro CodeHighlighter (freeware)<br />
http://www.CodeHighlighter.com/<br />
<br />
--><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version=”1.0” encoding=”UTF-8”</span><span style="color: #0000ff;">?&gt;</span><span style="color: #000000;"><br></span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:xsi</span><span style="color: #0000ff;">=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema-instance</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:context</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:aop</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:tx</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/tx" target="_blank" rel="external">http://www.springframework.org/schema/tx</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xsi:schemaLocation</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context/spring-context-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/context/spring-context-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a> <a href="http://www.springframework.org/schema/aop/spring-aop-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/tx" target="_blank" rel="external">http://www.springframework.org/schema/tx</a> <a href="http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</a>“</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">context:annotation-config </span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">context:component-scan </span><span style="color: #ff0000;">base-package</span><span style="color: #0000ff;">=”com.bluesky”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.LocalSessionFactoryBean”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configLocation”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”classpath:hibernate.cfg.xml”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configurationClass”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”org.hibernate.cfg.AnnotationConfiguration”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 定义事务管理器（声明式的事务） </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.HibernateTransactionManager”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">tx:advice </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”txAdvice”</span><span style="color: #ff0000;"> transaction-manager</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">tx:attributes</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">tx:method </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”<em>“</em></span><span style="color: #ff0000;"> propagation</span><span style="color: #0000ff;">=”REQUIRED”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">tx:attributes</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">tx:advice</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">aop:config</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">aop:pointcut </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”interceptorPointCuts”</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression</span><span style="color: #0000ff;">=”execution( com.bluesky.spring.dao.<em>.</em>(..))”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">aop:advisor </span><span style="color: #ff0000;">advice-ref</span><span style="color: #0000ff;">=”txAdvice”</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointcut-ref</span><span style="color: #0000ff;">=”interceptorPointCuts”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">aop:config</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br></span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></div><br><p>第五种方式：全注解<br><!--<br />
<br />
Code highlighting produced by Actipro CodeHighlighter (freeware)<br />
http://www.CodeHighlighter.com/<br />
<br />
--></p><br><div style="padding-right: 5px; padding-left: 4px; font-size: 13px; padding-bottom: 4px; width: 98%; padding-top: 4px; background-color: #eeeeee; border: #cccccc 1px solid;"><!--<br />
<br />
Code highlighting produced by Actipro CodeHighlighter (freeware)<br />
http://www.CodeHighlighter.com/<br />
<br />
--><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version=”1.0” encoding=”UTF-8”</span><span style="color: #0000ff;">?&gt;</span><span style="color: #000000;"><br></span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:xsi</span><span style="color: #0000ff;">=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema-instance</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:context</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:aop</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xmlns:tx</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/tx" target="_blank" rel="external">http://www.springframework.org/schema/tx</a>“</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp; xsi:schemaLocation</span><span style="color: #0000ff;">=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/context/spring-context-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/context/spring-context-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/aop" target="_blank" rel="external">http://www.springframework.org/schema/aop</a> <a href="http://www.springframework.org/schema/aop/spring-aop-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.springframework.org/schema/tx" target="_blank" rel="external">http://www.springframework.org/schema/tx</a> <a href="http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" target="_blank" rel="external">http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</a>“</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">context:annotation-config </span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">context:component-scan </span><span style="color: #ff0000;">base-package</span><span style="color: #0000ff;">=”com.bluesky”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">tx:annotation-driven </span><span style="color: #ff0000;">transaction-manager</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.LocalSessionFactoryBean”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configLocation”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”classpath:hibernate.cfg.xml”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”configurationClass”</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">=”org.hibernate.cfg.AnnotationConfiguration”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">&nbsp; <br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #008000;">&lt;!–</span><span style="color: #008000;"> 定义事务管理器（声明式的事务） </span><span style="color: #008000;">–&gt;</span><span style="color: #000000;">&nbsp; <br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">=”transactionManager”</span><span style="color: #ff0000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class</span><span style="color: #0000ff;">=”org.springframework.orm.hibernate3.HibernateTransactionManager”</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;"> ref</span><span style="color: #0000ff;">=”sessionFactory”</span><span style="color: #ff0000;">&nbsp;</span><span style="color: #0000ff;">/&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;"><br>&nbsp;&nbsp;&nbsp; <br></span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></div><br><p>此时在DAO上需加上@Transactional注解，如下：</p><br><div style="padding-right: 5px; padding-left: 4px; font-size: 13px; padding-bottom: 4px; width: 98%; padding-top: 4px; background-color: #eeeeee; border: #cccccc 1px solid;"><!--<br />
<br />
Code highlighting produced by Actipro CodeHighlighter (freeware)<br />
http://www.CodeHighlighter.com/<br />
<br />
--><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.bluesky.spring.dao;<br><br></span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.List;<br><br></span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.hibernate.SessionFactory;<br></span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.beans.factory.annotation.Autowired;<br></span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.orm.hibernate3.support.HibernateDaoSupport;<br></span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.stereotype.Component;<br><br></span><span style="color: #0000ff;">import</span><span style="color: #000000;"> com.bluesky.spring.domain.User;<br><br>@Transactional<br>@Component(</span><span style="color: #000000;">“</span><span style="color: #000000;">userDao</span><span style="color: #000000;">“</span><span style="color: #000000;">)<br></span><span style="color: #0000ff;">public</span><span style="color: #000000;">&nbsp;</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> UserDaoImpl </span><span style="color: #0000ff;">extends</span><span style="color: #000000;"> HibernateDaoSupport </span><span style="color: #0000ff;">implements</span><span style="color: #000000;"> UserDao {<br><br>&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> List</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">User</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> listUsers() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: #0000ff;">return</span><span style="color: #000000;">&nbsp;</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.getSession().createQuery(</span><span style="color: #000000;">“</span><span style="color: #000000;">from User</span><span style="color: #000000;">“</span><span style="color: #000000;">).list();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <img src="http://www.blogjava.net/Images/dot.gif" alt=""><br>}</span></div><br><a name="baidusnap0"></a><span style="font-size: medium;"><strong style="color: black; background-color: #ffff66;">spring</strong>里面事务的传播属性和</span><a name="baidusnap1"></a><strong style="color: black; background-color: #a0ffff;"><span style="font-size: medium;">事务隔离级别</span></strong></div><br><p><br><div class="tit"><strong style="color: black; background-color: #a0ffff;"></strong></div><br></p><br><div class="tit"><strong style="color: black; background-color: #a0ffff;"><span style="font-size: medium;"><br><table border="0"><br><tbody><br><tr><br><td><br><p>&nbsp;</p><br><p style="text-indent: 2em;">一、Propagation （事务的传播属性）</p><br><p style="text-indent: 2em;">Propagation ：　　key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：&nbsp;&nbsp; </p><br><p style="text-indent: 2em;">PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</p><br><p style="text-indent: 2em;">PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。</p><br><p style="text-indent: 2em;">PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。</p><br><p style="text-indent: 2em;">PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。</p><br><p style="text-indent: 2em;">PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><br><p style="text-indent: 2em;">PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。</p><br><p style="text-indent: 2em;">1： PROPAGATION_REQUIRED</p><br><p style="text-indent: 2em;">加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务</p><br><p style="text-indent: 2em;">比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，</p><br><p style="text-indent: 2em;">ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA</p><br><p style="text-indent: 2em;">的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。</p><br><p style="text-indent: 2em;">这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被</p><br><p style="text-indent: 2em;">提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚</p><br><p style="text-indent: 2em;">2： PROPAGATION_SUPPORTS</p><br><p style="text-indent: 2em;">如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行</p><br><p style="text-indent: 2em;">3： PROPAGATION_MANDATORY</p><br><p style="text-indent: 2em;">必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常</p><br><p style="text-indent: 2em;">4： PROPAGATION_REQUIRES_NEW</p><br><p style="text-indent: 2em;">这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，</p><br><p style="text-indent: 2em;">那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，</p><br><p style="text-indent: 2em;">他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在</p><br><p style="text-indent: 2em;">两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，</p><br><p style="text-indent: 2em;">如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。</p><br><p style="text-indent: 2em;">5： PROPAGATION_NOT_SUPPORTED</p><br><p style="text-indent: 2em;">当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，</p><br><p style="text-indent: 2em;">那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。</p><br><p style="text-indent: 2em;">6： PROPAGATION_NEVER</p><br><p style="text-indent: 2em;">不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，</p><br><p style="text-indent: 2em;">那么ServiceB.methodB就要抛出异常了。</p><br><p style="text-indent: 2em;">7： PROPAGATION_NESTED</p><br><p style="text-indent: 2em;">理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，</p><br><p style="text-indent: 2em;">而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。</p><br><p style="text-indent: 2em;">而Nested事务的好处是他有一个savepoint。</p><br><p style="text-indent: 2em;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><br><p style="text-indent: 2em;">ServiceA {</p><br><p style="text-indent: 2em;">/<strong></strong></p><br><p style="text-indent: 2em;"><em> 事务属性配置为 PROPAGATION_REQUIRED</em></p><br><p style="text-indent: 2em;">/</p><br><p style="text-indent: 2em;">void methodA() {</p><br><p style="text-indent: 2em;">try {</p><br><p style="text-indent: 2em;">//savepoint</p><br><p style="text-indent: 2em;">ServiceB.methodB(); //PROPAGATION_NESTED 级别</p><br><p style="text-indent: 2em;">} catch (SomeException) {</p><br><p style="text-indent: 2em;">// 执行其他业务, 如 ServiceC.methodC();</p><br><p style="text-indent: 2em;">}</p><br><p style="text-indent: 2em;">}</p><br><p style="text-indent: 2em;">}</p><br><p style="text-indent: 2em;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p></td></tr></tbody></table></span></strong><p></p><br><p style="text-indent: 2em;">也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如</p><br><p style="text-indent: 2em;">ServiceC.methodC，继续执行，来尝试完成自己的事务。</p><br><p style="text-indent: 2em;">但是这个事务并没有在EJB标准中定义。</p><br><p style="text-indent: 2em;">二、Isolation Level(事务隔离等级):</p><br><p style="text-indent: 2em;">1、Serializable：最严格的级别，事务串行执行，资源消耗最大；</p><br><p style="text-indent: 2em;">2、REPEATABLE READ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了&ldquo;脏读取&rdquo;和&ldquo;不可重复读取&rdquo;的情况，但是带来了更多的性能损失。</p><br><p style="text-indent: 2em;">3、READ COMMITTED:大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了&ldquo;脏读取&rdquo;。该级别适用于大多数系统。</p><br><p style="text-indent: 2em;">4、Read Uncommitted：保证了读取过程中不会读取到非法数据。隔离级别在于处理多事务的并发问题。</p><br><p style="text-indent: 2em;">我们知道并行可以提高数据库的吞吐量和效率，但是并不是所有的并发事务都可以并发运行，这需要查看数据库教材的可串行化条件判断了。</p><br><p style="text-indent: 2em;">这里就不阐述。</p><br><p style="text-indent: 2em;">我们首先说并发中可能发生的3中不讨人喜欢的事情</p><br><p style="text-indent: 2em;">1： Dirty reads–读脏数据。也就是说，比如事务A的未提交（还依然缓存）的数据被事务B读走，如果事务A失败回滚，会导致事务B所读取的的数据是错误的。</p><br><p style="text-indent: 2em;">2： non-repeatable reads–数据不可重复读。比如事务A中两处读取数据-total-的值。在第一读的时候，total是100，然后事务B就把total的数据改成 200，事务A再读一次，结果就发现，total竟然就变成200了，造成事务A数据混乱。</p><br><p style="text-indent: 2em;">3： phantom reads–幻象读数据，这个和non-repeatable reads相似，也是同一个事务中多次读不一致的问题。但是non-repeatable reads的不一致是因为他所要取的数据集被改变了（比如total的数据），但是phantom reads所要读的数据的不一致却不是他所要读的数据集改变，而是他的条件数据集改变。比如Select account.id where account.name=”ppgogo<em>“,第一次读去了6个符合条件的id，第二次读取的时候，由于事务b把一个帐号的名字由”dd”改成”ppgogo1”，结果取出来了7个数据。</em></p><br><p style="text-indent: 2em;">&nbsp;</p><br><p style="text-indent: 2em;"><br><table style="width: 317px;" border="0"><br><tbody><br><tr><br><td>&nbsp;</td><br><td>Dirty reads</td><br><td>non-repeatable reads</td><br><td>phantom reads</td><br></tr><br><tr><br><td>Serializable</td><br><td>不会</td><br><td>不会</td><br><td>不会</td><br></tr><br><tr><br><td>REPEATABLE READ</td><br><td>不会</td><br><td>不会</td><br><td>会</td><br></tr><br><tr><br><td>READ COMMITTED</td><br><td>不会</td><br><td>会</td><br><td>会</td><br></tr><br><tr><br><td>Read Uncommitted</td><br><td>会</td><br><td>会</td><br><td>会</td><br></tr><br></tbody><br></table><br></p><br><p style="text-indent: 2em;">&nbsp;</p><br><p style="text-indent: 2em;">三、readOnly</p><br><p style="text-indent: 2em;">事务属性中的readOnly标志表示对应的事务应该被最优化为只读事务。</p><br><p style="text-indent: 2em;">这是一个最优化提示。在一些情况下，一些事务策略能够起到显著的最优化效果，例如在使用Object/Relational映射工具（如：Hibernate或TopLink）时避免dirty checking（试图&ldquo;刷新&rdquo;）。</p><br><p style="text-indent: 2em;">四、Timeout</p><br><p style="text-indent: 2em;">在事务属性中还有定义&ldquo;timeout&rdquo;值的选项，指定事务超时为几秒。在JTA中，这将被简单地传递到J2EE服务器的事务协调程序，并据此得到相应的解释</p><br><p style="text-indent: 2em;">&nbsp;</p><br><br><br><br><br><p style="text-indent: 2em;"><strong style="color: black; background-color: #ffff66;">spring</strong>里面事务的传播属性和<strong style="color: black; background-color: #a0ffff;">事务隔离级别</strong></p><br><p style="text-indent: 2em;"><br><table border="0"><br><tbody><br><tr><br><td><br><p>&nbsp;</p><br><p style="text-indent: 2em;">一、Propagation （事务的传播属性）</p><br><p style="text-indent: 2em;">Propagation ：　　key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</p><br><p style="text-indent: 2em;">PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。</p><br><p style="text-indent: 2em;">PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。</p><br><p style="text-indent: 2em;">PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。</p><br><p style="text-indent: 2em;">PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><br><p style="text-indent: 2em;">PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。</p><br><p style="text-indent: 2em;">1： PROPAGATION_REQUIRED</p><br><p style="text-indent: 2em;">加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务</p><br><p style="text-indent: 2em;">比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，</p><br><p style="text-indent: 2em;">ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA</p><br><p style="text-indent: 2em;">的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。</p><br><p style="text-indent: 2em;">这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被</p><br><p style="text-indent: 2em;">提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚</p><br><p style="text-indent: 2em;">2： PROPAGATION_SUPPORTS</p><br><p style="text-indent: 2em;">如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行</p><br><p style="text-indent: 2em;">3： PROPAGATION_MANDATORY</p><br><p style="text-indent: 2em;">必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常</p><br><p style="text-indent: 2em;">4： PROPAGATION_REQUIRES_NEW</p><br><p style="text-indent: 2em;">这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，</p><br><p style="text-indent: 2em;">那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，</p><br><p style="text-indent: 2em;">他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在</p><br><p style="text-indent: 2em;">两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，</p><br><p style="text-indent: 2em;">如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。</p><br><p style="text-indent: 2em;">5： PROPAGATION_NOT_SUPPORTED</p><br><p style="text-indent: 2em;">当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，</p><br><p style="text-indent: 2em;">那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。</p><br><p style="text-indent: 2em;">6： PROPAGATION_NEVER</p><br><p style="text-indent: 2em;">不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，</p><br><p style="text-indent: 2em;">那么ServiceB.methodB就要抛出异常了。</p><br><p style="text-indent: 2em;">7： PROPAGATION_NESTED</p><br><p style="text-indent: 2em;">理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，</p><br><p style="text-indent: 2em;">而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。</p><br><p style="text-indent: 2em;">而Nested事务的好处是他有一个savepoint。</p><br><p style="text-indent: 2em;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><br><p style="text-indent: 2em;">ServiceA {</p><br><p style="text-indent: 2em;">/<strong></strong></p><br><p style="text-indent: 2em;"><em> 事务属性配置为 PROPAGATION_REQUIRED</em></p><br><p style="text-indent: 2em;">/</p><br><p style="text-indent: 2em;">void methodA() {</p><br><p style="text-indent: 2em;">try {</p><br><p style="text-indent: 2em;">//savepoint</p><br><p style="text-indent: 2em;">ServiceB.methodB(); //PROPAGATION_NESTED 级别</p><br><p style="text-indent: 2em;">} catch (SomeException) {</p><br><p style="text-indent: 2em;">// 执行其他业务, 如 ServiceC.methodC();</p><br><p style="text-indent: 2em;">}</p><br><p style="text-indent: 2em;">}</p><br><p style="text-indent: 2em;">}</p><br><p style="text-indent: 2em;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><br><p style="text-indent: 2em;">也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如</p><br><p style="text-indent: 2em;">ServiceC.methodC，继续执行，来尝试完成自己的事务。</p><br><p style="text-indent: 2em;">但是这个事务并没有在EJB标准中定义。</p><br><p style="text-indent: 2em;">二、Isolation Level(事务隔离等级):</p><br><p style="text-indent: 2em;">1、Serializable：最严格的级别，事务串行执行，资源消耗最大；</p><br><p style="text-indent: 2em;">2、REPEATABLE READ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了&ldquo;脏读取&rdquo;和&ldquo;不可重复读取&rdquo;的情况，但是带来了更多的性能损失。</p><br><p style="text-indent: 2em;">3、READ COMMITTED:大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了&ldquo;脏读取&rdquo;。该级别适用于大多数系统。</p><br><p style="text-indent: 2em;">4、Read Uncommitted：保证了读取过程中不会读取到非法数据。隔离级别在于处理多事务的并发问题。</p><br><p style="text-indent: 2em;">我们知道并行可以提高数据库的吞吐量和效率，但是并不是所有的并发事务都可以并发运行，这需要查看数据库教材的可串行化条件判断了。</p><br><p style="text-indent: 2em;">这里就不阐述。</p><br><p style="text-indent: 2em;">我们首先说并发中可能发生的3中不讨人喜欢的事情</p><br><p style="text-indent: 2em;">1： Dirty reads–读脏数据。也就是说，比如事务A的未提交（还依然缓存）的数据被事务B读走，如果事务A失败回滚，会导致事务B所读取的的数据是错误的。</p><br><p style="text-indent: 2em;">2： non-repeatable reads–数据不可重复读。比如事务A中两处读取数据-total-的值。在第一读的时候，total是100，然后事务B就把total的数据改成 200，事务A再读一次，结果就发现，total竟然就变成200了，造成事务A数据混乱。</p><br><p style="text-indent: 2em;">3： phantom reads–幻象读数据，这个和non-repeatable reads相似，也是同一个事务中多次读不一致的问题。但是non-repeatable reads的不一致是因为他所要取的数据集被改变了（比如total的数据），但是phantom reads所要读的数据的不一致却不是他所要读的数据集改变，而是他的条件数据集改变。比如Select account.id where account.name=”ppgogo*”,第一次读去了6个符合条件的id，第二次读取的时候，由于事务b把一个帐号的名字由”dd”改成”ppgogo1”，结果取出来了7个数据。</p><br><p style="text-indent: 2em;">&nbsp;</p><br><p style="text-indent: 2em;"><br><table style="width: 317px;" border="0"><br><tbody><br><tr><br><td>&nbsp;</td><br><td>Dirty reads</td><br><td>non-repeatable reads</td><br><td>phantom reads</td><br></tr><br><tr><br><td>Serializable</td><br><td>不会</td><br><td>不会</td><br><td>不会</td><br></tr><br><tr><br><td>REPEATABLE READ</td><br><td>不会</td><br><td>不会</td><br><td>会</td><br></tr><br><tr><br><td>READ COMMITTED</td><br><td>不会</td><br><td>会</td><br><td>会</td><br></tr><br><tr><br><td>Read Uncommitted</td><br><td>会</td><br><td>会</td><br><td>会</td><br></tr><br></tbody><br></table><br></p><br><p style="text-indent: 2em;">&nbsp;</p><br><p style="text-indent: 2em;">三、readOnly</p><br><p style="text-indent: 2em;">事务属性中的readOnly标志表示对应的事务应该被最优化为只读事务。</p><br><p style="text-indent: 2em;">这是一个最优化提示。在一些情况下，一些事务策略能够起到显著的最优化效果，例如在使用Object/Relational映射工具（如：Hibernate或TopLink）时避免dirty checking（试图&ldquo;刷新&rdquo;）。</p><br><p style="text-indent: 2em;">四、Timeout</p><br><p style="text-indent: 2em;">在事务属性中还有定义&ldquo;timeout&rdquo;值的选项，指定事务超时为几秒。在JTA中，这将被简单地传递到J2EE服务器的事务协调程序，并据此得到相应的解释</p><br><p style="text-indent: 2em;">&nbsp;</p><br><p style="text-indent: 2em;">&nbsp;</p><br><p style="text-indent: 2em;">20110112</p><br><p style="text-indent: 2em;"><span id="articlecontent" class="wenzhang_con" style="width: 740px;" onmouseup="NewHighlight(event)">数据库提供了四种事务隔离级别, 不同的隔离级别采用不同的锁类开来实现. <br><br>在四种隔离级别中, Serializable的级别最高, Read Uncommited级别最低. <br><br>大多数数据库的默认隔离级别为: Read Commited,如Sql Server , Oracle. <br><br>少数数据库默认的隔离级别为Repeatable Read, 如MySQL InnoDB存储引擎 <br><br>即使是最低的级别,也不会出现 第一类 丢失 更新问题 .&nbsp; <br><br>1. <strong>脏读(事务没提交，提前读取)</strong> ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。 <br><br>2. <strong>不可重复读(两次读的不一致)</strong> ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。 <br>3.<strong> 幻读 </strong>: 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。 <br>4.<strong> 第一类更新丢失(回滚丢失)</strong> ： <br>&nbsp; 当2个事务更新相同的数据源，如果第一个事务被提交，而另外一个事务却被撤销，那么会连同第一个事务所做的跟新也被撤销。也就是说第一个事务做的跟新丢失了。 <br>5.<strong> 第二类更新丢失(覆盖丢失)</strong> ： <br>&nbsp; 第二类更新丢失实在实际应用中经常遇到的并发问题，他和不可重复读本质上是同一类并发问题，通常他被看做不可重复读的特例：当2个或这个多个事务查询同样的记录然后各自基于最初的查询结果更新该行时，会造成第二类丢失更新。因为每个事务都不知道不知道其他事务的存在，最后一个事务对记录做的修改将覆盖其他事务对该记录做的已提交的跟新… <br>补充 : 基于元数据的 Spring 声明性事务 : <br><br>Isolation 属性一共支持五种事务设置，具体介绍如下： <br><br>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFAULT 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 . <br><br>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ_UNCOMMITTED 会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 ) <br><br>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ_COMMITTED&nbsp; 会出现不可重复读、幻读问题（锁定正在读取的行） <br><br>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPEATABLE_READ 会出幻读（锁定所读取的所有行） <br><br>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERIALIZABLE 保证所有的情况不会发生（锁表） <br><br>不可重复读的重点是修改 : <br>同样的条件 ,&nbsp;&nbsp; 你读取过的数据 ,&nbsp;&nbsp; 再次读取出来发现值不一样了 <br>幻读的重点在于新增或者删除 <br>同样的条件 ,&nbsp;&nbsp; 第 1 次和第 2 次读出来的记录数不一样 <br></span></p><br></td><br></tr><br></tbody><br></table><br></p><br></div><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/07/26/truncation-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/truncation-02/" itemprop="url">分布式事务？No, 最终一致性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-26T17:54:01+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h1>分布式一致性</h1><h1>一、写在前面</h1><p>现今互联网界，分布式系统和微服务架构盛行。</p><p>一个简单操作，在服务端非常可能是由多个服务和数据库实例协同完成的。</p><p>在互联网金融等一致性要求较高的场景下，多个独立操作之间的一致性问题显得格外棘手。</p><p>基于水平扩容能力和成本考虑，传统的强一致的解决方案（e.g.单机事务）纷纷被抛弃。其理论依据就是响当当的<a href="\"http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/CAP_theorem\"" class="\"" wrap="" external\"="" target="\"_blank\"" rel="\"nofollow" noreferrer\"="">CAP原理<i class="\"icon-external\""></i></a>。</p><p>我们往往为了可用性和分区容错性，忍痛放弃强一致支持，转而追求最终一致性。大部分业务场景下，我们是可以接受短暂的不一致的。</p><p>本文主要讨论一些最终一致性相关的实现思路。</p><noscript><img src="\"https://pic3.zhimg.com/v2-135c492dbc2225ca86af34b837e446fa_b.png\"" data-rawwidth="\"760\"" data-rawheight="\"713\"" class="\"origin_image" zh-lightbox-thumb\"="" width="\"760\"" data-original="\"https://pic3.zhimg.com/v2-135c492dbc2225ca86af34b837e446fa_r.png\""></noscript><img src="\"//zhstatic.zhihu.com/assets/zhihu/ztext/whitedot.jpg\"" data-rawwidth="\"760\"" data-rawheight="\"713\"" class="\"origin_image" zh-lightbox-thumb="" lazy\"="" width="\"760\"" data-original="\"https://pic3.zhimg.com/v2-135c492dbc2225ca86af34b837e446fa_r.png\"" data-actualsrc="\"https://pic3.zhimg.com/v2-135c492dbc2225ca86af34b837e446fa_b.png\""><br><br><h1>二、最终一致性解决方案</h1><p>这个时候一般都会去举一个例子：A给B转100元。</p><p>当然，A跟B很不幸的被分在了不同的数据库实例上。甚者这两个人可能是在不同机构开的户。</p><p>下面讨论基本都是围绕这个场景的。更复杂的场景需要各位客官发挥下超人的想象力和扩展能力了。</p><p>谈到最终一致性，人们首先想到的应该是2PC解决方案。</p><h2>1. 两阶段提交</h2><p>两阶段提交需要有一个协调者，来协调两个操作之间的操作流程。当参与方为更多时，其逻辑其实就比较复杂了。</p><p>而参与者需要实现两阶段提交协议。Pre commit阶段需要锁住相关资源，commit或rollback时分别进行实际提交或释放资源。</p><p>看似还不错。但是考虑到各种异常情况那就比较痛苦了。</p><p>举个例子：如下图，执行到提交阶段，调用A的commit接口超时了，协调者该如何做？</p><p>我们一般会假设预提交成功后，提交或回滚肯定是成功的（由参与者保障）。</p><p>上述情况协调者只能选择继续重试。这也就要求下游接口必须实现幂等（关于幂等的实现下面我们单独再讨论下）。</p><p>一般，下游出现故障，不是短时重试能解决的。所以，我们一般也需要有定时去处理中间状态的逻辑。</p><p>这个地方，其实如果有个支持重试的MQ，可以扔到MQ。在实践中，我们曾经也尝试自己实现了一个基于MySQL的重试队列。下面还会聊到这一点。</p><p>另外，我们也利用了一些外部重试机制。比如支付场景，微信和支付宝都有非常可靠的通知机制。</p><p>我们在通知处理接口中做一些重试策略。如果重试失败，就返回微信或支付宝失败。</p><p>这样第三方还会接着回调我们(怀疑他们可能发现了我厂回调成功率比其他商户要低^_^)，不过作为小厂，利用一些大厂成熟的机制还是可取的。</p><noscript><img src="\"https://pic3.zhimg.com/v2-adeed5162805d0de2b9c08dc5f1f943e_b.png\"" data-rawwidth="\"1107\"" data-rawheight="\"636\"" class="\"origin_image" zh-lightbox-thumb\"="" width="\"1107\"" data-original="\"https://pic3.zhimg.com/v2-adeed5162805d0de2b9c08dc5f1f943e_r.png\""></noscript><img src="\"//zhstatic.zhihu.com/assets/zhihu/ztext/whitedot.jpg\"" data-rawwidth="\"1107\"" data-rawheight="\"636\"" class="\"origin_image" zh-lightbox-thumb="" lazy\"="" width="\"1107\"" data-original="\"https://pic3.zhimg.com/v2-adeed5162805d0de2b9c08dc5f1f943e_r.png\"" data-actualsrc="\"https://pic3.zhimg.com/v2-adeed5162805d0de2b9c08dc5f1f943e_b.png\""><br><h2>2.\n异步确保（没有事务消息）</h2><p>“异步确保”这个词不一定是准确的，还没找到更合适的词，抱歉。</p><p>异步化不只是为了一致性，有时候更多的考虑响应时间，下游稳定性等因素。本节只讨论通过异步方案，如何实现最终一致性。</p><p>该方案关键是要有个消息表。另外，一般会有个队列，而且我们一般都会假设这个MQ不丢消息。不过很不幸此MQ还不支持事务消息。</p><p>基本思路就是：</p><ol><li>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交。实现时为了简单，可以只是增加一个字段。新增字段会跟业务强耦合，新增表处理起来不同交易数据可以通用处理。不过因为消息表跟业务需要在一个事务里，所以存储耦合在所难免。</li><li>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，那发送给生产方一个confirm消息，表明已经处理成功了。如果处理失败，该消息还是需要放回MQ的。如果MQ支持重试，那就省事儿了。如果不支持，可以考虑把该消息放回队尾或另建一个队列特殊处理。当然非要处理成功才能继续，那只能block在这条消息了（估计一般人不会这么做）。Kafka lowlevel接口是支持自己设置offset的，所以可以实现block。</li><li>生产方定时扫描本地消息表，把还没处理完成的消息由发送一遍。如果有靠谱的自动对账补账逻辑，其实这一步也可以省略。在实践中，丢消息或者下游处理失败这种场景还是非常少的。这里要看业务上能不能容忍不一致到一个对账补账周期。</li></ol><p>当然如果进一步简化，那么MQ也可以不要的。直接用一个脚本处理，一些低频场景，也没啥大问题。当然离线扫表这个事情，总让人不爽。业务量不大且也出初期相信很多人干活儿这事儿。</p><p>另外，对一致性要求不高的或者有其他兜底方案的场景（比如较为频繁的对账补账机制），我们就不需要关心消息的confirm等情况，只要扔给消息，就认为万事大吉，一般也是可取的。</p><noscript><img src="\"https://pic1.zhimg.com/v2-38771836390d7db544d0780c96d8d56c_b.png\"" data-rawwidth="\"1140\"" data-rawheight="\"527\"" class="\"origin_image" zh-lightbox-thumb\"="" width="\"1140\"" data-original="\"https://pic1.zhimg.com/v2-38771836390d7db544d0780c96d8d56c_r.png\""></noscript><img src="\"//zhstatic.zhihu.com/assets/zhihu/ztext/whitedot.jpg\"" data-rawwidth="\"1140\"" data-rawheight="\"527\"" class="\"origin_image" zh-lightbox-thumb="" lazy\"="" width="\"1140\"" data-original="\"https://pic1.zhimg.com/v2-38771836390d7db544d0780c96d8d56c_r.png\"" data-actualsrc="\"https://pic1.zhimg.com/v2-38771836390d7db544d0780c96d8d56c_b.png\""><p>上面我们除了处理业务逻辑，还做了很多繁琐的事情。把这些杂活儿都扔给一个中间件多好！这就是阿里等大厂做的事务消息中间件了（比如Notify，RockitMQ的事务消息，请看下节）。</p><h2>3.\n异步确保（事务消息）</h2><p>事务消息实际上是一个很理想的想法。</p><p>理想是：我们只要把消息扔到MQ，那么这个消息肯定会被消费成功。生产方不用担心消息发送失败，也不用担心消息会丢失。</p><p>回到现实，消费方，如果消息处理失败了，还有机会继续消费，直到成功为止（消费方逻辑bug导致消费失败情况不在本文讨论范围内）。</p><p>但遗憾的是市面上大部分MQ都不支持事务消息，其中包括看起来可以一统江湖的kafka。</p><p>RocketMQ号称支持，但是还没开源。阿里云据说免费提供，没玩过（羡慕下阿里等大厂内部猿类们）。不过从网上公开的资料看，用起来还是有些不爽的地方。这是后话了，毕竟解决了很多问题。</p><p>事务消息，关键一点是把上小节中繁琐的消息状态和重发等用中间件形式封装了。</p><p>我厂目前还没提供成熟的支持事务消息的MQ。下面以网传RMQ为例，说明事务消息大概是怎么玩的：</p><p>RMQ的事务消息相对于普通MQ，相当于提供了2PC的提交接口。</p><p>生产方需要先发送一个prepared消息给RMQ。如果操作1失败，返回失败。</p><p>然后执行本地事务，如果成功了需要发送Confirm消息给RMQ。2失败，则调用RMQ cancel接口。 </p><p>那问题是3失败了（或者超时）该如何处理呢？</p><p>别急，RMQ考虑到这个问题了。 RMQ会要求你实现一个check的接口。生产方需要实现该接口，并告知RMQ自己本地事务是否执行成功（第4步）。RMQ会定时轮训所有处于pre状态的消息，并调用对应的check接口，以决定此消息是否可以提交。</p><p>当然第5步也可能会失败。这时候需要RMQ支持消息重试。处理失败的消息果断时间再进行重试，直到成功为止（超过重试次数后会进死信队列，可能得人肉处理了，因为没用过所以细节不是很了解）。</p><p>支持消息重试，这一点也很重要。消息重试机制也不仅仅在这里能用到，还有其他一些特殊的场景，我们会依赖他。下一小节，我们简单探讨一下这个问题。</p><p>RMQ还是很强大的。我们认为这个程度的一致性已经能够满足绝大部分互联网应用场景。代价是生产方做了不少额外的事情，但相比没有事务消息情况，确实解放了不少劳动力。 </p><noscript><img src="\"https://pic2.zhimg.com/v2-cffaa4dd5e45a4d1fa5a528cfaf20991_b.png\"" data-rawwidth="\"556\"" data-rawheight="\"325\"" class="\"origin_image" zh-lightbox-thumb\"="" width="\"556\"" data-original="\"https://pic2.zhimg.com/v2-cffaa4dd5e45a4d1fa5a528cfaf20991_r.png\""></noscript><img src="\"//zhstatic.zhihu.com/assets/zhihu/ztext/whitedot.jpg\"" data-rawwidth="\"556\"" data-rawheight="\"325\"" class="\"origin_image" zh-lightbox-thumb="" lazy\"="" width="\"556\"" data-original="\"https://pic2.zhimg.com/v2-cffaa4dd5e45a4d1fa5a528cfaf20991_r.png\"" data-actualsrc="\"https://pic2.zhimg.com/v2-cffaa4dd5e45a4d1fa5a528cfaf20991_b.png\""><p>P.S. 据说阿里内部因为历史原因，用notify比RMQ要多，他们俩基本原理类似。</p><h2>4. 补偿交易（Compensating\nTransaction）</h2><p>补偿交易，其核心思想是:针对每个操作，都要注册一个与其对应的补偿操作。一般来说操作本身和其补偿（撤销）操作会在一个事务里完成。</p><p>当其后续操作失败后，需要按相反顺序完成前面注册的所有撤销操作。</p><p>跟2PC比，他的核心价值应该是少了锁资源的代价。流程也相对简单一点。但实际操作中，补偿操作不太好定义，其中间状态处理也会比较棘手。</p><p>比如A:-100(补偿为A:+100),\nB:+100。那么如果B:+100失败后就需要执行A:+100。</p><p>曾经有位大牛同事(也是我灰常崇拜的一位技术控)一直热衷于这个思路，相信有些场景用补偿交易模式也是个不错的选择。</p><p>他更多是不断思考如何让补偿看起来跟注册个单库事务一样简单。做到业务无感知。</p><p>因为本人没有相关实战经验，所以留个<a href="\"http://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction\"" class="\"" wrap="" external\"="" target="\"_blank\"" rel="\"nofollow" noreferrer\"="">链接在这里<i class="\"icon-external\""></i></a>，供大家扩展阅读。偷懒了，截个此文中的一张图。</p><noscript><img src="\"https://pic3.zhimg.com/v2-706ab3a10327ce6707b316fcb0e6df96_b.png\"" data-rawwidth="\"647\"" data-rawheight="\"380\"" class="\"origin_image" zh-lightbox-thumb\"="" width="\"647\"" data-original="\"https://pic3.zhimg.com/v2-706ab3a10327ce6707b316fcb0e6df96_r.png\""></noscript><img src="\"//zhstatic.zhihu.com/assets/zhihu/ztext/whitedot.jpg\"" data-rawwidth="\"647\"" data-rawheight="\"380\"" class="\"origin_image" zh-lightbox-thumb="" lazy\"="" width="\"647\"" data-original="\"https://pic3.zhimg.com/v2-706ab3a10327ce6707b316fcb0e6df96_r.png\"" data-actualsrc="\"https://pic3.zhimg.com/v2-706ab3a10327ce6707b316fcb0e6df96_b.png\""><br><h2>5.\n消息重试</h2><p>上面多次提到消息重试。如果说事务消息重点解决了生产者和MQ之间的一致性问题，那么重试机制对于确保消费者和MQ之间的一致性是至关重要的。</p><p>重试可以是pull模式，也可以是push模式。我厂目前已经提供push模式的消息重试，这个还是要赞一下的！</p><p>消息重试，重试顾名思义是要解决消息一次性传递过程中的失败场景。举个例子，支付宝回调商户，然后商户系统挂了，怎么办？答案是重试！</p><p>一般来说，消息如果消费失败，就会被放到重试队列。如果是延迟时间固定（比如每次延迟2s），那么只需要按失败的顺序进队列就好了，然后对队首的消息，只有当延迟时间到达才能被消费。</p><p>这里会有个水位的概念。如果按时间作为水位，那么期望执行时间大于当前时间的消息才是高于水位以上的。其他消息对consumer不可见。</p><p>如果要实现每个消息延迟时间不一样，之前想过一种基于队列的方案是，按秒的维度建多个队列。按执行时间入到不同的队列，一天86400个队列（一般丑陋）。然后cosumer按时间消费不同队列。</p><p>当然如果不依赖队列可以有更灵活的方案。</p><p>之前做支付时候，做了个基于DB的延时队列。每次消息进去时候，都会把下次执行时间设置一下。再对这个时间做个索引….</p><p>略土，but it works。毕竟失败的消息不该很多，所以DB容量也不用太在意。很多时候，能跑起来的，简单的架构会得到更多人喜爱。</p><p>我厂提供了一种基于redis的延时队列，可以支持消息重试。用到的主要数据结构是redis的zset，按消息处理时间排序。</p><p>当然实现起来也没说的那么简单。MQ遇到的持久化问题，内存数据丢失问题，重试次数控制，消息追溯等等都需要有一些额外的开发量。</p><p>综上，如果MQ能够提供消息重试特性，那就不要自己折腾了。这里还是有不少坑的。</p><h2>6.\n幂等（接口支持重入）</h2><p>即使没有MQ，重试也是无处不在的。所以幂等问题不是因为用到MQ后引入的，而是老问题。</p><p>幂等怎么做？</p><p>如果是单条insert操作，我们一般会依赖唯一键。如果一个事务里包含一个单条insert，那也可以依赖这条insert做幂等，当insert抛异常就回滚事务。</p><p>如果是update操作，那么状态机控制和版本控制异常重要。这里要多加小心。</p><p>再复杂点的，可以考虑引入一个log表。该log对操作id（消息id？）进行唯一键控制。然后整个操作用事务控制。当插入log失败时整个事务回滚就好了。</p><p>有人会说先查log表或者利用redis等缓存，加锁。我想说的是这个基本上都不work。除非在事务里进行查寻。所以建议，所幸让代码简单点，直接插入，依赖数据库唯一键冲突回滚掉就好了。</p><p>用唯一键挡重入是目前为止个人觉得最有安全感的方式。当然对数据库会有一些额外性能损耗。问题就变成了有多大的并发，其中又有多大是需要重试的？</p><p>我相信Fasion IO卡+分库分表之后，想达到数据库性能瓶颈还是有点难度的（主要是针对金融类场景）。</p><h1>三、后记</h1><p>本文略虚，当然目前最终一致性没有一个放之四海而皆准的成功实践。需要大家根据不同的业务特性和发展阶段，选则适当的方式来实现。</p><p>纠结最终一致性问题，其实万恶之源是因为RPC本身会失败，会有结果不确定的情况。</p><p>隐约感觉本人职业生涯大部分时间都会跟各种失败和timeout搏斗了。</p><p>本文重点讨论利用MQ实现最终一致性。主要原因有：</p><p>1. 目前市面上的MQ都相对非常强大，几乎都号称可以做到不丢数据。相信未来对事务消息应该也会更加普及。</p><p>2. 异步化几乎是不同处理能力（响应时间、吞吐量）和稳定性（99.99%的服务依赖99.9%的服务）的服务之间解耦的毕竟之路。</p><p>当然前面的讨论还很浅显。能力有限，希望能够不断完善此文，请各位看到的客观不吝赐教。</p><p>下一篇，希望能够跟大家share一下，最近在做的一个项目。其主要目的利用现有还未支持事务消息的MQ，在业务层实现类事务消息逻辑，并且尽量不让代码变成一坨。</p><br><p>本人在知乎处女文，会有人看到吗？</p><p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/07/20/dubbox-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/20/dubbox-01/" itemprop="url">转载:dubbox 2.8.4搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-20T10:27:33+08:00">
                2017-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="article_c"><br>        <div class="markdown_views"><p>关于dubbox的核心原理和细节会另开一篇文章来介绍，这篇文章主要是从配置和应用层面来介绍dubbox 2.8.4的使用。</p><br><br><br><br><h3 id="dubbox的服务监控和日志采集httpblogcsdnnetu011282930articledetails52786414"><strong>dubbox的服务监控和日志采集</strong>：<a href="http://blog.csdn.net/u011282930/article/details/52786414" target="_blank" rel="external">http://blog.csdn.net/u011282930/article/details/52786414</a></h3><br><br><h2 id="zookeeper的安装"><strong>zookeeper的安装</strong></h2><br><br><p>1、准备工作</p><br><br><p>-下载zookeeper <br><br>官方地址：<a href="http://apache.fayea.com/zookeeper/zookeeper-3.4.6/" target="_blank" rel="external">http://apache.fayea.com/zookeeper/zookeeper-3.4.6/</a> <br><br>下载版本：zookeeper-3.4.6.tar.gz</p><br><br><p>-下载JDK <br><br>下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html</a> <br><br>下载版本：JDK1.7.X版本，32位或64位看操作系统 <br><br>JDK的安装就跳过了，直接百度一大堆，一定记得设置PATH，classpath，JAVA_HOME环境变量</p><br><br><p>2、解压和安装zookeeper <br><br>zookeeper的目录我是放置在/usr/zookeeper-3.4.6/这个位置，所以： <br><br><code>tar -zxvf ./zookeeper-3.4.6.tar.gz</code> <br><br><code>mv ./zookeeper-3.4.6 /usr/zookeeper-3.4.6/</code></p><br><br><p>同样的，设置全局环境变量： <br><br><code>export PATH=/usr/zookeeper-3.4.6/bin:$PATH</code></p><br><br><p>好的，安装完成了，是不是简单。接下来，我们讲解一下zookeeper的主配置文件。zookeeper的主配置文件所在的地址是：${您的zookeeper安装位置}/conf/zoo.cfg <br><br>但是，解压后的zookeeper并没有这个配置文件，有一个名叫zoo_sample.cfg，所以，我们复制一个zoo.cfg文件： <br><br><code>cp /usr/zookeeper-3.4.6/conf/zoo_sample.cfg /usr/zookeeper-3.4.6/conf/zoo.cfg</code></p><br><br><p>最后，使用zkServer.sh start命令，启动zookeeper：</p><br><br><br><br><pre class="prettyprint"><code class=" hljs r">[root@vm2 ~]<span class="hljs-comment"># zkServer.sh start</span><br>JMX enabled by default<br>Using config: /usr/zookeeper-<span class="hljs-number">3.4</span><span class="hljs-number">.6</span>/bin/../conf/zoo.cfg<br>Starting zookeeper <span class="hljs-keyword">…</span> STARTED</code></pre><br><br><br><br><h1 id="dubbox"><strong>dubbox</strong></h1><br><br><p>1、准备工作 <br><br>下载dubbox的源代码 <br><br>下载地址：<a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">https://github.com/dangdangdotcom/dubbox</a></p><br><br><p>2、编译源码（此处默认大家会用maven了） <br><br>运行maven命令：mvn clean install -Dmaven.test.skip=true <br><br>将dubbox的源码打包发布到本地仓库，目的是为了获取：dubbo-admin-2.8.4.war和dubbo-monitor.war</p><br><br><br><br><h2 id="dubbox-admin管理端"><strong>dubbox-admin管理端</strong></h2><br><br><p>懒人下载：<a href="http://download.csdn.net/detail/u011282930/9477514" target="_blank" rel="external">http://download.csdn.net/detail/u011282930/9477514</a></p><br><br><p>1、部署dubbo-admin管理端，将dubbo-admin-2.8.4.war放置到准备好的tomcat目录 <br><br>2、修改WEB-INF下dubbo.properties <br><br>主要是修改zookeeper的地址 <br><br><code>dubbo.registry.address=zookeeper://127.0.0.1:2181</code> <br><br>3、运行tomcat <br><br>输入地址：<a href="http://localhost:8080/dubbo-admin-2.8.4" target="_blank" rel="external">http://localhost:8080/dubbo-admin-2.8.4</a> <br><br>默认登录账户和密码均为：root <br><br>4、登录后首页 <br><br><img src="http://img.blog.csdn.net/20160331083357772" alt="这里写图片描述" title=""> <br><br>到此为止，dubbox的后台管理端就配置成功了</p><br><br><br><br><h2 id="dubbox-monitor监控端"><strong>dubbox-monitor监控端</strong></h2><br><br><p>懒人下载：<a href="http://download.csdn.net/detail/u011282930/9477515" target="_blank" rel="external">http://download.csdn.net/detail/u011282930/9477515</a> <br><br>我们对于dubbo的监控用的是改装后的（页面非常好看）</p><br><br><p>下载dubbox-monitor的源代码 <br><br>下载地址：<a href="http://git.oschina.net/handu/dubbo-monitor" target="_blank" rel="external">http://git.oschina.net/handu/dubbo-monitor</a></p><br><br><p>Dubbo-Monitor配置介绍 <br><br>1、创建数据库 首先创建名称为monitor数据库，编码格式UTF-8。然后将项目sql文件夹下面的create.sql导入到数据库，生成dubbo_invoke表代表成功导入。 <br><br>下载地址：<a href="http://download.csdn.net/detail/u011282930/9650381" target="_blank" rel="external">http://download.csdn.net/detail/u011282930/9650381</a></p><br><br><p>2、编辑项目中application.properties，配置如下：</p><br><br><br><br><pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-preprocessor">####Dubbo Settings</span><br>dubbo<span class="hljs-preprocessor">.application</span><span class="hljs-preprocessor">.name</span>=dubbo-monitor<br>dubbo<span class="hljs-preprocessor">.application</span><span class="hljs-preprocessor">.owner</span>=handu<span class="hljs-preprocessor">.com</span><br>dubbo<span class="hljs-preprocessor">.registry</span><span class="hljs-preprocessor">.address</span>=zookeeper://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span><br>dubbo<span class="hljs-preprocessor">.protocol</span><span class="hljs-preprocessor">.port</span>=<span class="hljs-number">6060</span><br><br><span class="hljs-preprocessor">####Database Settings</span><br>db<span class="hljs-preprocessor">.url</span>=jdbc:mysql://&lt;database_host&gt;:&lt;database_port&gt;/monitor?prepStmtCacheSize=<span class="hljs-number">517</span>&amp;cachePrepStmts=true&amp;autoReconnect=true&amp;characterEncoding=utf-<span class="hljs-number">8</span><br>db<span class="hljs-preprocessor">.username</span>=root<br>db<span class="hljs-preprocessor">.password</span>=root<br>db<span class="hljs-preprocessor">.maxActive</span>=<span class="hljs-number">500</span><br><br><span class="hljs-preprocessor">####System Manager</span><br>manager<span class="hljs-preprocessor">.username</span>=admin<br>manager<span class="hljs-preprocessor">.password</span>=admin</code></pre><br><br><p>3、打包运行项目 执行maven命令：mvn clean package target文件夹下生成的dubbo-monitor.war即为项目部署文件，将其放置到对应服务器目录下，启动服务器即可。例如：tomcat的webapps文件夹下。</p><br><br><p>4、访问项目 启动web服务器后，访问地址：<a href="http://IP:[port]/dubbo-moniotor" target="_blank" rel="external">http://IP:[port]/dubbo-moniotor</a>，采用配置文件中manager.username和manager.password设置值进行登录。 <br><br><img src="http://img.blog.csdn.net/20160331084239712" alt="这里写图片描述" title=""> <br><br>5、透过dubbox服务管理端，我们会发现多了一个monitor的服务 <br><br><img src="http://img.blog.csdn.net/20160331084141868" alt="这里写图片描述" title=""></p><br><br><br><br><h4 id="下文默认大家已经用maven引入相关依赖或者导入相关包了"><strong>下文默认大家已经用maven引入相关依赖或者导入相关包了</strong></h4><br><br><p>具体依赖jar包如下图所示 <br><br><img src="http://img.blog.csdn.net/20160331172455088" alt="这里写图片描述" title=""> <br><br>maven依赖库</p><br><br><br><br><pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>2.8.4<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>dubbo-rpc-rest<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>2.8.4<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>dubbo-rpc-webservice<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>2.8.4<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>com.101tec<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>0.2<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>3.3.6<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-title">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-title">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-title">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.2.16<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span></code></pre><br><br><br><br><h2 id="服务提供者实例开发"><strong>服务提供者实例开发</strong></h2><br><br><p>1、定义一个Service接口和相关实现类 <br><br>定义一个接口，IUserService.java</p><br><br><br><br><pre class="prettyprint"><code class=" hljs cs">package service;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> IUserService {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span>();<br>}<br></code></pre><br><br><p>实现这个接口，UserService.java</p><br><br><br><br><pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> service;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserService</span> {</span><br><br>    <span class="hljs-annotation">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span>() {<br>        System.err.println(<span class="hljs-string">“HELLO WORLD!”</span>);<br>    }<br><br>}<br></code></pre><br><br><p>2、配置这个接口的xml文件，dubbo-provider.xml</p><br><br><br><br><pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version=”1.1” encoding=”UTF-8”?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-title">beans</span> <span class="hljs-attribute">xmlns</span>=<span class="hljs-value">“<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a>“</span><br>    <span class="hljs-attribute">xmlns:xsi</span>=<span class="hljs-value">“<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema-instance</a>“</span> <span class="hljs-attribute">xmlns:dubbo</span>=<span class="hljs-value">“<a href="http://code.alibabatech.com/schema/dubbo" target="_blank" rel="external">http://code.alibabatech.com/schema/dubbo</a>“</span><br>    <span class="hljs-attribute">xsi:schemaLocation</span>=<span class="hljs-value">“<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a><br>       <a href="http://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/spring-beans.xsd</a><br>       <a href="http://code.alibabatech.com/schema/dubbo" target="_blank" rel="external">http://code.alibabatech.com/schema/dubbo</a><br>       <a href="http://code.alibabatech.com/schema/dubbo/dubbo.xsd" target="_blank" rel="external">http://code.alibabatech.com/schema/dubbo/dubbo.xsd</a>“</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">dubbo:application</span> <span class="hljs-attribute">owner</span>=<span class="hljs-value">“whb”</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">“hello-world-app”</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!–zookeeper注册中心 –&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">dubbo:registry</span> <span class="hljs-attribute">address</span>=<span class="hljs-value">“zookeeper://172.17.84.84:2181”</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!–使用multicast广播注册中心暴露服务地址 –&gt;</span><br>    <span class="hljs-comment">&lt;!–&lt;dubbo:registry address=”multicast://10.57.41.19:1234” /&gt; –&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">dubbo:protocol</span> <span class="hljs-attribute">name</span> =<span class="hljs-value">“dubbo”</span> <span class="hljs-attribute">port</span>=<span class="hljs-value">“20880”</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!– 配置监控的服务地址和IP–&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">dubbo:monitor</span> <span class="hljs-attribute">address</span>=<span class="hljs-value">“127.0.0.1:7070”</span>  /&gt;</span><br>    <span class="hljs-comment">&lt;!– 发布这个服务 –&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">dubbo:service</span>  <span class="hljs-attribute">protocol</span>=<span class="hljs-value">“dubbo”</span>  <span class="hljs-attribute">timeout</span>=<span class="hljs-value">“2000”</span> <span class="hljs-attribute">connections</span>=<span class="hljs-value">“100”</span> <span class="hljs-attribute">interface</span> =<span class="hljs-value">“service.IUserService”</span> <span class="hljs-attribute">ref</span>=<span class="hljs-value">“userService”</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!– 和本地bean一样实现服务 –&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">“userService”</span><br>        <span class="hljs-attribute">class</span>=<span class="hljs-value">“service.UserService”</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-title">beans</span>&gt;</span>  </code></pre><br><br><p>3、运行发布我们的接口，LuncherProvider.java</p><br><br><br><br><pre class="prettyprint"><code class=" hljs cs">package demo;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> LuncherProvider {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws InterruptedException {<br>        LuncherProvider luncher = <span class="hljs-keyword">new</span> LuncherProvider();<br>        luncher.start();<br>        Thread.sleep(<span class="hljs-number">1000</span> <em> <span class="hljs-number">60</span> </em> <span class="hljs-number">10</span>);<br>    }<br><br>    <span class="hljs-keyword">void</span> start() {<br>        String configLocation = <span class="hljs-string">“classpath<em>:/dubbo-provider.xml”</em></span>;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<br>                configLocation);<br>        String[] names = context.getBeanDefinitionNames();<br>        System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">“Beans:”</span>);<br>        <span class="hljs-keyword">for</span> (String <span class="hljs-keyword">string</span> : names)<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-keyword">string</span> + <span class="hljs-string">“,”</span>);<br>        System.<span class="hljs-keyword">out</span>.println();<br>    }<br>}</code></pre><br><br><p>控制台输出如下内容，为成功 <br><br><img src="http://img.blog.csdn.net/20160331090743347" alt="这里写图片描述" title=""> <br><br>通过dubbox管理端来查看我们的服务，通过下图，我们可以看到我们的服务已经注册到zookeeper了 <br><br><img src="http://img.blog.csdn.net/20160331085207982" alt="这里写图片描述" title=""></p><br><br><br><br><h2 id="消费者实例开发"><strong>消费者实例开发</strong></h2><br><br><p>如何调用我们发布的服务呢？ <br><br>1、定义一个一模一样的接口，IUserService.java</p><br><br><br><br><pre class="prettyprint"><code class=" hljs cs">package service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> IUserService {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span>();<br>}<br></code></pre><br><br><p>2、配置这个接口调用信息，</p><br><br><br><br><pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version=”1.1” encoding=”UTF-8”?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-title">beans</span> <span class="hljs-attribute">xmlns</span>=<span class="hljs-value">“<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a>“</span><br>    <span class="hljs-attribute">xmlns:xsi</span>=<span class="hljs-value">“<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema-instance</a>“</span> <span class="hljs-attribute">xmlns:dubbo</span>=<span class="hljs-value">“<a href="http://code.alibabatech.com/schema/dubbo" target="_blank" rel="external">http://code.alibabatech.com/schema/dubbo</a>“</span><br>    <span class="hljs-attribute">xsi:schemaLocation</span>=<span class="hljs-value">“<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a><br>       <a href="http://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/spring-beans.xsd</a><br>       <a href="http://code.alibabatech.com/schema/dubbo" target="_blank" rel="external">http://code.alibabatech.com/schema/dubbo</a><br>       <a href="http://code.alibabatech.com/schema/dubbo/dubbo.xsd" target="_blank" rel="external">http://code.alibabatech.com/schema/dubbo/dubbo.xsd</a>“</span>&gt;</span><br>         <span class="hljs-comment">&lt;!–消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 –&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-title">dubbo:application</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">“consumer-of-helloworld-app”</span> /&gt;</span><br>         <span class="hljs-comment">&lt;!–zookeeper注册中心 –&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-title">dubbo:registry</span>  <span class="hljs-attribute">protocol</span>=<span class="hljs-value">“zookeeper”</span> <span class="hljs-attribute">address</span>=<span class="hljs-value">“172.17.84.84:2181”</span> /&gt;</span><br>         <span class="hljs-comment">&lt;!–使用multicast广播注册中心暴露的服务地址 –&gt;</span><br>         <span class="hljs-comment">&lt;!–&lt;dubbo:registryaddress=”multicast://10.57.41.19:1234” /&gt; –&gt;</span><br>          <span class="hljs-comment">&lt;!–         &lt;dubbo:monitor address=”127.0.0.1:7070”  /&gt; –&gt;</span><br>          <span class="hljs-comment">&lt;!– 生成远程服务代理，可以和本地bean一样使用IUserService–&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-title">dubbo:reference</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">“userService”</span> <span class="hljs-attribute">interface</span>=<span class="hljs-value">“service.IUserService”</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-title">beans</span>&gt;</span>  </code></pre><br><br><p>3、测试调用服务的代码，LuncherConsumer.java</p><br><br><br><br><pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> demo;<br><br><br><br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">import</span> service.IUserService;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuncherConsumer</span>  {</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> InterruptedException{<br>                   LuncherConsumer luncher=<span class="hljs-keyword">new</span> LuncherConsumer();<br>                   String configLocation=<span class="hljs-string">“classpath:/dubbo-consumer.xml”</span>;<br>                   ApplicationContext context =<span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(configLocation);<br>                   IUserService us=(IUserService) context.getBean(<span class="hljs-string">“userService”</span>);<br>                   String[] names=context.getBeanDefinitionNames();<br>                   us.sayHello();<br>         }<br>}  </code></pre><br><br><p>观察服务端的控制台，会输出“HELLO WORLD” <br><br><img src="http://img.blog.csdn.net/20160331090854144" alt="这里写图片描述" title=""></p><br><br><p>至此，dubbox的配置和使用就成功了！</p></div>

</div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/07/17/thread-pool-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/17/thread-pool-01/" itemprop="url">转载:线程池原理及实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-17T15:06:49+08:00">
                2017-07-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br><br><p><span style="font-size:16px"><span style="color:#ff0000"><strong>1、线程池简介：</strong></span><br><br>&nbsp;&nbsp;&nbsp; 多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; 假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。<br><br><br><br>&nbsp;&nbsp;&nbsp; 如果：T1 &#43; T3 远大于 T2，则可以采用线程池，以提高服务器性能。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个线程池包括以下四个基本组成部分：<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; 线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。<br><br>&nbsp;&nbsp;&nbsp; 线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子：<br><br>&nbsp;&nbsp;&nbsp; 假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。<br><br></span></p><br><p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 代码实现中并没有实现任务接口，而是把Runnable对象加入到线程池管理器（ThreadPool），然后剩下的事情就由线程池管理器（ThreadPool）来完成了</span></p><br><p><span style="font-size:16px"></span>&nbsp;</p><br><span style="font-size:16px"></span><br><div class="dp-highlighter bg_java"><br><div class="bar"><br><div class="tools"><strong>[java]</strong> <a href="http://blog.csdn.net/touch_2011/article/details/6914468#" class="ViewSource" title="view plain" target="_blank" rel="external"><br>view plain</a><a href="http://blog.csdn.net/touch_2011/article/details/6914468#" class="CopyToClipboard" title="copy" target="_blank" rel="external">copy</a></div><br></div><br><ol class="dp-j" start="1"><br><li class="alt"><span><span class="keyword">package</span><span>&nbsp;mine.util.thread;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">import</span><span>&nbsp;java.util.LinkedList;&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">import</span><span>&nbsp;java.util.List;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span><span class="comment">/<strong></strong></span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;<em>&nbsp;线程池类，线程管理器：创建线程，执行任务，销毁线程，获取线程基本信息</em></span>&nbsp;</span></li><li><span><span class="comment">&nbsp;/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ThreadPool&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;线程池中默认线程的个数为5</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;worker_num&nbsp;=&nbsp;</span><span class="number">5</span><span>;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;工作线程</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;WorkThread[]&nbsp;workThrads;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;未处理的任务</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">volatile</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;finished_task&nbsp;=&nbsp;</span><span class="number">0</span><span>;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;任务队列，作为一个缓冲,List线程不安全</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;List&lt;Runnable&gt;&nbsp;taskQueue&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;LinkedList&lt;Runnable&gt;();&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;ThreadPool&nbsp;threadPool;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;创建具有默认线程个数的线程池</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;ThreadPool()&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span><span>(</span><span class="number">5</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;创建线程池,worker_num为线程池中工作线程的个数</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;ThreadPool(</span><span class="keyword">int</span><span>&nbsp;worker_num)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadPool.worker_num&nbsp;=&nbsp;worker_num;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workThrads&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;WorkThread[worker_num];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="keyword">int</span><span>&nbsp;i&nbsp;=&nbsp;</span><span class="number">0</span><span>;&nbsp;i&nbsp;&lt;&nbsp;worker_num;&nbsp;i&#43;&#43;)&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workThrads[i]&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;WorkThread();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workThrads[i].start();<span class="comment">//&nbsp;开启线程池中的线程</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;单态模式，获得一个默认线程个数的线程池</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;ThreadPool&nbsp;getThreadPool()&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;getThreadPool(ThreadPool.worker_num);&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;单态模式，获得一个指定线程个数的线程池,worker_num(&gt;0)为线程池中工作线程的个数</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;worker_num&lt;=0创建默认的工作线程个数</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;ThreadPool&nbsp;getThreadPool(</span><span class="keyword">int</span><span>&nbsp;worker_num1)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(worker_num1&nbsp;&lt;=&nbsp;</span><span class="number">0</span><span>)&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker_num1&nbsp;=&nbsp;ThreadPool.worker_num;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(threadPool&nbsp;==&nbsp;</span><span class="keyword">null</span><span>)&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threadPool&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;ThreadPool(worker_num1);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;threadPool;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;execute(Runnable&nbsp;task)&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(taskQueue)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taskQueue.add(task);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taskQueue.notify();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;execute(Runnable[]&nbsp;task)&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(taskQueue)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(Runnable&nbsp;t&nbsp;:&nbsp;task)&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taskQueue.add(t);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taskQueue.notify();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;execute(List&lt;Runnable&gt;&nbsp;task)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(taskQueue)&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(Runnable&nbsp;t&nbsp;:&nbsp;task)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taskQueue.add(t);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taskQueue.notify();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;destroy()&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(!taskQueue.isEmpty())&nbsp;{</span><span class="comment">//&nbsp;如果还有任务没执行完成，就先睡会吧</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(<span class="number">10</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(InterruptedException&nbsp;e)&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;工作线程停止工作，且置为null</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="keyword">int</span><span>&nbsp;i&nbsp;=&nbsp;</span><span class="number">0</span><span>;&nbsp;i&nbsp;&lt;&nbsp;worker_num;&nbsp;i&#43;&#43;)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workThrads[i].stopWorker();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workThrads[i]&nbsp;=&nbsp;<span class="keyword">null</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threadPool=<span class="keyword">null</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taskQueue.clear();<span class="comment">//&nbsp;清空任务队列</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回工作线程的个数</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;getWorkThreadNumber()&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;worker_num;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回已完成任务的个数,这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;getFinishedTasknumber()&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;finished_task;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;返回任务队列的长度，即还没处理的任务个数</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;getWaitTasknumber()&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;taskQueue.size();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;覆盖toString方法，返回线程池信息：工作线程个数和已完成任务个数</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation">@Override</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;String&nbsp;toString()&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="string">&quot;WorkThread&nbsp;number:&quot;</span><span>&nbsp;&#43;&nbsp;worker_num&nbsp;&#43;&nbsp;</span><span class="string">&quot;&nbsp;&nbsp;finished&nbsp;task&nbsp;number:&quot;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#43;&nbsp;finished_task&nbsp;&#43;&nbsp;<span class="string">&quot;&nbsp;&nbsp;wait&nbsp;task&nbsp;number:&quot;</span><span>&nbsp;&#43;&nbsp;getWaitTasknumber();&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;内部类，工作线程</em></span>&nbsp;</span></li><li><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WorkThread&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Thread&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;该工作线程是否有效，用于结束该工作线程</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;isRunning&nbsp;=&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/<em></em></span>&nbsp;</span></li><li><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关键所在啊，如果任务队列不空，则取出任务执行，若任务队列空，则等待</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation">@Override</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;run()&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;r&nbsp;=&nbsp;<span class="keyword">null</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(isRunning)&nbsp;{</span><span class="comment">//&nbsp;注意，若线程无效则自然结束run方法，该线程就没用了</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(taskQueue)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(isRunning&nbsp;&amp;&amp;&nbsp;taskQueue.isEmpty())&nbsp;{</span><span class="comment">//&nbsp;队列为空</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taskQueue.wait(<span class="number">20</span><span>);&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(InterruptedException&nbsp;e)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!taskQueue.isEmpty())&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;taskQueue.remove(<span class="number">0</span><span>);</span><span class="comment">//&nbsp;取出任务</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(r&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.run();<span class="comment">//&nbsp;执行任务</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finished_task&#43;&#43;;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;<span class="keyword">null</span><span>;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;停止工作，让该线程自然执行完run方法，自然结束</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;stopWorker()&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isRunning&nbsp;=&nbsp;<span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol><br></div><br><p>&nbsp;</p><br><p>测试代码：</p><br><div class="dp-highlighter bg_java"><br><div class="bar"><br><div class="tools"><strong>[java]</strong> <a href="http://blog.csdn.net/touch_2011/article/details/6914468#" class="ViewSource" title="view plain" target="_blank" rel="external"><br>view plain</a><a href="http://blog.csdn.net/touch_2011/article/details/6914468#" class="CopyToClipboard" title="copy" target="_blank" rel="external">copy</a></div><br></div><br><ol class="dp-j" start="1"><br><li class="alt"><span><span class="keyword">package</span><span>&nbsp;mine.util.thread;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="comment">//测试线程池</span><span>&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;TestThreadPool&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;创建3个线程的线程池</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadPool&nbsp;t&nbsp;=&nbsp;ThreadPool.getThreadPool(<span class="number">3</span><span>);&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.execute(<span class="keyword">new</span><span>&nbsp;Runnable[]&nbsp;{&nbsp;</span><span class="keyword">new</span><span>&nbsp;Task(),&nbsp;</span><span class="keyword">new</span><span>&nbsp;Task(),&nbsp;</span><span class="keyword">new</span><span>&nbsp;Task()&nbsp;});&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.execute(<span class="keyword">new</span><span>&nbsp;Runnable[]&nbsp;{&nbsp;</span><span class="keyword">new</span><span>&nbsp;Task(),&nbsp;</span><span class="keyword">new</span><span>&nbsp;Task(),&nbsp;</span><span class="keyword">new</span><span>&nbsp;Task()&nbsp;});&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(t);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.destroy();<span class="comment">//&nbsp;所有线程都执行完成才destory</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(t);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;任务类</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">static</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Task&nbsp;</span><span class="keyword">implements</span><span>&nbsp;Runnable&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">volatile</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;i&nbsp;=&nbsp;</span><span class="number">1</span><span>;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation">@Override</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;run()&nbsp;{</span><span class="comment">//&nbsp;执行任务</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">&quot;任务&nbsp;&quot;</span><span>&nbsp;&#43;&nbsp;(i&#43;&#43;)&nbsp;&#43;&nbsp;</span><span class="string">&quot;&nbsp;完成&quot;</span><span>);&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol><br></div><br><p><br><br>&nbsp;</p><br><p><span style="font-size:16px">运行结果：</span></p><br><p><span style="font-size:16px">WorkThread number:3&nbsp; finished task number:0&nbsp; wait task number:6<br><br>任务 1 完成<br><br>任务 2 完成<br><br>任务 3 完成<br><br>任务 4 完成<br><br>任务 5 完成<br><br>任务 6 完成<br><br>WorkThread number:3&nbsp; finished task number:6&nbsp; wait task number:0<br><br></span></p><br><p><span style="font-size:16px">分析：由于并没有任务接口，传入的可以是自定义的任何任务，所以线程池并不能准确的判断该任务是否真正的已经完成（真正完成该任务是这个任务的run方法执行完毕），只能知道该任务已经出了任务队列，正在执行或者已经完成。</span></p><br><p><span style="font-size:16px"></span></p><br><p><span style="color:#ff0000; font-size:16px"><strong>2、java类库中提供的线程池简介：</strong></span></p><br><p><span style="color:#000000"><span style="font-size:16px"><strong>&nbsp;&nbsp;&nbsp;&nbsp; java提供的线程池更加强大，相信理解线程池的工作原理，看类库中的线程池就不会感到陌生了。</strong><br><br></span></span></p><br><p><span style="font-size:16px"><img alt="" src="http://hi.csdn.net/attachment/201110/28/0_1319784225fRSR.gif"></span></p><br><p><span style="font-size:16px"><img alt="" src="http://hi.csdn.net/attachment/201110/28/0_1319784243mu5f.gif"></span></p><br><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/07/04/redBlackTree-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/04/redBlackTree-01/" itemprop="url">转载:简单清晰的红黑树讲解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-04T10:49:40+08:00">
                2017-07-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br><br><h1 style="text-align:center"><span style="font-family:Microsoft YaHei; font-size:48px; font-weight:normal">查找（一）</span></h1><br><p><span style="font-size:18px"><br><br></span></p><br><p><span style="font-size:18px"><br><br></span></p><br><p><span style="font-size:18px">我们使用<strong>符号表</strong>这个词来描述一张抽象的表&#26684;，我们会将信息（<u>&#20540;</u>）存储在其中，然后按照指定的<u>键</u>来搜索并获取这些信息。键和&#20540;的具体意义取决于不同的应用。</span></p><br><p><span style="font-size:18px">符号表中可能会保存很多键和很多信息，因此实现一张高效的符号表也是一项很有挑战性的任务。</span></p><br><p><span style="font-size:18px">我们会用三种经典的数据类型来实现高效的符号表：<strong>二叉查找数</strong>、<strong>红黑树</strong>、<strong>散列表</strong>。</span></p><br><p><span style="font-size:18px"><br><br></span></p><br><p></p><br><h1><span style="font-family:Microsoft YaHei; font-size:32px">二分查找</span></h1><br><p></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">我们使用有序数组存储键，经典的二分查找能够根据数组的索引大大减少每次查找所需的比较次数。</p><br><p style="font-size:18px">在查找时，我们先将被查找的键和子数组的中间键比较。如果被查找的键小于中间键，我们就在左子数组中继续查找，如果大于我们就在右子数组中继续查找，否则中间键就是我们要找的键。</p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px">一般情况下二分查找都比顺序查找快的多，它也是众多实际应用程序的最佳选择。对于一个静态表（不允许插入）来说，将其在初始化时就排序是&#20540;得的。</p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px">当然，二分查找也不适合很多应用。现代应用需要<u>同时</u>能够支持高效的查找和插入两种操作的符号表实现。也就是说，<u>我们需要在构造庞大的符号表的同时能够任意插入（也许还有删除）键&#20540;对，同时也要能够完成查找操作</u>。</p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px">要支持高效的插入操作，我们&#20284;乎需要一种链式结构。当单链接的链表是无法使用二分查找的，因为二分查找的高效来自于能够快速通过索引取得任何子数组的中间元素。为了将二分查找的效率和链表的灵活性结合起来，我们需要更加复杂的数据结构。</p><br><p style="font-size:18px">能够同时拥有两者的就是<strong>二叉查找树</strong>。</p><br><p style="font-size:18px">&nbsp;</p><br><h1><span style="font-family:Microsoft YaHei; font-size:32px">二叉查找树</span></h1><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">一颗二叉查找树（<strong>BST</strong>）是一颗二叉树，其中每个节点都含有一个可比较的键（以及相关联的&#20540;）且<u>每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键</u>。</p><br><p style="font-size:18px">&nbsp;<img src="http://img.blog.csdn.net/20140517140928015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><br><p style="font-size:18px"></p><br><p>一颗二叉查找树代表了一组键（及其相应的&#20540;）的集合，而同一个集合可以用多颗不同的二叉查找树表示。</p><br><p>如果我们将一颗二叉查找树的所有键<strong><u>投影</u></strong>到一条直线上，保证一个结点的左子树中的键出现在它的右边，右子树中的键出现在它的右边，那么我们一定可以得到一条有序的键列。</p><br><p>&nbsp;</p><br><img src="http://img.blog.csdn.net/20140517141025312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br><p style="font-size:18px"><br><br></p><br><p></p><br><p><strong><span style="font-size:24px">查找</span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">在二叉查找树中查找一个键的递归算法：</p><br><p style="font-size:18px">如果树是空的，则查找未命中。如果被查找的键和根结点的键相等，查找命中。否则我们就在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大就选择右子树。</p><br><p style="font-size:18px">在二叉查找树中，<u>随着我们不断向下查找，当前结点所表示的子树的大小也在减小</u>（理想情况下是减半）</p><br><p style="font-size:18px">&nbsp;</p><br><p><strong><span style="font-size:24px">插入</span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">查找代码几乎和二分查找的一样简单，这种<strong><span style="color:red">简洁性</span></strong>是二叉查找树的重要特性之一。而二叉查找树的另一个更重要的特性就是<u>插入的实现难度和查找差不多</u>。</p><br><p style="font-size:18px">当查找一个不存在于树中的结点并结束于一条空链接时，我们需要做的就是将链接指向一个含有被查找的键的新结点。如果被查找的键小于根结点的键，我们会继续在左子树中插入该键，否则在右子树中插入该键。</p><br><p style="font-size:18px">&nbsp;</p><br><p><strong><span style="font-size:24px">分析</span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">使用二叉查找树的算法的运行时间取决于<u>树的形状</u>，而树的形状又取决于键被插入的先后顺序。</p><br><p style="font-size:18px">在最好的情况下，一颗含有N个结点的树是完全平衡的，每条空链接和根结点的距离都为~lgN。在最坏的情况下，搜索路径上可能有N个结点。但在一般情况下树的形状和最好情况更接近。</p><br><span style="font-size:18px"><img src="http://img.blog.csdn.net/20140517141307031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px"></p><br><p>我们假设键的插入顺序是随机的。对这个模型的分析而言，<u>二叉查找树和快速排序几乎就是“双胞胎”</u>。树的根结点就是快速排序中的第一个切分元素（左侧的键都比它小，右侧的键都比它大），而这对于所有的子树同样适用，这和快速排序中对于子数组的递归排序完全对应。</p><br><p>【在由N个随机键构造的二叉查找树中，查找命中平均所需的比较次数为~2lgN。 N越大这个公式越准确】</p><br><p>&nbsp;</p><br><h1>平衡查找树</h1><br><p><br><br></p><br><p>在一颗含有N个结点的树中，我们希望树高为~lgN，这样我们就能保证所有查找都能在~lgN此比较内结束，就和二分查找一样。不幸的是，在动态插入中保证树的完美平衡的代价太高了。我们放松对完美平衡的要求，使符号表API中所有操作均能够在对数时间内完成。</p><br><p>&nbsp;</p><br><h2><span style="color:red">2-3</span><span style="color:red">查找树</span></h2><br><p><br><br></p><br><p>为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。</p><br><p><strong>2-结点</strong>：含有一个键(及&#20540;)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。</p><br><p><strong>3-结点</strong>：含有两个键(及&#20540;)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p><br><p>（2-3指的是2叉-3叉的意思）</p><br><img src="http://img.blog.csdn.net/20140517141525468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br><span style="font-size:18px"><img src="http://img.blog.csdn.net/20140517141558937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br><br><p><span style="font-size:18px"><br><br></span></p><br><p></p><br><p style="font-size:18px">一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都是相同的。</p><br><p style="font-size:18px">&nbsp;</p><br><p><strong><span style="font-size:24px">查找</span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中的任何一个相等，查找命中。否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。</p><br><p style="font-size:18px">&nbsp;</p><br><p><strong><span style="color:red"><span style="font-size:24px">插入</span></span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。我们使用2-3树的主要原因就在于它能够在插入之后继续保持平衡。</p><br><p style="font-size:18px">如果未命中的查找结束于一个2-结点，我们只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。<u>如果未命中的查找结束于一个3-结点</u>，事情就要麻烦一些。</p><br><p style="font-size:18px">&nbsp;</p><br><p><span style="font-size:24px"><strong>热身</strong>：</span></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">先考虑最简单的例子：只有一个3-结点的树，向其插入一个新键。</p><br><p style="font-size:18px">这棵树唯一的结点中已经没有可插入的空间了。我们又不能把新键插在其空结点上（破坏了完美平衡）。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。创建一个4-结点很方便，因为很容易将它转换为一颗由3个2-结点组成的2-3树（如图所示），这棵树既是一颗含有3个结点的二叉查找树，同时也是一颗完美平衡的2-3树，其中所有空链接到根结点的距离都相等。</p><br><span style="font-size:18px"><img src="http://img.blog.csdn.net/20140517141709609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br><br><p><span style="font-size:18px"></span></p><br><p>&nbsp;</p><br><p><strong>向一个父结点为2-结点的3-结点中插入新键</strong></p><br><p>假设未命中的查找结束于一个3-结点，而它的父结点是一个2-结点。在这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间。</p><br><p>我们先像刚才一样构造一个临时的4-结点并将其分解，但此时我们不会为<u>中键</u>创建一个新结点，而是<u>将其移动至原来的父结点中</u>。（如图所示）</p><br><img src="http://img.blog.csdn.net/20140517141807656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br><p><span style="font-size:18px"></span></p><br><p>这次转换也并不影响（完美平衡的）2-3树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了，树仍然是完美平衡的，插入后所有的空链接到根结点的距离仍然相同。</p><br><p>&nbsp;</p><br><p><strong>向一个父结点为3-结点的3-结点中插入新键</strong></p><br><p>假设未命中的查找结束于一个3-结点，而它的父结点是一个3-结点。</p><br><p><u>我们再次和刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中</u>。但父结点也是一个3-结点，因此我们再用这个中键构造一个新的临时4-结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。</p><br><p>我们就这样<u>一直向上不断分解临时的4-结点并将中键插入更高的父结点</u>，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。</p><br><img src="http://img.blog.csdn.net/20140517141942296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br><p></p><br><p><span style="font-size:24px"><strong>总结</strong>：</span></p><br><p style="font-size:18px"><strong>先找插入结点，若结点有空(即2-结点)，则直接插入。如结点没空(即3-结点)，则插入使其临时容纳这个元素，然后分裂此结点，把中间元素移到其父结点中。对父结点亦如此处理。</strong>（中键一直往上移，直到找到空位，在此过程中没有空位就先搞个临时的，再分裂。）</p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px">★2-3树插入算法的<span style="color:red">根本在于</span>这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。</p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px"><strong>{你确定理解了2-3树的插入过程了吗？ 如果你理解了，那么你也就基本理解了红黑树的插入}</strong></p><br><p style="font-size:18px">&nbsp;</p><br><p><strong><span style="font-size:24px">构造</span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">和标准的二叉查找树由上向下生长不同，<span style="color:red">2-3</span><span style="color:red">树的生长是由下向上的</span>。</p><br><span style="font-size:18px"><img src="http://img.blog.csdn.net/20140517142043906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br><br><p><span style="font-size:18px"><br><br></span></p><br><p></p><br><p><strong><span style="font-size:24px">优点</span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以<u>任何查找或者插入的成本都肯定不会超过对数级别</u>。</p><br><p style="font-size:18px">完美平衡的2-3树要平展的多。例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。</p><br><p style="font-size:18px">&nbsp;</p><br><p><strong><span style="font-size:24px">缺点</span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">我们需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。</p><br><p style="font-size:18px">平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。</p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px"><br><br></p><br><h2><span style="font-family:Microsoft YaHei; font-size:32px">红黑二叉查找树</span></h2><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">【前言：本文所讨论的红黑树之目的在于使读者能更简单清晰地了解红黑树的构造，使读者能在纸上清晰快速地画出红黑树，而不是为了写出红黑树的实现代码。</p><br><p style="font-size:18px">若是要在代码级理解红黑树，则势必需要记住其复杂的插入和旋转的各种情况，我认为那只有助于增加大家对红黑树的恐惧，实际面试和工作中几乎不会遇到需要自己动手实现红黑树的情况(很多语言的标准库中就有红黑树的实现)。&nbsp; 若对于红黑树的C代码实现有兴趣的，可移步至July的博客。】</p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px">（<strong>理解红黑树一句话就够了</strong>：<span style="color:red">红黑树就是用红链接表示3-</span>结点的2-3树。那么红黑树的插入、构造就可转化为2-3树的问题，即：<u>在脑中用2-3树来操作，得到结果，再把结果中的3-结点转化为红链接即可</u>。而2-3树的插入，前面已有详细图文，实际也很简单：有空则插，没空硬插，再分裂。&nbsp; 这样，我们就不用记那么复杂且让人头疼的红黑树插入旋转的各种情况了。只要清楚2-3树的插入方式即可。&nbsp;<br> 下面图文详细演示。）</p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px"><span style="font-family:Microsoft YaHei"><strong>红黑树的本质</strong>：</span></p><br><p style="font-size:18px">红黑树是对2-3查找树的改进，它能用一种统一的方式完成所有变换。</p><br><p style="font-size:18px">&nbsp;</p><br><p><span style="font-size:24px"><span style="color:red">替换</span><span style="color:red">3-</span><span style="color:red">结点</span></span></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">★红黑树背后的思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。</p><br><p style="font-size:18px">我们将树中的链接分为两种类型：<span style="color:red">红链接</span>将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接。确切地说，<span style="color:red">我们将</span><span style="color:red">3-</span><span style="color:red">结点表示为由一条<strong><u>左斜</u></strong>的红色链接相连的两个</span><span style="color:red">2-</span><span style="color:red">结点</span>。</p><br><p style="font-size:18px">这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一颗对应的二叉查找树。我们将用这种方式表示2-3树的二叉查找树称为红黑树。</p><br><span style="font-size:18px"><img src="http://img.blog.csdn.net/20140517142303390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br><br><p><span style="font-size:18px"></span></p><br><p><strong>红黑树的另一种定义</strong>是满足下列条件的二叉查找树：</p><br><p>⑴红链接均为左链接。</p><br><p>⑵没有任何一个结点同时和两条红链接相连。</p><br><p>⑶该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</p><br><p>&nbsp;</p><br><p>如果我们<span style="color:red">将一颗红黑树中的红链接画平</span>，那么所有的空链接到根结点的距离都将是相同的。如果我们将由红链接相连的结点合并，得到的就是一颗2-3树。</p><br><p>相反，如果将一颗2-3树中的3-结点画作由红色左链接相连的两个2-结点，那么不会存在能够和两条红链接相连的结点，且树必然是完美平衡的。</p><br><img src="http://img.blog.csdn.net/20140517142543921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br><p></p><br><p style="font-size:18px">&nbsp;</p><br><p style="font-size:18px">无论我们用何种方式去定义它们，<span style="color:red">红黑树都既是二叉查找树，也是</span><span style="color:red">2-3</span><span style="color:red">树</span>。</p><br><p style="font-size:18px">（2-3树的深度很小，平衡性好，效率高，但是其有两种不同的结点，实际代码实现比较复杂。而红黑树用红链接表示2-3树中另类的3-结点，统一了树中的结点类型，使代码实现简单化，又不破坏其高效性。）</p><br><p style="font-size:18px">&nbsp;</p><br><p><span style="font-size:24px"><strong>颜色表示</strong>：</span></p><br><p style="font-size:18px">因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量color中（若指向它的链接是红色的，那么该变量为true，黑色则为false）。</p><br><p style="font-size:18px">当我们提到一个结点颜色时，我们指的是指向该结点的链接的颜色。</p><br><p style="font-size:18px">&nbsp;</p><br><p><strong><span style="font-size:24px">旋转</span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心地旋转并修复。</p><br><p style="font-size:18px">（我们在这里不讨论旋转的几种情况，把红黑树看做2-3树，自然可以得到正确的旋转后结果）</p><br><p style="font-size:18px">&nbsp;</p><br><p><strong><span style="color:red"><span style="font-size:24px">插入</span></span></strong></p><br><p style="font-size:18px"><br><br></p><br><p style="font-size:18px">在插入时我们可以使用旋转操作帮助我们保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要性质：<span style="color:red">有序性</span>和<span style="color:red">完美平衡性</span>。</p><br><p style="font-size:18px">&nbsp;</p><br><p><span style="font-size:24px"><strong>热身</strong>：</span></p><br><p style="font-size:18px"><strong><br><br></strong></p><br><p style="font-size:18px"><strong>向2-结点中插入新键</strong></p><br><p style="font-size:18px">（向红黑树中插入操作时，想想2-3树的插入操作。红黑树与2-3树在本质上是相同的，只是它们对3结点的表示不同。</p><br><p style="font-size:18px">向一个只含有一个2-结点的2-3树中插入新键后，2-结点变为3-结点。我们再把这个3-结点转化为红结点即可）</p><br><span style="font-size:18px"><img src="http://img.blog.csdn.net/20140517143549781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br><br><p><span style="font-size:18px"></span></p><br><p><strong>向一颗双键树（即一个3-结点）中插入新键</strong></p><br><p>（向红黑树中插入操作时，想想2-3树的插入操作。你把红黑树当做2-3树来处理插入，一切都变得简单了）</p><br><p>（向2-3树中的一个3-结点插入新键，这个3结点临时成为4-结点，然后分裂成3个2结点）</p><br><img src="http://img.blog.csdn.net/20140517143641906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br><p><span style="font-size:18px"><br><br></span></p><br><p></p><br><p><strong><span style="font-size:24px">★一颗红黑树的构造全过程</span></strong></p><br><span style="font-size:18px"><img src="http://img.blog.csdn.net/20140517143739453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br><br><p><span style="font-size:18px"></span></p><br><h2>平衡二叉树（AVL树）</h2><br><p></p><br><p><span style="color:red"><br><br></span></p><br><p><span style="color:red">定义</span>：平衡二叉树(Balance Binary Tree)又称AVL树。它或者是一颗空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对&#20540;不超过1。</p><br><p>若将二叉树上结点的平衡因子BF(BalanceFactor)定义为该结点的左子树深度减去它的右子树深度，则<strong>平衡因子的绝对&#20540;大于1</strong>。</p><br><p>&nbsp;</p><br><p>其旋转操作 用2-3树的分裂来类比想象。</p><br><br><br><p><span style="font-size:18px"><br><br></span></p><br><p><span style="font-size:18px"><br><br></span></p><br><p><span style="font-size:18px"><a target="_blank" href="http://blog.csdn.net/yang_yulei/article/details/26104921">下半部分——散列表、B树、B&#43;树、Trie树。</a></span></p><br><p><span style="font-size:18px"><br><br></span></p><br><p><span style="font-size:18px"><br><br></span></p><br><p><br><br></p><br><p><br><br></p><br><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://bloodorange2017.github.io/images/img_head_001.jpg"
               alt="XueCheng" />
          <p class="site-author-name" itemprop="name">XueCheng</p>
           
              <p class="site-description motion-element" itemprop="description">Do one thing at a time, and do well.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XueCheng</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

<script type="text/javascript"
color="160,160,233" opacity='0.4' zIndex="-2" count="16" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
