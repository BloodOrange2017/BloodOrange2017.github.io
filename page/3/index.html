<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Do one thing at a time, and do well.">
<meta property="og:type" content="website">
<meta property="og:title" content="XueCheng Notes">
<meta property="og:url" content="https://bloodorange2017.github.io/archives/page/3/index.html">
<meta property="og:site_name" content="XueCheng Notes">
<meta property="og:description" content="Do one thing at a time, and do well.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XueCheng Notes">
<meta name="twitter:description" content="Do one thing at a time, and do well.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bloodorange2017.github.io/archives/page/3/"/>





  <title>XueCheng Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XueCheng Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Where there is a will, there is a way.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/23/jvm-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/jvm-02/" itemprop="url">转载:02-JVM原理和优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-23T14:42:00+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br><br><p>JVM工作原理和特点主要是指操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境. </p><br><p>1.创建JVM装载环境和配置 </p><br><p>2.装载JVM.dll </p><br><p>3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例 </p><br><p>4.调用JNIEnv实例装载并处理class类。 </p><br><p></p><br><p>在我们运行和调试Java程序的时候,经常会提到一个JVM的概念.JVM是Java程序运行的环境,但是他同时一个操作系统的一个应用程序一个进程,因此他也有他自己的运行的生命周期,也有自己的代码和数据空间.<br></p><br><p>首先来说一下JVM工作原理中的jdk这个东西,不管你是初学者还是高手,是j2ee程序员还是j2se程序员,jdk总是在帮我们做一些事情.我们在了解Java之前首先大师们会给我们提供说jdk这个东西.它在Java整个体系中充当着什么角色呢?我很惊叹sun大师们设计天才,能把一个如此完整的体系结构化的如此完美.jdk在这个体系中充当一个生产加工中心,产生所有的数据输出,是所有指令和战略的执行中心.本身它提供了Java的完整方案,可以开发目前Java能支持的所有应用和系统程序.这里说一个问题,大家会问,那为什么还有j2me,j2ee这些东西,这两个东西目的很简单,分别用来简化各自领域内的开发和构建过程.jdk除了JVM之外,还有一些核心的API,集成API,用户工具,开发技术,开发工具和API等组成<br></p><br><p>好了,废话说了那么多,来点于主题相关的东西吧.JVM在整个jdk中处于最底层,负责于操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也就虚拟计算机. 操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境.<br></p><br><p>1.创建JVM装载环境和配置 </p><br><p>2.装载JVM.dll </p><br><p>3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例 </p><br><p>4.调用JNIEnv实例装载并处理class类。 </p><br><p><strong>一．JVM装入环境，JVM提供的方式是操作系统的动态连接文件．</strong>既然是文件那就一个装入路径的问题，Java是怎么找这个路径的呢？当你在调用Java test的时候，操作系统会在path下在你的Java.exe程序，Java.exe就通过下面一个过程来确定JVM的路径和相关的参数配置了．下面基于Windows的实现的分析．<br></p><br><p>首先查找jre路径，Java是通过GetApplicationHome api来获得当前的Java.exe绝对路径，c:\j2sdk1.4.2_09\bin\Java.exe,那么它会截取到绝对路径c:\j2sdk1.4.2_09\，判断c:\j2sdk1.4.2_09\bin\Java.dll文件是否存在，如果存在就把c:\j2sdk1.4.2_09\作为jre路径，如果不存在则判断c:\j2sdk1.4.2_09\jre\bin\Java.dll是否存在，如果存在这c:\j2sdk1.4.2_09\jre作为jre路径．如果不存在调用GetPublicJREHome查HKEY_LOCAL_MACHINE\Software\JavaSoft\Java<br> Runtime Environment\“当前JRE版本号”\JavaHome的路径为jre路径。 </p><br><p>然后装载JVM.cfg文件JRE路径&#43;\lib&#43;\ARCH（CPU构架）&#43;\JVM.cfgARCH（CPU构架）的判断是通过Java_md.c中GetArch函数判断的，该函数中windows平台只有两种情况：WIN64的‘ia64’，其他情况都为‘i386’。以我的为例：C:\j2sdk1.4.2_09\jre\lib\i386\JVM.cfg.主要的内容如下：<br></p><br><pre><ol class="dp-xml"><li class="alt"><span>-client&nbsp;KNOWN&nbsp; &nbsp;</span></li><li><span>-server&nbsp;KNOWN&nbsp; &nbsp;</span></li><li class="alt"><span>-hotspot&nbsp;ALIASED_TO&nbsp;-client&nbsp; &nbsp;</span></li><li><span>-classic&nbsp;WARN&nbsp; &nbsp;</span></li><li class="alt"><span>-native&nbsp;ERROR&nbsp; &nbsp;</span></li><li><span>-green&nbsp;ERROR&nbsp;&nbsp;</span></li></ol></pre><br><p>在我们的jdk目录中jre\bin\server和jre\bin\client都有JVM.dll文件存在，而Java正是通过JVM.cfg配置文件来管理这些不同版本的JVM.dll的．通过文件我们可以定义目前jdk中支持那些JVM,前面部分（client）是JVM名称，后面是参数，KNOWN表示JVM存在，ALIASED_TO表示给别的JVM取一个别名，WARN表示不存在时找一个JVM替代，ERROR表示不存在抛出异常．在运行Java XXX是，Java.exe会通过CheckJVMType来检查当前的JVM类型，Java可以通过两种参数的方式来指定具体的JVM类型，一种按照JVM.cfg文件中的JVM名称指定，第二种方法是直接指定，它们执行的方法分别是“Java<br> -J”、“Java -XXaltJVM=”或“Java -J-XXaltJVM=”。如果是第一种参数传递方式，CheckJVMType函数会取参数‘-J’后面的JVM名称，然后从已知的JVM配置参数中查找如果找到同名的则去掉该JVM名称前的‘-’直接返回该&#20540;；而第二种方法，会直接返回“-XXaltJVM=”或“-J-XXaltJVM=”后面的JVM类型名称；如果在运行Java时未指定上面两种方法中的任一一种参数，CheckJVMType会取配置文件中第一个配置中的JVM名称，去掉名称前面的‘-’返回该&#20540;。CheckJVMType函数的这个返回&#20540;会在下面的函数中汇同jre路径组合成JVM.dll的绝对路径。如果没有指定这会使用JVM.cfg中第一个定义的JVM.可以通过set<br> _Java_LAUNCHER_DEBUG=1在控制台上测试． </p><br><p>最后获得JVM.dll的路径，JRE路径&#43;\bin&#43;\JVM类型字符串&#43;\JVM.dll就是JVM的文件路径了，但是如果在调用Java程序时用-XXaltJVM=参数指定的路径path,就直接用path&#43;\JVM.dll文件做为JVM.dll的文件路径．<br></p><br><p><strong>二：装载JVM.dll</strong> </p><br><p>通过第一步已经找到了JVM的路径，Java通过LoadJavaVM来装入JVM.dll文件．装入工作很简单就是调用Windows API函数： </p><br><p>LoadLibrary装载JVM.dll动态连接库．然后把JVM.dll中的导出函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMInitArgs挂接到InvocationFunctions变量的CreateJavaVM和GetDefaultJavaVMInitArgs函数指针变量上。JVM.dll的装载工作宣告完成。<br></p><br><p><strong>三：初始化JVM，获得本地调用接口，</strong>这样就可以在Java中调用JVM的函数了．调用InvocationFunctions－&gt;CreateJavaVM也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例．<br></p><br><p><strong>四：运行Java程序．</strong> </p><br><p>Java程序有两种方式一种是jar包，一种是class. 运行jar,Java -jar XXX.jar运行的时候，Java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用Java类Java.util.jar.JarFileJNIEnv中方法getManifest()并从返回的Manifest对象中取getAttributes(&quot;Main-Class&quot;)的&#20540;即jar包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。main函数直接调用Java.c中LoadClass方法装载该类。如果是执行class方法。main函数直接调用Java.c中LoadClass方法装载该类。<br></p><br><p>然后main函数调用JNIEnv实例的GetStaticMethodID方法查找装载的class主类中 </p><br><p>“public static void main(String[] args)”方法，并判断该方法是否为public方法，然后调用JNIEnv实例的 </p><br><p>CallStaticVoidMethod方法调用该Java类的main方法。&nbsp; </p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br>以下转自：<a target="_blank" href="http://blog.csdn.net/cnhzgb/article/details/7179419">http://blog.csdn.net/cnhzgb/article/details/7179419</a><span style="font-size:24px"><strong></strong></span></p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br><span style="font-size:24px"><strong>= GC 基础 =====================</strong></span></p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; font-size:12px; padding-top:2px"><br><br><br></p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; font-size:12px; padding-top:2px"><br>JAVA堆的描述如下：</p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; font-size:12px; padding-top:2px"><br><img alt="" src="http://hi.csdn.net/attachment/201201/6/0_1325814932X3Ts.gif"><br style="line-height:normal"><br>内存由 Perm 和 Heap 组成. 其中<br><br>Heap = {Old &#43; NEW = { Eden , from, to } }<br><br>JVM内存模型中分两大块，一块是 NEW Generation, 另一块是Old Generation. 在New Generation中，有一个叫Eden的空间，主要是用来存放新生的对象，还有两个Survivor Spaces（from,to）, 它们用来存放每次垃圾回收后存活下来的对象。在Old Generation中，主要存放应用程序中生命周期长的内存对象，还有个Permanent Generation，主要用来放JVM自己的反射对象，比如类对象和方法对象等。<br><br>垃圾回收描述：<br><br>在New Generation块中，垃圾回收一般用Copying的算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个Survivor Space, 当Survivor Space空间满了后, 剩下的live对象就被直接拷贝到Old Generation中去。因此，每次GC后，Eden内存块会被清空。在Old Generation块中，垃圾回收一般用mark-compact的算法，速度慢些，但减少内存要求.<br><br>垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收NEW中的垃圾，内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。<br><br><br><br><br><br>当一个URL被访问时，内存申请过程如下：<br><br>A. JVM会试图为相关Java对象在Eden中初始化一块内存区域<br><br>B. 当Eden空间足够时，内存申请结束。否则到下一步<br><br>C. JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）, 释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区<br><br>D. Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区<br><br>E. 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级）<br><br>F. 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”<br><br>JVM调优建议:<br><br>ms/mx：定义YOUNG&#43;OLD段的总尺寸，ms为JVM启动时YOUNG&#43;OLD的内存大小；mx为最大可占用的YOUNG&#43;OLD内存大小。在用户生产环境上一般将这两个&#20540;设为相同，以减少运行期间系统在内存申请上所花的开销。<br><br>NewSize/MaxNewSize：定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小；MaxNewSize为最大可占用的YOUNG内存大小。在用户生产环境上一般将这两个&#20540;设为相同，以减少运行期间系统在内存申请上所花的开销。<br><br>PermSize/MaxPermSize：定义Perm段的尺寸，PermSize为JVM启动时Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个&#20540;设为相同，以减少运行期间系统在内存申请上所花的开销。<br><br>SurvivorRatio：设置Survivor空间和Eden空间的比例<br><br>内存溢出的可能性<br><br><br><br><br><br>1. OLD段溢出<br><br>这种内存溢出是最常见的情况之一，产生的原因可能是：<br><br>1) 设置的内存参数过小(ms/mx, NewSize/MaxNewSize)<br><br>2) 程序问题<br><br>单个程序持续进行消耗内存的处理，如循环几千次的字符串处理，对字符串处理应建议使用StringBuffer。此时不会报内存溢出错，却会使系统持续垃圾收集，无法处理其它请求，相关问题程序可通过Thread Dump获取（见系统问题诊断一章）单个程序所申请内存过大，有的程序会申请几十乃至几百兆内存，此时JVM也会因无法申请到资源而出现内存溢出，对此首先要找到相关功能，然后交予程序员修改，要找到相关程序，必须在Apache日志中寻找。<br><br>当Java对象使用完毕后，其所引用的对象却没有销毁，使得JVM认为他还是活跃的对象而不进行回收，这样累计占用了大量内存而无法释放。由于目前市面上还没有对系统影响小的内存分析工具，故此时只能和程序员一起定位。<br><br>2. Perm段溢出<br><br>通常由于Perm段装载了大量的Servlet类而导致溢出，目前的解决办法：<br><br>1) 将PermSize扩大，一般256M能够满足要求<br><br>2) 若别无选择，则只能将servlet的路径加到CLASSPATH中，但一般不建议这么处理<br><br><br><br><br><br>3. C Heap溢出<br><br>系统对C Heap没有限制，故C Heap发生问题时，Java进程所占内存会持续增长，直到占用所有可用系统内存<br><br>其他：<br><br>JVM有2个GC线程。第一个线程负责回收Heap的Young区。第二个线程在Heap不足时，遍历Heap，将Young 区升级为Older区。Older区的大小等于-Xmx减去-Xmn，不能将-Xms的&#20540;设的过大，因为第二个线程被迫运行会降低JVM的性能。<br><br>为什么一些程序频繁发生GC？有如下原因：<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; 程序内调用了System.gc()或Runtime.gc()。<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; 一些中间件软件调用自己的GC方法，此时需要设置参数禁止这些GC。<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; Java的Heap太小，一般默认的Heap&#20540;都很小。<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; 频繁实例化对象，Release对象。此时尽量保存并重用对象，例如使用StringBuffer()和String()。<br><br>如果你发现每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态。许多Server端的Java程序每次GC后最好能有65%的剩余空间。<br><br>经验之谈：<br><br>1．Server端JVM最好将-Xms和-Xmx设为相同&#20540;。为了优化GC，最好让-Xmn&#20540;约等于-Xmx的1/3[2]。<br><br>2．一个GUI程序最好是每10到20秒间运行一次GC，每次在半秒之内完成[2]。<br><br>注意：<br><br>1．增加Heap的大小虽然会降低GC的频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。<br><br>2．Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的&#20540;，因为Java为其他任务分配内存，例如每个线程的Stack等。<br><br>2．Stack的设定<br><br>每个线程都有他自己的Stack。<br><br></p><br><div style="line-height:normal; background-color:white; zoom:1!important; word-wrap:break-word; visibility:visible!important; font-size:12px; word-break:break-all"><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><table border="1" cellspacing="0" cellpadding="0" width="90%" style="line-height:normal; background-color:rgb(238,204,255); width:856px; table-layout:auto!important"><br><tbody style="line-height:normal"><br><tr style="line-height:normal"><br><td style="padding-bottom:1.5pt; line-height:normal; padding-left:1.5pt; padding-right:1.5pt; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:12px; word-break:break-all; padding-top:1.5pt"><br><div align="left" style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><span style="line-height:normal; font-size:12pt">-Xss</span></div><br></td><br><td style="padding-bottom:1.5pt; line-height:normal; padding-left:1.5pt; padding-right:1.5pt; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:12px; word-break:break-all; padding-top:1.5pt"><br><div align="left" style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><span style="line-height:normal; font-size:12pt">每个线程的</span><span style="line-height:normal; font-size:12pt">Stack</span><span style="line-height:normal; font-size:12pt">大小</span></div><br></td><br></tr><br></tbody><br></table><br></p><br><div style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br>Stack的大小限制着线程的数量。如果Stack过大就好导致内存溢漏。-Xss参数决定Stack大小，例如-Xss1024K。如果Stack太小，也会导致Stack溢漏。<br><br>3．硬件环境<br><br>硬件环境也影响GC的效率，例如机器的种类，内存，swap空间，和CPU的数量。<br><br>如果你的程序需要频繁创建很多transient对象，会导致JVM频繁GC。这种情况你可以增加机器的内存，来减少Swap空间的使用[2]。<br><br>4．4种GC<br><br>第一种为单线程GC，也是默认的GC。，该GC适用于单CPU机器。<br><br>第二种为Throughput GC，是多线程的GC，适用于多CPU，使用大量线程的程序。第二种GC与第一种GC相&#20284;，不同在于GC在收集Young区是多线程的，但在Old区和第一种一样，仍然采用单线程。-XX:&#43;UseParallelGC参数启动该GC。<br><br>第三种为Concurrent Low Pause GC，类&#20284;于第一种，适用于多CPU，并要求缩短因GC造成程序停滞的时间。这种GC可以在Old区的回收同时，运行应用程序。-XX:&#43;UseConcMarkSweepGC参数启动该GC。<br><br>第四种为Incremental Low Pause GC，适用于要求缩短因GC造成程序停滞的时间。这种GC可以在Young区回收的同时，回收一部分Old区对象。-Xincgc参数启动该GC。<br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px"></span><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br><strong>按照基本回收策略分</strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">引用计数（Reference Counting）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">标记-清除（Mark-Sweep）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;<img alt="标记清楚" src="http://hi.csdn.net/attachment/201003/6/1981948_1267862317X1a1.png" width="573" height="230" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">复制（Copying）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><img alt="复制" src="http://hi.csdn.net/attachment/201003/6/1981948_1267862317ZvYy.png" width="573" height="230" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none">&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">标记-整理（Mark-Compact）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;<img alt="标记整理" src="http://hi.csdn.net/attachment/201003/6/1981948_1267862317X1a1.png" width="573" height="230" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p><br><h2 style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:0px"><br><a target="_blank" name="t0"></a><br><br>&nbsp;</h2><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br><strong>按分区对待的方式分</strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>增量收集（Incremental Collecting）:</strong></span>实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>分代收集（Generational Collecting）:</strong></span>基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br><strong>按系统线程分</strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">串行收集:</span></strong>串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">并行收集:</span></strong>并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。（串型收集的并发版本，需要暂停jvm） 并行paralise指的是多个任务在多个cpu中一起并行执行，最后将结果合并。效率是N倍。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>并发收集:</strong></span>相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。（和并行收集不同，并发只有在开头和结尾会暂停jvm）并发concurrent指的是多个任务在一个cpu伪同步执行，但其实是串行调度的，效率并非直接是N倍。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; padding-top:2px"><br><strong><span style="font-size:13px">分代垃圾回收</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp;&nbsp; 分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="font-size:16px"><img alt="jvm分代" src="http://hi.csdn.net/attachment/201003/6/1981948_12678645142BKS.png" width="574" height="318" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>如图所示：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;虚拟机中的共划分为三个代：<strong>年轻代（Young Generation）、年老点（Old Generation）和持久代（Permanent Generation）</strong>。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">年轻代:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来<br> 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">年老代:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>持久代:</strong></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=&lt;N&gt;进行设置。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; padding-top:2px"><br><strong><span style="font-size:13px">什么情况下触发垃圾回收&nbsp;</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<strong>Scavenge GC</strong>和<strong>Full GC</strong>。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">Scavenge GC</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">Full GC</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><br><blockquote style="font-family:Arial; font-size:14px"><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>· 年老代（Tenured）被写满</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>· 持久代（Perm）被写满&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>· System.gc()被显示调用&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>·上一次GC之后Heap的各域分配策略动态变化</p><br></blockquote><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程1" src="http://hi.csdn.net/attachment/201004/18/1981948_1271591242sfBp.jpg" width="482" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程2" src="http://hi.csdn.net/attachment/201004/18/1981948_12715912450bkp.png" width="413" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程3" src="http://hi.csdn.net/attachment/201004/18/1981948_1271591246383f.png" width="413" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程" src="http://hi.csdn.net/attachment/201004/18/1981948_1271591249sb6K.png" width="415" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><h2><a target="_blank" name="t1"></a><strong><span style="font-size:16px">= G1 ===================================</span></strong></h2><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>传说中的G1，传说中的low-pause垃圾收集。Java SE 6的update14版本中已经包含测试版，可以在启动时加JVM参数来启用</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'">-XX:&#43;UnlockExperimentalVMOptions -XX:&#43;UseG1GC</span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><a target="_blank" href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html">http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html</a><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'">本文摘自《构建高性能的大型分布式Java应用》一书，Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率，将作为CMS的替代者在JDK 7中闪亮登场，其最大的特色在于允许指定在某个时间段内GC所导致的应用暂停的时间最大为多少，例如在100秒内最多允许GC导致的应用暂停时间为1秒，这个特性对于准实时响应的系统而言非常的吸引人，这样就再也不用担心系统突然会暂停个两三秒了。</span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>G1要做到这样的效果，也是有前提的，一方面是硬件环境的要求，必须是多核的CPU以及较大的内存（从规范来看，512M以上就满足条件了），另外一方面是需要接受吞吐量的稍微降低，对于实时性要求高的系统而言，这点应该是可以接受的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>为了能够达到这样的效果，G1在原有的各种GC策略上进行了吸收和改进，在G1中可以看到增量收集器和CMS的影子，但它不仅仅是吸收原有GC策略的优点，并在此基础上做出了很多的改进，简单来说，G1吸收了增量GC以及CMS的精髓，将整个jvm Heap划分为多个固定大小的region，扫描时采用Snapshot-at-the-beginning的并发marking算法（具体在后面内容详细解释）对整个heap中的region进行mark，回收时根据region中活跃对象的bytes进行排序，首先回收活跃对象bytes小以及回收耗时短（预估出来的时间）的region，回收的方法为将此region中的活跃对象复制到另外的region中，根据指定的GC所能占用的时间来估算能回收多少region，这点和以前版本的Full<br> GC时得处理整个heap非常不同，这样就做到了能够尽量短时间的暂停应用，又能回收内存，由于这种策略在回收时首先回收的是垃圾对象所占空间最多的region，因此称为Garbage First。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>看完上面对于G1策略的简短描述，并不能清楚的掌握G1，在继续详细看G1的步骤之前，必须先明白G1对于JVM Heap的改造，这些对于习惯了划分为new generation、old generation的大家来说都有不少的新意。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>G1将Heap划分为多个固定大小的region，这也是G1能够实现控制GC导致的应用暂停时间的前提，region之间的对象引用通过remembered set来维护，每个region都有一个remembered set，remembered set中包含了引用当前region中对象的region的对象的pointer，由于同时应用也会造成这些region中对象的引用关系不断的发生改变，G1采用了Card Table来用于应用通知region修改remembered sets，Card Table由多个512字节的Card构成，这些Card在Card<br> Table中以1个字节来标识，每个应用的线程都有一个关联的remembered set log，用于缓存和顺序化线程运行时造成的对于card的修改，另外，还有一个全局的filled RS buffers，当应用线程执行时修改了card后，如果造成的改变仅为同一region中的对象之间的关联，则不记录remembered set log，如造成的改变为跨region中的对象的关联，则记录到线程的remembered set log，如线程的remembered set log满了，则放入全局的filled RS<br> buffers中，线程自身则重新创建一个新的remembered set log，remembered set本身也是一个由一堆cards构成的哈希表。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>尽管G1将Heap划分为了多个region，但其默认采用的仍然是分代的方式，只是仅简单的划分为了年轻代（young）和非年轻代，这也是由于G1仍然坚信大多数新创建的对象都是不需要长的生命周期的，对于应用新创建的对象，G1将其放入标识为young的region中，对于这些region，并不记录remembered set logs，扫描时只需扫描活跃的对象，G1在分代的方式上还可更细的划分为：fully young或partially young，fully young方式暂停的时候仅处理young regions，partially同样处理所有的young<br> regions，但它还会根据允许的GC的暂停时间来决定是否要加入其他的非young regions，G1是运行到fully-young方式还是partially young方式，外部是不能决定的，在启动时，G1采用的为fully-young方式，当G1完成一次Concurrent Marking后，则切换为partially young方式，随后G1跟踪每次回收的效率，如果回收fully-young中的regions已经可以满足内存需要的话，那么就切换回fully young方式，但当heap size的大小接近满的情况下，G1会切换到partially<br> young方式，以保证能提供足够的内存空间给应用使用。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>除了分代方式的划分外，G1还支持另外一种pure G1的方式，也就是不进行代的划分，pure方式和分代方式的具体不同在下面的具体执行步骤中进行描述。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>掌握了这些概念后，继续来看G1的具体执行步骤：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initial Marking</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>G1对于每个region都保存了两个标识用的bitmap，一个为previous marking bitmap，一个为next marking bitmap，bitmap中包含了一个bit的地址信息来指向对象的起始点。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>开始Initial Marking之前，首先并发的清空next marking bitmap，然后停止所有应用线程，并扫描标识出每个region中root可直接访问到的对象，将region中top的&#20540;放入next top at mark start（TAMS）中，之后恢复所有应用线程。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>触发这个步骤执行的条件为：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;G1定义了一个JVM Heap大小的百分比的阀&#20540;，称为h，另外还有一个H，H的&#20540;为(1-h)<em>Heap Size，目前这个h的&#20540;是固定的，后续G1也许会将其改为动态的，根据jvm的运行情况来动态的调整，在分代方式下，G1还定义了一个u以及soft limit，soft limit的&#20540;为H-u</em>Heap Size，当Heap中使用的内存超过了soft limit&#20540;时，就会在一次clean up执行完毕后在应用允许的GC暂停时间范围内尽快的执行此步骤；</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;在pure方式下，G1将marking与clean up组成一个环，以便clean up能充分的使用marking的信息，当clean up开始回收时，首先回收能够带来最多内存空间的regions，当经过多次的clean up，回收到没多少空间的regions时，G1重新初始化一个新的marking与clean up构成的环。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concurrent Marking</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>按照之前Initial Marking扫描到的对象进行遍历，以识别这些对象的下层对象的活跃状态，对于在此期间应用线程并发修改的对象的以来关系则记录到remembered set logs中，新创建的对象则放入比top&#20540;更高的地址区间中，这些新创建的对象默认状态即为活跃的，同时修改top&#20540;。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Final Marking Pause</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>当应用线程的remembered set logs未满时，是不会放入filled RS buffers中的，在这样的情况下，这些remebered set logs中记录的card的修改就会被更新了，因此需要这一步，这一步要做的就是把应用线程中存在的remembered set logs的内容进行处理，并相应的修改remembered sets，这一步需要暂停应用，并行的运行。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Live Data Counting and Cleanup</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>&#20540;得注意的是，在G1中，并不是说Final Marking Pause执行完了，就肯定执行Cleanup这步的，由于这步需要暂停应用，G1为了能够达到准实时的要求，需要根据用户指定的最大的GC造成的暂停时间来合理的规划什么时候执行Cleanup，另外还有几种情况也是会触发这个步骤的执行的：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;G1采用的是复制方法来进行收集，必须保证每次的”to space”的空间都是够的，因此G1采取的策略是当已经使用的内存空间达到了H时，就执行Cleanup这个步骤；</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;对于full-young和partially-young的分代模式的G1而言，则还有情况会触发Cleanup的执行，full-young模式下，G1根据应用可接受的暂停时间、回收young regions需要消耗的时间来估算出一个yound regions的数量&#20540;，当JVM中分配对象的young regions的数量达到此&#20540;时，Cleanup就会执行；partially-young模式下，则会尽量频繁的在应用可接受的暂停时间范围内执行Cleanup，并最大限度的去执行non-young regions的Cleanup。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>这一步中GC线程并行的扫描所有region，计算每个region中低于next TAMS&#20540;中marked data的大小，然后根据应用所期望的GC的短延时以及G1对于region回收所需的耗时的预估，排序region，将其中活跃的对象复制到其他region中。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><span style="font-size:14px">G1为了能够尽量的做到准实时的响应，例如估算暂停时间的算法、对于经常被引用的对象的特殊处理等，G1为了能够让GC既能够充分的回收内存，又能够尽量少的导致应用的暂停，可谓费尽心思，从G1的论文中的性能评测来看效果也是不错的，不过如果G1能允许开发人员在编写代码时指定哪些对象是不用mark的就更完美了，这对于有巨大缓存的应用而言，会有很大的帮助，G1将随JDK 6 Update 14&nbsp;beta发布。</span><br><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><h2><a target="_blank" name="t2"></a><span style="font-family:'Courier New'">= CMS ==================================</span></h2><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><a target="_blank" href="http://www.iteye.com/topic/1119491">http://www.iteye.com/topic/1119491</a><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><span></span></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><span style="font-size:13px"><strong>1.总体介绍：</strong></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。并发意味着除了开头和结束阶段，需要暂停JVM，其它时间gc和应用一起执行。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上<span style="color:#ff00">-XX:&#43;UseConcMarkSweepGC</span>&nbsp;，这个参数表示对于老年代的回收采用CMS。CMS采用的基础算法是：标记—清除。默认会开启 -XX :&#43;UseParNewGC，在年轻代使用并行复制收集。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><strong><span style="font-size:13px">2.CMS过程：</span></strong></p><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>初始标记(STW initial mark) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发标记(Concurrent marking) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发预清理(Concurrent precleaning) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>重新标记(STW remark) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发清理(Concurrent sweeping) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发重置(Concurrent reset)</li></ul><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>初始标记</strong>&nbsp;</span>：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的&quot;根对象&quot;开始，只扫描到能够和&quot;根对象&quot;直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>并发标记</strong>&nbsp;</span>：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><strong><span style="color:#3366ff">并发预清理</span>&nbsp;</strong>：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段&quot;重新标记&quot;的工作，因为下一个阶段会Stop The World。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>重新标记</strong>&nbsp;</span>：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从&quot;跟对象&quot;开始向下追溯，并处理对象关联。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><strong><span style="color:#3366ff">并发清理</span>&nbsp;</strong>：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>并发重置</strong>&nbsp;</span>：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>&nbsp;</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#ff00">CSM执行过程：</span>&nbsp;<br><br><img class="magplus" title="点击查看原始大小图片" alt="" src="http://dl.iteye.com/upload/attachment/612577/2b525609-ce63-3a42-bf19-b2fbcd42f26c.png" width="700" height="151" style="border-right-width:0px; border-top-width:0px; border-bottom-width:0px; border-left-width:0px"></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><strong><span style="font-size:13px">3.CMS缺点</span></strong></p><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>CMS回收器采用的基础算法是Mark-Sweep。所有CMS不会整理、压缩堆空间。这样就会有一个问题：经过CMS收集的堆会产生空间碎片。 CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空 间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。</li></ul><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>需要更多的CPU资源。从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。并且，重新标记阶段，为空保证STW快速完成，也要用到更多的甚至所有的CPU资源。当然，多核多CPU也是未来的趋势！</li></ul><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回 收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，已 避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用68%的时候，CMS就开始行动了。 – XX:CMSInitiatingOccupancyFraction =n 来设置这个阀&#20540;。</li></ul><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>总得来说，CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><span style="font-size:13px"><strong>4.啥时候用CMS</strong></span></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>如果你的应用程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU(也就是硬件牛&#36924;)，那么使用CMS来收集会给你带来好处。还有，如果在JVM中，有相对较多存活时间较长的对象(老年代比较大)会更适合使用CMS。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><h2><a target="_blank" name="t3"></a>= 调试工具 ==================================</h2><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px"><br><strong><span style="font-size:13px">jmap</span></strong></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jmap -heap pid &nbsp;(不能观察G1模式）</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>using parallel threads in the new generation.<br><br>using thread-local object allocation.<br><br>Concurrent Mark-Sweep GC<br><br><br><br>Heap Configuration:<br><br>&nbsp; &nbsp;MinHeapFreeRatio = 40<br><br>&nbsp; &nbsp;MaxHeapFreeRatio = 70<br><br>&nbsp; &nbsp;MaxHeapSize &nbsp; &nbsp; &nbsp;= 2147483648 (2048.0MB)<br><br>&nbsp; &nbsp;NewSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 268435456 (256.0MB)<br><br>&nbsp; &nbsp;MaxNewSize &nbsp; &nbsp; &nbsp; = 268435456 (256.0MB)<br><br>&nbsp; &nbsp;OldSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 805306368 (768.0MB)<br><br>&nbsp; &nbsp;NewRatio &nbsp; &nbsp; &nbsp; &nbsp; = 7<br><br>&nbsp; &nbsp;SurvivorRatio &nbsp; &nbsp;= 8<br><br>&nbsp; &nbsp;PermSize &nbsp; &nbsp; &nbsp; &nbsp; = 134217728 (128.0MB)<br><br>&nbsp; &nbsp;MaxPermSize &nbsp; &nbsp; &nbsp;= 134217728 (128.0MB)<br><br><br><br>Heap Usage:<br><br>New Generation (Eden &#43; 1 Survivor Space):<br><br>&nbsp; &nbsp;capacity = 241631232 (230.4375MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 145793088 (139.03912353515625MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 95838144 (91.39837646484375MB)<br><br>&nbsp; &nbsp;60.33702133340114% used<br><br>Eden Space:<br><br>&nbsp; &nbsp;capacity = 214827008 (204.875MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 132689456 (126.54252624511719MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 82137552 (78.33247375488281MB)<br><br>&nbsp; &nbsp;61.7657236095752% used<br><br>From Space:<br><br>&nbsp; &nbsp;capacity = 26804224 (25.5625MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 13103632 (12.496597290039062MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 13700592 (13.065902709960938MB)<br><br>&nbsp; &nbsp;48.886444166411984% used<br><br>To Space:<br><br>&nbsp; &nbsp;capacity = 26804224 (25.5625MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 0 (0.0MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 26804224 (25.5625MB)<br><br>&nbsp; &nbsp;0.0% used<br><br>concurrent mark-sweep generation: （old区）<br><br>&nbsp; &nbsp;capacity = 1879048192 (1792.0MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 1360638440 (1297.6059341430664MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 518409752 (494.3940658569336MB)<br><br>&nbsp; &nbsp;72.41104543209076% used<br><br>Perm Generation:<br><br>&nbsp; &nbsp;capacity = 134217728 (128.0MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 65435064 (62.40373992919922MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 68782664 (65.59626007080078MB)<br><br>&nbsp; &nbsp;48.75292181968689% used<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jmap -histo:live pid</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>num &nbsp; &nbsp; #instances &nbsp; &nbsp; &nbsp; &nbsp; #bytes &nbsp;class name<br><br>———————————————-<br><br>&nbsp; &nbsp;1: &nbsp; &nbsp; &nbsp; 3148147 &nbsp; &nbsp; &nbsp;209172848 &nbsp;[B<br><br>&nbsp; &nbsp;2: &nbsp; &nbsp; &nbsp; 2584345 &nbsp; &nbsp; &nbsp;144723320 &nbsp;java.lang.ref.SoftReference<br><br>&nbsp; &nbsp;3: &nbsp; &nbsp; &nbsp; 2578827 &nbsp; &nbsp; &nbsp;123783696 &nbsp;sun.misc.CacheEntry<br><br>&nbsp; &nbsp;4: &nbsp; &nbsp; &nbsp; &nbsp;781560 &nbsp; &nbsp; &nbsp;112544640 &nbsp;com.sun.net.ssl.internal.ssl.SSLSessionImpl<br><br>&nbsp; &nbsp;5: &nbsp; &nbsp; &nbsp; 1385200 &nbsp; &nbsp; &nbsp; 89970592 &nbsp;[C<br><br>&nbsp; &nbsp;6: &nbsp; &nbsp; &nbsp; &nbsp;783287 &nbsp; &nbsp; &nbsp; 87807200 &nbsp;[Ljava.util.Hashtable$Entry;<br><br>&nbsp; &nbsp;7: &nbsp; &nbsp; &nbsp; 1421399 &nbsp; &nbsp; &nbsp; 56855960 &nbsp;java.lang.String<br><br>&nbsp; &nbsp;8: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 &nbsp; &nbsp; &nbsp; 56828880 &nbsp;[Lsun.misc.CacheEntry;<br><br>&nbsp; &nbsp;9: &nbsp; &nbsp; &nbsp; 2343358 &nbsp; &nbsp; &nbsp; 56240592 &nbsp;com.sun.net.ssl.internal.ssl.SessionId<br><br>&nbsp; 10: &nbsp; &nbsp; &nbsp; &nbsp;783185 &nbsp; &nbsp; &nbsp; 50123840 &nbsp;java.util.Hashtable<br><br>&nbsp; 11: &nbsp; &nbsp; &nbsp; &nbsp;783094 &nbsp; &nbsp; &nbsp; 50118016 &nbsp;java.lang.ref.Finalizer<br><br>&nbsp; 12: &nbsp; &nbsp; &nbsp; &nbsp;287243 &nbsp; &nbsp; &nbsp; 36086720 &nbsp;[Ljava.lang.Object;<br><br>&nbsp; 13: &nbsp; &nbsp; &nbsp; &nbsp;263376 &nbsp; &nbsp; &nbsp; 33712128 &nbsp;org.apache.commons.pool.impl.GenericObjectPool<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><strong>jstat</strong></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jstat -gccause 31169 60000 1000<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>(sweep 1,2) (Eden) (Old) (Perm) (Young GC, GCTime)(Full GC, GCTime)</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>&nbsp; S0 &nbsp; &nbsp; &nbsp; &nbsp; S1 &nbsp; &nbsp; E &nbsp; &nbsp; &nbsp; &nbsp; O &nbsp; &nbsp; &nbsp; &nbsp; P &nbsp; &nbsp; YGC &nbsp; &nbsp; YGCT &nbsp; &nbsp; FGC &nbsp; &nbsp;FGCT &nbsp; &nbsp; &nbsp;GCT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LGCC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GCC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp;48.80 &nbsp; 0.00 &nbsp;68.94 &nbsp;69.55 &nbsp;48.86 &nbsp;30202 &nbsp;725.319 51835 5083.298 5808.616 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp;47.98 &nbsp; 0.00 &nbsp;37.47 &nbsp;69.61 &nbsp;48.86 &nbsp;30206 &nbsp;725.385 51835 5083.298 5808.682 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp;50.73 &nbsp; 0.00 &nbsp;51.72 &nbsp;69.65 &nbsp;48.86 &nbsp;30210 &nbsp;725.459 51835 5083.298 5808.757 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp; 0.00 &nbsp;50.02 &nbsp;82.67 &nbsp;69.60 &nbsp;48.84 &nbsp;30213 &nbsp;725.508 51836 5091.572 5817.081 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jstat -gcutil $pid</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>&nbsp; S0 &nbsp; &nbsp; &nbsp; &nbsp; S1 &nbsp; &nbsp; E &nbsp; &nbsp; &nbsp; &nbsp; O &nbsp; &nbsp; &nbsp; P &nbsp; &nbsp; &nbsp; YGC &nbsp; &nbsp; YGCT &nbsp; &nbsp;FGC &nbsp; &nbsp;FGCT &nbsp; &nbsp; GCT &nbsp;&nbsp;<br><br>&nbsp;74.79 &nbsp; 0.00 &nbsp;95.15 &nbsp; 0.86 &nbsp;37.35 &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp;0.112 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;0.000 &nbsp; &nbsp; &nbsp;0.112<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>O = old occupied</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>YGC = young gc time ( new part )</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>YGCT = young gc total cost time</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>FGC = full gc time ( old part )</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>FGCT = full gc total cost time</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>GCT = all gc cost time</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px"></span></p><br><p><strong>jvisualvm</strong></p><br><p>window下启动远程监控，并在被监控服务端，启动jstatd服务。</p><br><p><br><br></p><br><p><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px">创建安全策略文件，并命名为jstatd.all.policy<br style="line-height:25px"><br>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {<br style="line-height:25px"><br>&nbsp;&nbsp;&nbsp; permission java.security.AllPermission;<br style="line-height:25px"><br>};</span><br><br></p><br><p><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px"><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px">jstatd -J-Djava.security.policy=jstatd.all.policy -p 8080 &amp;</span></span></p><br><br><br><strong>======================== Tunning =================</strong></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>典型配置：</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><pre>-server -Xmx2g -Xms2g -Xmn512m -XX:PermSize=128m -Xss256k -XX:&#43;DisableExplicitGC -XX:&#43;UseConcMarkSweepGC -XX:&#43;UseParNewGC -XX:&#43;CMSParallelRemarkEnabled -XX:&#43;UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:&#43;UseFastAccessorMethods -XX:&#43;UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true<br></pre><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><a target="_blank" href="http://java.sun.com/performance/reference/whitepapers/tuning.html">http://java.sun.com/performance/reference/whitepapers/tuning.html</a><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><a target="_blank" href="http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html">http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html</a><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>&#43;AggressiveOpts 激进优化，默认开启，使用java新特性优化</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>1. 默认使用串行收集器， 单个cpu时适用</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>2. 吞吐收集器（throughput collector）：命令行参数：-XX:&#43;UseParallelGC。在新生代使用并行清除收集策略，在旧生代和默认收集器相同。</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>适用：a、拥有2个以上cpu， b、临时对象较多的程序</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><span style="font-family:Arial,Verdana,sans-serif">-XX:ParallelGCThreads 并行收集线程数量，最好和cpu数量相当</span><br><br><br><br>3. 并发收集器（concurrent low pause collector）：命令行参数：-XX:&#43;UseConcMarkSweepGC。在旧生代使用并发收集策略，大部分收集工作都是和应用并发进行的，在进行收集的时候，应用的暂停时间很短。默认配套打开 -XX:&#43;UseParNewGC，会在新生代使用并行复制收集。</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>适用：a、拥有多个cpu， b、老对象较多的程序</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>如果使用了UseParNewGC，那么同时使用CMSParallelRemarkEnabled参数可以降低标识暂停</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:&#43;UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片<br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:&#43;UseFastAccessorMethods 原始类型的快速优化</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:SurvivorRatio 新生区中，eden&amp;survivor的比例，设置为8</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:TargetSurvivorRatio 生存区需要做垃圾回收的比例&#20540;，默认为50%，设置高些可以更好的利用该区</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><img alt="" src="http://img.my.csdn.net/uploads/201207/09/1341820867_5296.gif"><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>各个垃圾收集器之间的区别：</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><a target="_blank" href="http://www.javaperformancetuning.com/news/qotm026.shtml">http://www.javaperformancetuning.com/news/qotm026.shtml</a><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>新生代，单独区域单独收集，不会影响老生代，因为区域小，且允许漏收集，采用复制清除的方法，更快。</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br></div><br><span style="font-family:Arial,'Liberation Sans','DejaVu Sans',sans-serif; font-size:14px; line-height:18px; border-collapse:collapse"></span><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>The&nbsp;<span style="font-size:14px; padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px; padding-left:0px; padding-right:0px; border-top-width:0px; border-bottom-width:0px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><em>(original)<br> copying collector</em></span>&nbsp;(Enabled by default). When this collector kicks in, all application threads are stopped, and the copying collection proceeds using one thread (which means only one CPU even if on a multi-CPU machine). This is known as a stop-the-world<br> collection, because basically the JVM pauses everything else until the collection is completed.</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>The&nbsp;<span style="font-size:14px; padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px; padding-left:0px; padding-right:0px; border-top-width:0px; border-bottom-width:0px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><em>parallel<br> copying collector</em></span>&nbsp;(Enabled using -XX:&#43;UseParNewGC). Like the original copying collector, this is a stop-the-world collector. However this collector parallelizes the copying collection over multiple threads, which is more efficient than the original<br> single-thread copying collector for multi-CPU machines (though not for single-CPU machines). This algorithm potentially speeds up young generation collection by a factor equal to the number of CPUs available, when compared to the original singly-threaded copying<br> collector.</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>The&nbsp;<span style="font-size:14px; padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px; padding-left:0px; padding-right:0px; border-top-width:0px; border-bottom-width:0px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><em>parallel<br> scavenge collector</em></span>&nbsp;(Enabled using -XX:UseParallelGC). This is like the previous parallel copying collector, but the algorithm is tuned for gigabyte heaps (over 10GB) on multi-CPU machines. This collection algorithm is designed to maximize throughput<br> while minimizing pauses. It has an optional adaptive tuning policy which will automatically resize heap spaces. If you use this collector, you can only use the the original mark-sweep collector in the old generation (i.e. the newer old generation concurrent<br> collector cannot work with this young generation collector).</p><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br></p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>UserParallelGC使用了更高效的算法，用于处理大规模内存&gt;10G场景，提供了大吞吐量功能。但是，同时在老生代，只能使用串行的标记清除方法。</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>老生代，必须做fullgc，必须从root开始全面标识收集。</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br></p><br><ul style="font-family:Simsun; font-size:16px"><br><li>The&nbsp;<em>(original) mark-sweep collector</em>&nbsp;(Enabled by default). This uses a stop-the-world mark-and-sweep collection algorithm. The collector is single-threaded, the entire JVM is paused and the collector uses only one CPU until completed.</li><li>The&nbsp;<em>concurrent collector</em>&nbsp;(Enabled using -XX:&#43;UseConcMarkSweepGC). This collector tries to allow application processing to continue as much as possible during the collection. Splitting the collection into six phases described shortly, four are concurrent<br> while two are stop-the-world:<br><br>1. the initial-mark phase (stop-the-world, snapshot the old generation so that we can run most of the rest of the collection concurrent to the application threads);<br><br>2. the mark phase (concurrent, mark the live objects traversing the object graph from the roots);<br><br>3. the pre-cleaning phase (concurrent);<br><br>4. the re-mark phase (stop-the-world, another snapshot to capture any changes to live objects since the collection started);<br><br>5. the sweep phase (concurrent, recycles memory by clearing unreferenced objects);<br><br>6. the reset phase (concurrent).<br><br>If &quot;the rate of creation&quot; of objects is too high, and the concurrent collector is not able to keep up with the concurrent collection, it falls back to the traditional mark-sweep collector.</li><li>The&nbsp;<em>incremental collector</em>&nbsp;(Enabled using -Xincgc). The incremental collector uses a &quot;train&quot; algorithm to collect small portions of the old generation at a time. This collector has higher overheads than the mark-sweep collector, but because small<br> numbers of objects are collected each time, the (stop-the-world) garbage collection pause is minimized at the cost of total garbage collection taking longer. The &quot;train&quot; algorithm does not guarantee a maximum pause time, but pause times are typically less<br> than ten milliseconds.</li></ul><br><br><br><p></p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br><br><br></p><br></div><br></div>

<p></p></div><p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/17/clover-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/17/clover-01/" itemprop="url">转载:clover分布式任务调度系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-17T17:36:39+08:00">
                2017-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content"><br><br><p><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong>1、clover</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>分布式调度介绍</strong></span></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">c</span><span style="font-family:Arial">lover</span><span style="font-family:宋体">分布式任务调度是完全使用</span><span style="font-family:Arial">Java</span><span style="font-family:宋体">技术自主开发</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">特点如下</span><span style="font-family:Arial">:</span><span style="font-family:Arial"></span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">1</span><span style="font-family:宋体">、防</span><span style="font-family:宋体">单点故障</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">2</span><span style="font-family:宋体">、</span><span style="font-family:Arial">job</span><span style="font-family:宋体">可部署多台</span><span style="font-family:宋体">，但任务调度</span><span style="font-family:宋体">时，只有一台</span><span style="font-family:宋体">参执行</span><span style="font-family:宋体">。如果一台下线，</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">clover</span><span style="font-family:宋体">选择其他已在</span><span style="font-family:Arial">zookeeper</span><span style="font-family:宋体">注册</span><span style="font-family:Arial">job</span><span style="font-family:宋体">来执行。</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">3</span><span style="font-family:宋体">、可</span><span style="font-family:宋体">管理</span><span style="font-family:宋体">监控程序 ，相关负责人的</span><span style="font-family:Arial">job</span><span style="font-family:宋体">不可用会发送邮件通知</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">4</span><span style="font-family:宋体">、提供</span><span style="font-family:宋体">管理后台，</span><span style="font-family:宋体">可手动停止任务，设置任务执行</span><span style="font-family:宋体">频率、恢复策</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">略。人工干预指定</span><span style="font-family:宋体">哪些</span><span style="font-family:Arial">job</span><span style="font-family:宋体">来</span><span style="font-family:宋体">工作，可</span><span style="font-family:宋体">查看任务执行进度、任务执行</span><span style="font-family:宋体">失败时会收到</span><span style="font-family:宋体">报警并记录日志。</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">5</span><span style="font-family:宋体">、执行中的任务，但未执行完成，不会再次调度任务</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">6</span><span style="font-family:宋体">、支持灾难重现，</span><span style="font-family:Arial">server</span><span style="font-family:宋体">端不可用，但</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端注册</span><span style="font-family:Arial">job</span><span style="font-family:宋体">信息会存储到临时</span><span style="font-family:Arial">DB</span><span style="font-family:宋体">中，当</span><span style="font-family:Arial">server</span><span style="font-family:宋体">重启后立即去读临时</span><span style="font-family:Arial">DB</span><span style="font-family:宋体">并执行相应</span><span style="font-family:Arial">job</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">7</span><span style="font-family:宋体">、</span><span style="font-family:Arial">job</span><span style="font-family:宋体">支持</span><span style="font-family:Arial">LOCAL</span><span style="font-family:宋体">、</span><span style="font-family:Arial">REMOTE</span><span style="font-family:宋体">模式以及</span><span style="font-family:Arial">ADD</span><span style="font-family:宋体">、</span><span style="font-family:Arial">UPDATE</span><span style="font-family:宋体">、</span><span style="font-family:Arial">DELETE</span><span style="font-family:宋体">操作</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">8</span><span style="font-family:宋体">、支持动态创建</span><span style="font-family:Arial">job</span><span style="font-family:宋体">、</span><span style="font-family:Arial">spring</span><span style="font-family:宋体">配置文件和注解方式注册</span><span style="font-family:Arial">job</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">9</span><span style="font-family:宋体">、可以查询所有运行报错日志查询</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">10</span><span style="font-family:宋体">、管理后台可以创建、修改、删除</span><span style="font-family:Arial">job</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial"><br><br></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial"></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong>2、&nbsp;</strong></span><span style="font-family:微软雅黑"><strong>总体</strong></span><span style="font-family:微软雅黑"><strong>框架分析</strong></span></span></span><span style="font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong><br><br></strong></span></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203135721930?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203135740926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong>3、&nbsp;</strong></span><span style="font-family:微软雅黑"><strong>总体框架分析</strong></span><span style="font-family:微软雅黑"><strong>-</strong></span><span style="font-family:微软雅黑"><strong>系统流程图</strong></span></span></span><span style="font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong><br><br></strong></span></span></span></p><br><img src="http://img.blog.csdn.net/20150203135912753?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="http://img.blog.csdn.net/20150203135929128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong>4、&nbsp;</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>技术</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>-</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>项目结构</strong></span></span><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203140331474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong>5、&nbsp;</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>涉及技术</strong></span></span><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#ff0000"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">MongoDB</span><span style="font-family:宋体">集群</span><span style="font-family:Arial">:</span><span style="font-family:宋体">负责存储</span><span style="font-family:Arial">clover</span><span style="font-family:宋体">所有数据信息，当初想考虑使用</span><span style="font-family:Arial">LevelDB</span><span style="font-family:宋体">，但不方便管理，</span><span style="font-family:Arial">Redis</span><span style="font-family:宋体">完全放弃了，理由是对于频繁写操作性能下降、总有连接超时</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">ZK</span><span style="font-family:宋体">集群</span><span style="font-family:Arial">:</span><span style="font-family:宋体">负责</span><span style="font-family:Arial">server</span><span style="font-family:宋体">和</span><span style="font-family:Arial">client</span><span style="font-family:宋体">启动注册信息，所有</span><span style="font-family:Arial">server</span><span style="font-family:宋体">、</span><span style="font-family:Arial">client</span><span style="font-family:宋体">信息都是有读写操作权限，目的防止被他人或程序修改</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">ZeroMQ</span><span style="font-family:Arial">:</span><span style="font-family:宋体">负责</span><span style="font-family:Arial">server</span><span style="font-family:宋体">和</span><span style="font-family:Arial">client</span><span style="font-family:宋体">消息通信</span><span style="font-family:Arial">&amp;</span><span style="font-family:宋体">后台管理页面创建、修改、删除</span><span style="font-family:Arial">job</span><span style="font-family:宋体">通信</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">使用</span><span style="font-family:Arial">ZeroMQ</span><span style="font-family:宋体">的理由</span><span style="font-family:Arial">:</span><span style="font-family:宋体">就是快，就是那么任性，流式技术框架</span><span style="font-family:Arial">storm</span><span style="font-family:宋体">使用，未来会考虑使用</span><span style="font-family:Arial">Spark</span><span style="font-family:宋体">的</span><span style="font-family:Arial">akka</span><span style="font-family:宋体">消息通信框架</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Monitor:</span><span style="font-family:宋体">负责死亡心跳检测，监控</span><span style="font-family:Arial">server</span><span style="font-family:宋体">、</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端，使用</span><span style="font-family:Arial">Java<br> Timer</span><span style="font-family:宋体">实现</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">后台管理页面</span><span style="font-family:Arial">:bootstrap &#43;</span><span style="font-family:Arial">jsp&#43;highcharts</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Spring:</span><span style="font-family:宋体">重新定义</span><span style="font-family:Arial">spring</span><span style="font-family:宋体">的</span><span style="font-family:Arial">xsd</span><span style="font-family:宋体">标签以及</span><span style="font-family:Arial">Annotation</span><span style="font-family:宋体">注解方式，注册</span><span style="font-family:Arial">job</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Snappy:</span><span style="font-family:宋体">通信消息压缩方式，减少网络数据传输带宽</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Curator</span><span style="font-family:宋体">：监听</span><span style="font-family:Arial">ZK</span><span style="font-family:宋体">数据包变更，并保持到内存中，方便程序快速获取</span><span style="font-family:Arial">server</span><span style="font-family:宋体">和</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端信息</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Quartz</span><span style="font-family:宋体">：基于</span><span style="font-family:Arial">quartz</span><span style="font-family:宋体">重写底层定时任务调度，考虑处理各种任务执行规则问题，而选择</span><span style="font-family:Arial">quartz</span><span style="font-family:宋体">来调度任务</span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><br><br></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ff0000">6、clover使用</span></strong></span><br><br></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203140708147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><span style="font-size:24px"><span style="font-family:微软雅黑"><strong>6.3、&nbsp;</strong></span><span style="font-family:微软雅黑"><strong>项目中定义</strong></span><span style="font-family:微软雅黑"><strong>Client</strong></span><span style="font-family:微软雅黑"><strong>JobClass</strong></span></span><br><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141102023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><span style="font-weight:bold"><span style="font-size:24px"><span style="font-family:微软雅黑"><strong><span style="line-height:40px">6.4</span><span style="line-height:150%">、&nbsp;</span></strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>非</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>spring</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>项目使用</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>-</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>启动</strong></span><span style="line-height:150%; font-family:微软雅黑"><strong>clover-client</strong></span></span><br><br></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141252253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141331545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><img src="http://img.blog.csdn.net/20150203141429733?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141515971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="font-family:微软雅黑; font-size:27px; line-height:40px"><strong>6.</strong></span>5、&nbsp;</strong></span><span style="font-family:微软雅黑"><strong>非</strong></span><span style="font-family:微软雅黑"><strong>spring</strong></span><span style="font-family:微软雅黑"><strong>项目</strong></span><span style="font-family:微软雅黑"><strong>使用</strong></span><span style="font-family:微软雅黑"><strong>-</strong></span><span style="font-family:微软雅黑"><strong>启动</strong></span><span style="font-family:微软雅黑"><strong>job</strong></span><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203141826952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong></strong></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑; font-size:27px; line-height:40px"><strong>6.</strong></span>6、 spring</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>项目</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>使用</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>-</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>启动</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>clover-client</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203142007224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p><img src="http://img.blog.csdn.net/20150203142101704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><br><p><br><br></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong></strong></span></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:24px"><span style="font-family:微软雅黑"><strong><span style="font-family:微软雅黑; line-height:40px"><strong>6.</strong></span>7、spring</strong></span><span style="font-family:微软雅黑"><strong>项目使用</strong></span><span style="font-family:微软雅黑"><strong>-</strong></span><span style="font-family:微软雅黑"><strong>启动</strong></span><span style="font-family:微软雅黑"><strong>clover-client</strong></span></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203142212560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203142358000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="font-family:微软雅黑; font-size:27px; font-weight:bold"><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203142635482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="color:#ff0000">7、后台管理页面</span></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="color:#ff0000"><br><br></span></strong></span></strong></span></p><br><p><span style="font-family:微软雅黑; color:#ff9900"><span style="font-size:27px"><strong>7.1、主页面</strong></span></span></p><br><p><span style="font-family:微软雅黑"><span style="font-size:27px"><strong><img src="http://img.blog.csdn.net/20150203142908456?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></span></p><br><p><span style="font-family:微软雅黑"><span style="font-size:27px"><strong><br><br></strong></span></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="color:#ffcc66">7.2、zk管理页面</span></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143040590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><span style="color:#ff9900">7.3、job管理页面</span></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143138321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="font-family:微软雅黑"><strong><br><br></strong></span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ffcc66">7.4、联系人管理页面</span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143230055?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ffcc33">7.5、日志管理页面</span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143333563?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ff0000">8、性能分析</span></strong></span></p><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><span style="color:#ff0000"><br><br></span></strong></span></p><br><p><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.1、</strong></span><span style="line-height:150%; font-family:微软雅黑; font-size:20pt"><strong>clover server</strong></span><span style="line-height:150%; font-family:微软雅黑; font-size:20pt"><strong>压力</strong></span></span></p><br><p><span style="line-height:150%; font-family:微软雅黑; font-size:20pt"><strong></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Server</span><span style="font-family:宋体">端只负责任务定时执行和分发到指定</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端，由于使用了</span><span style="font-family:Arial">quartz</span><span style="font-family:宋体">，</span><span style="font-family:Arial">server</span><span style="font-family:宋体">端在定时轮训执行任务以及解析定时任务时间方面，对性能压力减少了很多</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Server</span><span style="font-family:宋体">端分发消息，使用</span><span style="font-family:Arial">zeromq</span><span style="font-family:Arial"></span><span style="font-family:宋体">非阻塞方式发送消息给指定</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端，目前部署两台服务器完全胜任所有性能压力</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Server</span><span style="font-family:宋体">端支持集群部署，每次</span><span style="font-family:Arial">client</span><span style="font-family:宋体">发送消息随机</span><span style="font-family:Arial">Hash</span><span style="font-family:宋体">到某一台</span><span style="font-family:Arial">server</span><span style="font-family:宋体">服务器</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体">当所有的</span><span style="font-family:Arial">server</span><span style="font-family:宋体">都不可用，为了不影响</span><span style="font-family:Arial">client</span><span style="font-family:宋体">的使用，将会把</span><span style="font-family:Arial">clientjob</span><span style="font-family:宋体">信息存储到临时</span><span style="font-family:Arial">DB</span><span style="font-family:宋体">中，此刻还会发送邮件报警给相关</span><span style="font-family:Arial">server</span><span style="font-family:宋体">负责人，</span><span style="font-family:Arial">server</span><span style="font-family:宋体">立即重启后，会把所有临时</span><span style="font-family:Arial">DB</span><span style="font-family:宋体">中数据读取并执行，此刻</span><span style="font-family:Arial">client</span><span style="font-family:宋体">可以继续收到消息并执行业务逻辑</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:Arial">Server</span><span style="font-family:宋体">端监听所有</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端</span><span style="font-family:Arial">ZK</span><span style="font-family:宋体">消息后放入内存中，当</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端</span><span style="font-family:Arial">zk</span><span style="font-family:宋体">数据信息发送变化后，才修改内存数据，这样可以提供</span><span style="font-family:Arial">server</span><span style="font-family:宋体">端获取</span><span style="font-family:Arial">client</span><span style="font-family:宋体">端</span><span style="font-family:Arial">zk</span><span style="font-family:宋体">信息速度，也减轻了</span><span style="font-family:Arial">zk</span><span style="font-family:宋体">不断被访问的压力</span><span style="font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"><br><br></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>2</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>zk</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>压力</strong></span></span><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:24pt; font-family:宋体">俺真心没啥压力，俺是一个大集群，你们这些大爷和土豪就每次启动容器时候将初始化信息放到我这边，而当你们数据信息发生变化（修改节点数据、节点数据不可用），监听者才会访问俺，其实想想你们没事 肯定不会经常变更数据滴，</span><span style="font-size:24pt; font-family:Arial">(<em>^__^</em>)</span><span style="font-size:24pt; font-family:宋体">，不过<br> 当你们挂了 或者关闭应用程序时候，我会把你们全部删除滴，这就会浪费伦家点时间和力气吧</span><span style="font-size:24pt; font-family:Arial"></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:24pt; font-family:宋体"><br><br></span></p><br><img src="" alt=""><br><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>3</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>MongoDB</strong></span></span><span style="font-size:20pt; font-family:微软雅黑"><strong></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143542539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>4</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>zeromq</strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><img src="http://img.blog.csdn.net/20150203143631465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></strong></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></p><br><p style="margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="font-family:宋体"></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong>8.</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>5</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>zeromq</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong><br> push/pull</strong></span><span style="font-size:20pt; font-family:微软雅黑"><strong>模式</strong></span></span></p><br><p style="line-height:150%; margin-top:0pt; margin-bottom:0pt; direction:ltr; unicode-bidi:embed; vertical-align:baseline"><br><span style="color:#3333ff"><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></span></p><br><img src="http://img.blog.csdn.net/20150203143700529?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Rhcmtfc3VtbWVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br><p><span style="font-size:20pt; font-family:微软雅黑"><strong><br><br></strong></span></p><br><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/16/subscribe-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/subscribe-02/" itemprop="url">转载:简述观察者(订阅/发布)模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T11:53:57+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content"><br><br><h1><span style="font-size:24px">1.定义</span></h1><br><h1><span style="font-size:18px; font-weight:normal">&nbsp; &nbsp; 定义对象间的一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</span></h1><br><div><span style="font-size:24px"><strong>2.解决的问题</strong></span></div><br><div><span style="font-size:24px"><strong>&nbsp; &nbsp;&nbsp;</strong></span><span style="font-size:18px">现状：有时我们会将一个系统分割成一系列相互协作的类，但是这样会有一个副作用—需要维护相关对象间的一致性。这样的话我们为了维持一致性而使得各个类之间紧密耦合，导致可重用性的降低，会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</span></div><br><div><span style="font-size:18px">&nbsp; &nbsp; &nbsp;观察者模式使得任意树木的观察者不必知道彼此的存在，且主题发生变化时都可以得到主题的通知，而同步改变状态。是一种松散耦合，且有更好的可重用性。</span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:24px"><span style="line-height:18px"><strong>3.模式的组成结构</strong></span></span></div><br><div>&nbsp; &nbsp; &nbsp;<span style="font-size:18px">&nbsp; &nbsp;抽象主题（Subject）：它把所有观察者对象的引用保存到一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</span><br><br></div><br><div><span style="font-size:18px">&nbsp; &nbsp; &nbsp; 具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。<br><br></span></div><br><div><span style="font-size:18px">&nbsp; &nbsp; &nbsp;&nbsp;抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><strong>&nbsp;</strong>&nbsp; 具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><strong><span style="font-size:24px">4.模式的类图</span></strong></span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><strong><span style="font-size:24px"><br><br></span></strong></span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px">&nbsp; 由于自己还不会画类图，就网上找了一张</span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><img src="http://img.blog.csdn.net/20160109191634902?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><strong><span style="font-size:24px">5.具体实现代码</span></strong></span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><span style="font-size:14px">5.1.<span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><strong>IPrettyGirl.java&nbsp;</strong></span></span></span></div><br><div><pre name="code" class="java">package com.example.design.observer;<br>/<em>
 </em> 抽象主题角色<br> <em> 类型是接口或者抽象类
 </em>/<br>public interface IPrettyGirl {<br>    public void addObservers(IObserver observers);//添加观察者<br><br>    public void deleteObservers(IObserver observers);//删除观察者<br><br>    public void notifyAllObservers(String msg);//通知所有的观察者<br>}<br>//public abstract class IPrettyGirl{<br>//    public abstract void addObservers(IObserver observers);//添加观察者<br>//<br>//    public abstract void deleteObservers(IObserver observers);//删除观察者<br>//<br>//    public abstract void notifyAllObservers(String msg);//通知所有的观察者<br>//<br>//}</pre><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px"><span style="font-size:14px">5.2.<span style="background-color:rgb(240,240,240)">IObserver.java</span></span></span></span></span></div><br><div><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px"><span style="font-size:14px"><span style="background-color:rgb(240,240,240)"></span></span></span></span></span><pre name="code" class="java">package com.example.design.observer;<br>/<strong><br> <em> 
 </em> 抽象观察者<br> <em>
 </em>/<br>public interface IObserver {<br>   public void UpdateMsg(String msg);<br>}</strong></pre></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px">5.3&nbsp;Angelababy.java</span><br><br></span></span></span></span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px"></span></span></span></span></span><pre name="code" class="java">package com.example.design.observer;<br><br>import java.util.ArrayList;<br>import java.util.List;<br><br>/<em>
 </em> 具体主题<br> <em> 这里选取众多屌丝追女神的例子
 </em>/<br>public class Angelababy implements IPrettyGirl {<br><br>    // 观察者集合<br>    private List&lt;IObserver&gt; mList = new ArrayList&lt;IObserver&gt;();// 注意这里集合的泛型用的是接口类型<br><br>    public void addObservers(IObserver observers) {<br>        mList.add(observers);<br>    }<br><br>    @Override<br>    public void deleteObservers(IObserver observers) {<br>        mList.remove(observers);<br>    }<br><br>    @Override<br>    public void notifyAllObservers(String msg) {<br>        for (IObserver list : mList) {<br>            list.UpdateMsg(msg);<br>        }<br>    }<br><br>}</pre></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px">5.4.</span><span style="font-family:Arial; font-size:14px; line-height:26px; background-color:rgb(240,240,240)">Observers.java</span><br><br></span></span></span></span></span></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px; background-color:rgb(240,240,240)"></span></span></span></span></span></span><pre name="code" class="java">package com.example.design.observer;<br>/<br> <em> 
 </em> 具体观察者<br> <em> 屌丝男一 
 </em>/<br>public class Observers implements IObserver {<br>    private String name;<br><br>    public  Observers(String name) {<br>        this.name = name;<br>    }<br><br>    @Override<br>    public void UpdateMsg(String msg) {<br>        // TODO 自动生成的方法存根<br>        if (&quot;我不开心&quot;.equals(msg)) {<br>            System.out.println(name+&quot;说： 多喝热水&quot;);<br>        }<br>    }<br><br>}</pre></div><br><div><span style="font-family:Consolas,Courier New,Courier,mono,serif; font-size:18px; line-height:18px"><span style="font-family:Consolas,'Courier New',Courier,mono,serif; line-height:18px; background-color:rgb(245,250,226)"><span style="font-family:Arial; line-height:26px; font-size:18px"><span style="background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:Arial; font-size:14px; line-height:26px; background-color:rgb(240,240,240)"><span style="font-family:Arial; font-size:14px; line-height:26px">然后多写几个观察者(屌丝)类，这里就不贴代码了，同4。</span></span></span></span></span></span></span><br><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"><br></p><br><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; line-height:25px"><br><span style="font-size:14px">5.5 测试主方法</span></p><br><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-size:14px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; line-height:25px"><br></p><br><pre name="code" class="java">package com.example.design.observer;<br><br>/<em>*
 </em> —-观察者模式—-<br> <em> 
 </em>/<br>public class TestMain {<br><br>    public static void main(String[] args) {<br>        // TODO 自动生成的方法存根<br>        Observers observers1 = new Observers(&quot;王大锤&quot;);<br>        Observers2 observers2 = new Observers2(&quot;黄晓明&quot;);<br>        Observers3 observers3 = new Observers3(&quot;郑恺&quot;);<br>        Observers4 observers4 = new Observers4(&quot;邓超&quot;);<br><br>        Angelababy angelababy = new Angelababy();<br><br>        // 注册添加观察者<br>        angelababy.addObservers(observers1);<br>        angelababy.addObservers(observers2);<br>        angelababy.addObservers(observers3);<br>        angelababy.addObservers(observers4);<br><br>        // 发出通知消息<br>        angelababy.notifyAllObservers(&quot;我不开心&quot;);<br>        //删除观察者<br>        angelababy.deleteObservers(observers1);<br>        System.out.println(&quot;———————&quot;);<br>        angelababy.notifyAllObservers(&quot;我不开心&quot;);<br>    }<br>}</pre><span style="font-size:14px">5.6.输出结果</span><br><p></p><br><p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-size:14px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; line-height:25px"><br></p><br><pre name="code" class="java">王大锤说： 多喝热水<br>黄晓明说：多喝热水,么么哒<br>郑恺说：走，带你去看电影<br>邓超说：走，带你去吃缙云烧饼<br>———————<br>黄晓明说：多喝热水,么么哒<br>郑恺说：走，带你去看电影<br>邓超说：走，带你去吃缙云烧饼</pre><br><p><span style="font-size:18px">6.模式的总结</span></p><br><p><span style="font-size:18px">&nbsp; &nbsp;6.1 优点<br><br>　　 &nbsp;观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。<br><br>&nbsp; &nbsp;6.2 缺点<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。<br><br>&nbsp; &nbsp;6.3 适用场景<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。<br><br><span style="color:rgb(255,0,0)">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。<br><br></span></p><br><p><strong><span style="font-size:18px; color:#ff0000">如果上面有什么不妥的地方，欢迎留言指正</span></strong></p><br></div>

<p></p></div><p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/16/subscribe-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/subscribe-01/" itemprop="url">转载:订阅发布模式(Subscribe/Publish)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T11:19:45+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content"><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 订阅发布模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。</p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相应对象间的一致性，这样会给维护、扩展和重用都带来不便。当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变时，就可以使用订阅发布模式了。</p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个抽象模型有两个方面，其中一方面依赖于另一方面，这时订阅发布模式可以将这两者封装在独立的对象中，使它们各自独立地改变和复用。订阅发布模式所做的工作其实就是在解耦合。让耦合的双方都依赖于抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。</p><br>    <p>在我们日常写程序时，经常遇到下面这种情况：</p><br>    <blockquote><br>    <p>public void 有告警信息产生() <br>{ <br>&nbsp;&nbsp;&nbsp; 刷新界面(); <br>&nbsp;&nbsp;&nbsp; 更新数据库(); <br>&nbsp;&nbsp;&nbsp; 给管理员发Mail(); <br>&nbsp;&nbsp;&nbsp; &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; <br>}</p><br>    </blockquote><br>    <p>当有告警信息产生时，依次要去执行：刷新界面()、更新数据库()、给管理员发Mail()等操作。表面上看代码写得很工整，其实这里面问题多多：</p><br>    <ul><br>    <li>首先，这完全是面向过程开发，根本不适合大型项目。 </li><br>    <li>第二，代码维护量太大。设想一下，如果产生告警后要执行10多个操作，那这将是个多么大，多少复杂的类呀，时间一长，可能连开发者自己都不知道如何去维护了。 </li><br>    <li>第三，扩展性差。如果产生告警后，要增加一个声音提示()功能，怎么办呢？没错，只能加在有告警信息产生()这个函数中，这样一来，就违反了&ldquo;开放-关闭原则&rdquo;。而且修改了原有的函数，那么在测试时，除了要测新增功能外，还要做原功能的回归测试；在一个大型项目中，做一次回归测试可能要花费大约两周左右的时间，而且前提是新增功能没有影响原来功能及产生新的bug。 </li><br>    </ul><br>    <p>那么如何把有告警信息产生()函数同其他函数进行解耦合呢？别着急，下面就介绍今天的主角—-订阅发布模式。见下图：</p><br>    <p><img style="display: inline; border: 0px;" src="http://hi.csdn.net/attachment/201001/22/32139_1264124155jcyK.png" alt="订阅发布模式1" width="313" height="243"> </p><br>    <p>上面的流程就是对有告警信息产生()这个函数的描述。我们要做的，就是把产生告警和它需要通知的事件进行解耦，让它们之间没有相互依赖的关系，解耦合图如下：</p><br>    <p><img style="display: inline; border: 0px;" src="http://hi.csdn.net/attachment/201001/22/32139_12641241575302.png" alt="订阅发布模式2" width="521" height="207"> </p><br>    <p>事件触发者被抽象出来，称为消息发布者，即图中的P。事件接受都被抽象出来，称为消息订阅者，即图中的S。P与S之间通过S.P（即订阅器）连接。这样就实现了P与S的解耦。首先，P就把消息发送到指定的订阅器上，从始至终，它并不知道也不关心要把消息发向哪个S。S如果想接收消息，就要向订阅器进行订阅，订阅成功后，S就可以接收来自S.P的消息了，从始至终，S并不知道也不关心消息来源于哪个具体的P。同理，S还可以向S.P进行退订操作，成功退订后，S就无法接收到来自指定S.P的消息了。这样就完美的解决了P与S之间的解耦。</p><br>    <p>等等，好像还有一个问题。从图上看，虽然P与S之间完成了解耦，但是P与S.P，S与S.P之间不就又耦合上了吗？其实这个问题好解决，想想我们上篇的<a href="http://blog.csdn.net/tjvictor/archive/2010/01/20/5218401.aspx" target="_blank"><span style="color: #006bad;">装饰模式</span></a>是怎么解耦的？对，就接口。这里我们同样使用接口来解决P与S.P和S与S.P之间的解耦，同时，使用delegate来解决多订阅多发布的机制。</p><br>    <p>下面给出实现代码。由于订阅发布模式涉及P, S.P和S三部份内容，所以代码比较多，也比较长。请大家耐心阅读。</p><br>    <p>首先，为了实现P与S.P, S与S.P之间的解耦，我们需要定义两个接口文件</p><br>    <blockquote><br>    <p>ISubscribe.cs<br>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; //定义订阅事件<br>&nbsp;&nbsp;&nbsp; public delegate void SubscribeHandle(string str);<br>&nbsp;&nbsp;&nbsp; //定义订阅接口<br>&nbsp;&nbsp;&nbsp; public interface ISubscribe<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event SubscribeHandle SubscribeEvent;<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    <blockquote><br>    <p>IPublish<br>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; //定义发布事件<br>&nbsp;&nbsp;&nbsp; public delegate void PublishHandle(string str);<br>&nbsp;&nbsp;&nbsp; //定义发布接口<br>&nbsp;&nbsp;&nbsp; public interface IPublish<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event PublishHandle PublishEvent; </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Notify(string str);<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    <p>然后我们来设计订阅器。显然订阅器要实现双向解耦，就一定要继承上面两个接口，这也是我为什么用接口不用抽象类的原因(类是单继承)。</p><br>    <code><br>    <blockquote><br>    <p>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; public class SubPubComponet : ISubscribe, IPublish<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private string _subName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public SubPubComponet(string subName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._subName = subName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PublishEvent += new PublishHandle(Notify);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region ISubscribe Members<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event SubscribeHandle subscribeEvent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event SubscribeHandle ISubscribe.SubscribeEvent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add { subscribeEvent += value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove { subscribeEvent -= value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region IPublish Members<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public PublishHandle PublishEvent; </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event PublishHandle IPublish.PublishEvent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add { PublishEvent += value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove { PublishEvent -= value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Notify(string str)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (subscribeEvent != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscribeEvent.Invoke(string.Format(“消息来源{0}:消息内容:{1}”, _subName, str));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    </code><br>    <p>接下来是设计订阅者S。S类中使用了ISubscribe来与S.P进行解耦。代码如下： </p><br>    <code><br>    <blockquote><br>    <p>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; public class Subscriber<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private string _subscriberName; </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Subscriber(string subscriberName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._subscriberName = subscriberName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ISubscribe AddSubscribe { set { value.SubscribeEvent += Show; } }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ISubscribe RemoveSubscribe { set { value.SubscribeEvent -= Show; } } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void Show(string str)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(string.Format(“我是{0}，我收到订阅的消息是:{1}”, _subscriberName, str));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    </code><br>    <p>最后是发布者P，继承IPublish来对S.P发布消息通知。 </p><br>    <code><br>    <blockquote><br>    <p>namespace TJVictor.DesignPattern.SubscribePublish<br>{<br>&nbsp;&nbsp;&nbsp; public class Publisher:IPublish<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private string _publisherName; </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Publisher(string publisherName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._publisherName = publisherName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private event PublishHandle PublishEvent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event PublishHandle IPublish.PublishEvent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add { PublishEvent += value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove { PublishEvent -= value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </p><br>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Notify(string str)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PublishEvent != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PublishEvent.Invoke(string.Format(“我是{0},我发布{1}消息”, _publisherName, str));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</p><br>    </blockquote><br>    </code><br>    <p>至此，一个简单的订阅发布模式已经完成了。下面是调用代码及运行结果。调用代码模拟了图2中的订阅发布关系，大家可以从代码，运行结果和示例图三方面对照着看。</p><br>    <code><br>    <blockquote><br>    <p>#region TJVictor.DesignPattern.SubscribePublish<br>//新建两个订阅器<br>SubPubComponet subPubComponet1 = new SubPubComponet(“订阅器1”);<br>SubPubComponet subPubComponet2 = new SubPubComponet(“订阅器2”);<br>//新建两个发布者<br>IPublish publisher1 = new Publisher(“TJVictor1”);<br>IPublish publisher2 = new Publisher(“TJVictor2”);<br>//与订阅器关联<br>publisher1.PublishEvent += subPubComponet1.PublishEvent;<br>publisher1.PublishEvent += subPubComponet2.PublishEvent;<br>publisher2.PublishEvent += subPubComponet2.PublishEvent;<br>//新建两个订阅者<br>Subscriber s1 = new Subscriber(“订阅人1”);<br>Subscriber s2 = new Subscriber(“订阅人2”);<br>//进行订阅<br>s1.AddSubscribe = subPubComponet1;<br>s1.AddSubscribe = subPubComponet2;<br>s2.AddSubscribe = subPubComponet2;<br>//发布者发布消息<br>publisher1.Notify(“博客1”);<br>publisher2.Notify(“博客2”);<br>//发送结束符号<br>Console.WriteLine(“”.PadRight(50,’-‘));<br>//s1取消对订阅器2的订阅<br>s1.RemoveSubscribe = subPubComponet2;<br>//发布者发布消息<br>publisher1.Notify(“博客1”);<br>publisher2.Notify(“博客2”);<br>//发送结束符号<br>Console.WriteLine(“”.PadRight(50, ‘-‘));<br>#endregion </p><br>    <p>#region Console.ReadLine();<br>Console.ReadLine();<br>#endregion</p><br>    </blockquote><br>    </code><br>    <p>&nbsp;运行结果图：</p><br>    <p><img src="http://hi.csdn.net/attachment/201001/22/32139_12641261136vbM.png" alt="订阅发布模式3" width="740" height="210"></p><br>    <p>&nbsp;</p><br>    <p>&nbsp;</p><br>    <p>如需转载，请注明本文原创自CSDN TJVictor专栏：<a href="http://blog.csdn.net/tjvictor" target="_blank" rel="external"><span style="color: #006bad;">http://blog.csdn.net/tjvictor</span></a></p><br>    </div> 


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/16/aop-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/aop-01/" itemprop="url">转载:Java动态代理的两种实现方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T09:04:51+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="article_c"><br><br>&nbsp;AOP的拦截功能是由java中的动态代理来实现的。说白了，就是在目标类的基础上增加切面逻辑，生成增强的目标类（该切面逻辑或者在目标类函数执行之前，或者目标类函数执行之后，或者在目标类函数抛出异常时候执行。不同的切入时机对应不同的Interceptor的种类，如BeforeAdviseInterceptor，AfterAdviseInterceptor以及ThrowsAdviseInterceptor等）。<br><br><p><br><br></p><br><p>那么动态代理是如何实现将切面逻辑（advise）织入到目标类方法中去的呢？下面我们就来详细介绍并实现AOP中用到的两种动态代理。<br><br></p><br><p>AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。<span style="color:#FF0000">jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。</span>由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。。<br><br></p><br><h1>1、定义接口和实现</h1><br><p></p><br><pre name="code" class="java">package com.meituan.hyt.test3.service;<br><br><br>public interface UserService {<br>    public String getName(int id);<br><br>    public Integer getAge(int id);<br>}<br></pre><br><p></p><br><p><br><br></p><br><p></p><br><pre name="code" class="java">package com.meituan.hyt.test3.service.impl;<br><br>import com.meituan.hyt.test3.service.UserService;<br><br><br>public class UserServiceImpl implements UserService {<br>    @Override<br>    public String getName(int id) {<br>        System.out.println(&quot;——getName——&quot;);<br>        return &quot;Tom&quot;;<br>    }<br><br>    @Override<br>    public Integer getAge(int id) {<br>        System.out.println(&quot;——getAge——&quot;);<br>        return 10;<br>    }<br>}<br></pre><br><br><p></p><br><h1>2、jdk动态代理实现</h1><br><p></p><br><pre name="code" class="java">package com.meituan.hyt.test3.jdk;<br><br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br><br><br>public class MyInvocationHandler implements InvocationHandler {<br>    private Object target;<br><br>    MyInvocationHandler() {<br>        super();<br>    }<br><br>    MyInvocationHandler(Object target) {<br>        super();<br>        this.target = target;<br>    }<br><br>    @Override<br>    public Object invoke(Object o, Method method, Object[] args) throws Throwable {<br>        if(&quot;getName&quot;.equals(method.getName())){<br>            System.out.println(&quot;++++++before &quot; + method.getName() + &quot;++++++&quot;);<br>            Object result = method.invoke(target, args);<br>            System.out.println(&quot;++++++after &quot; + method.getName() + &quot;++++++&quot;);<br>            return result;<br>        }else{<br>            Object result = method.invoke(target, args);<br>            return result;<br>        }<br><br>    }<br>}<br></pre><br><br><pre name="code" class="java">package com.meituan.hyt.test3.jdk;<br><br>import com.meituan.hyt.test3.service.UserService;<br>import com.meituan.hyt.test3.service.impl.UserServiceImpl;<br><br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Proxy;<br><br><br>public class Main1 {<br>    public static void main(String[] args) {<br>        UserService userService = new UserServiceImpl();<br>        InvocationHandler invocationHandler = new MyInvocationHandler(userService);<br>        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),<br>                userService.getClass().getInterfaces(), invocationHandler);<br>        System.out.println(userServiceProxy.getName(1));<br>        System.out.println(userServiceProxy.getAge(1));<br>    }<br>}</pre><br><br>运行结果<br><p></p><br><p>&#43;&#43;&#43;&#43;&#43;&#43;before getName&#43;&#43;&#43;&#43;&#43;&#43;<br><br>——getName——<br><br>&#43;&#43;&#43;&#43;&#43;&#43;after getName&#43;&#43;&#43;&#43;&#43;&#43;<br><br>Tom<br><br>——getAge——<br><br>10</p><br><h1>3、cglib动态代理实现<br><br></h1><br><p>Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：<br><br><br><br>CGLIB的核心类：<br><br>&nbsp;&nbsp;&nbsp; net.sf.cglib.proxy.Enhancer – 主要的增强类<br><br>&nbsp;&nbsp;&nbsp; net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现<br><br>&nbsp;&nbsp;&nbsp; net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：<br><br>&nbsp;&nbsp;&nbsp; Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。<br><br><br><br>net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法<br><br>public Object intercept(Object object, java.lang.reflect.Method method,<br><br>Object[] args, MethodProxy proxy) throws Throwable;<br><br><br><br>第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。</p><br><p></p><br><pre name="code" class="java">package com.meituan.hyt.test3.cglib;<br><br><br>import net.sf.cglib.proxy.MethodInterceptor;<br>import net.sf.cglib.proxy.MethodProxy;<br><br>import java.lang.reflect.Method;<br><br><br>public class CglibProxy implements MethodInterceptor {<br>    @Override<br>    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {<br>        System.out.println(&quot;++++++before &quot; + methodProxy.getSuperName() + &quot;++++++&quot;);<br>        System.out.println(method.getName());<br>        Object o1 = methodProxy.invokeSuper(o, args);<br>        System.out.println(&quot;++++++before &quot; + methodProxy.getSuperName() + &quot;++++++&quot;);<br>        return o1;<br>    }<br>}<br></pre><br><br><br><br><pre name="code" class="java">package com.meituan.hyt.test3.cglib;<br><br>import com.meituan.hyt.test3.service.UserService;<br>import com.meituan.hyt.test3.service.impl.UserServiceImpl;<br>import net.sf.cglib.proxy.Enhancer;<br><br><br><br>public class Main2 {<br>    public static void main(String[] args) {<br>        CglibProxy cglibProxy = new CglibProxy();<br><br>        Enhancer enhancer = new Enhancer();<br>        enhancer.setSuperclass(UserServiceImpl.class);<br>        enhancer.setCallback(cglibProxy);<br><br>        UserService o = (UserService)enhancer.create();<br>        o.getName(1);<br>        o.getAge(1);<br>    }<br>}</pre><br><br>运行结果：<br><p></p><br><p>&#43;&#43;&#43;&#43;&#43;&#43;before CGLIB$getName$0&#43;&#43;&#43;&#43;&#43;&#43;<br><br>getName<br><br>——getName——<br><br>&#43;&#43;&#43;&#43;&#43;&#43;before CGLIB$getName$0&#43;&#43;&#43;&#43;&#43;&#43;<br><br>&#43;&#43;&#43;&#43;&#43;&#43;before CGLIB$getAge$1&#43;&#43;&#43;&#43;&#43;&#43;<br><br>getAge<br><br>——getAge——<br><br>&#43;&#43;&#43;&#43;&#43;&#43;before CGLIB$getAge$1&#43;&#43;&#43;&#43;&#43;&#43;<br><br></p><br><div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd"></div><br><div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd"></div><br><div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd"></div><br> </div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/12/lock-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/12/lock-03/" itemprop="url">转载:Lock实现原理(底层实现)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-12T17:18:57+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content"><br>        <div class="markdown_views"><p>关于java lock的底层实现原理，讲的有点深，转载学习！</p><br><br><p>Lock完全用Java写成，在java这个层面是无关JVM实现的。</p><br><br><p>在java.util.concurrent.locks包中有很多Lock的实现类，常用的有ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock），其实现都依赖java.util.concurrent.<strong>AbstractQueuedSynchronizer</strong>类，实现思路都大同小异，因此我们以ReentrantLock作为讲解切入点。</p><br><br><br><br><h3 id="reentrantlock的调用过程">ReentrantLock的调用过程</h3><br><br><p>经过观察ReentrantLock把所有Lock接口的操作都委派到一个<strong>Sync类</strong>上，该类继承了<strong>AbstractQueuedSynchronizer</strong>：</p><br><br><pre><code>static abstract class Sync extends AbstractQueuedSynchronizer<br></code></pre><br><br><p>Sync又有两个子类：</p><br><br><pre><code>final static class NonfairSync extends Sync<br><br>final static class FairSync extends Sync<br></code></pre><br><br><p>显然是为了支持公平锁和非公平锁而定义，默认情况下为非公平锁。 <br><br>先理一下Reentrant.lock()方法的调用过程（默认非公平锁）： <br><br><img src="http://hi.csdn.net/attachment/201107/29/0_13119022769n5R.gif" alt="这里写图片描述" title=""></p><br><br><p>这些讨厌的Template模式导致很难直观的看到整个调用过程，其实通过上面调用过程及AbstractQueuedSynchronizer的注释可以发现，AbstractQueuedSynchronizer中抽象了绝大多数Lock的功能，而只把tryAcquire方法延迟到子类中实现。tryAcquire方法的语义在于用具体子类判断请求线程是否可以获得锁，无论成功与否AbstractQueuedSynchronizer都将处理后面的流程。</p><br><br><br><br><h3 id="锁实现加锁">锁实现（加锁）</h3><br><br><p>简单说来，AbstractQueuedSynchronizer会把所有的请求线程构成一个CLH队列，当一个线程执行完毕（lock.unlock()）时会激活自己的后继节点，但正在执行的线程并不在队列中，而那些等待执行的线程全部处于阻塞状态，经过调查线程的显式阻塞是通过调用LockSupport.park()完成，而LockSupport.park()则调用sun.misc.Unsafe.park()本地方法，再进一步，HotSpot在Linux中中通过调用pthread_mutex_lock函数把线程交给系统内核进行阻塞。 <br><br>该队列如图：</p><br><br><p><img src="http://hi.csdn.net/attachment/201107/28/0_1311847049xnXb.gif" alt="这里写图片描述" title=""></p><br><br><p>与synchronized相同的是，这也是一个虚拟队列，不存在队列实例，仅存在节点之间的前后关系。令人疑惑的是为什么采用CLH队列呢？原生的CLH队列是用于自旋锁，但Doug Lea把其改造为阻塞锁。 <br><br><strong>当有线程竞争锁时，该线程会首先尝试获得锁，这对于那些已经在队列中排队的线程来说显得不公平，这也是非公平锁的由来</strong>，与synchronized实现类似，这样会极大提高吞吐量。 <br><br>如果已经存在Running线程，则新的竞争线程会被追加到队尾，具体是采用基于CAS的Lock-Free算法，因为线程并发对Tail调用CAS可能会导致其他线程CAS失败，解决办法是<strong>循环CAS直至成功</strong>。AbstractQueuedSynchronizer的实现非常精巧，令人叹为观止，不入细节难以完全领会其精髓，下面详细说明实现过程：</p><br><br><br><br><h4 id="21-syncnonfairtryacquire">2.1 Sync.nonfairTryAcquire</h4><br><br><p>nonfairTryAcquire方法将是lock方法间接调用的第一个方法，每次请求锁时都会首先调用该方法。</p><br><br><pre><code>final boolean nonfairTryAcquire(int acquires) {<br>    final Thread current = Thread.currentThread();<br>    int c = getState();<br>    if (c == 0) {<br>        if (compareAndSetState(0, acquires)) {<br>            setExclusiveOwnerThread(current);<br>            return true;<br>        }<br>    }<br>    else if (current == getExclusiveOwnerThread()) {<br>        int nextc = c + acquires;<br>        if (nextc &lt; 0) // overflow<br>            throw new Error(“Maximum lock count exceeded”);<br>        setState(nextc);<br>        return true;<br>    }<br>    return false;<br>}<br></code></pre><br><br><p>该方法会首先判断当前状态，如果c==0说明没有线程正在竞争该锁，如果不c !=0 说明有线程正拥有了该锁。 <br><br>如果发现c==0，则通过CAS设置该状态值为acquires,acquires的初始调用值为1，每次线程重入该锁都会+1，每次unlock都会-1，但为0时释放锁。如果CAS设置成功，则可以预计其他任何线程调用CAS都不会再成功，也就认为当前线程得到了该锁，也作为Running线程，<strong>很显然这个Running线程并未进入等待队列。</strong> <br><br>如果c !=0 但发现自己已经拥有锁，只是简单地++acquires，并修改status值，但因为没有竞争，所以通过setStatus修改，而非CAS，也就是说这段代码实现了偏向锁的功能，并且实现的非常漂亮。</p><br><br><br><br><h4 id="22-abstractqueuedsynchronizeraddwaiter">2.2 AbstractQueuedSynchronizer.addWaiter</h4><br><br><p>addWaiter方法负责把<strong>当前无法获得锁的线程包装为一个Node添加到队尾</strong>：</p><br><br><pre><code>private Node addWaiter(Node mode) {<br>    Node node = new Node(Thread.currentThread(), mode);<br>    // Try the fast path of enq; backup to full enq on failure<br>    Node pred = tail;<br>    if (pred != null) {<br>        node.prev = pred;<br>        if (compareAndSetTail(pred, node)) {<br>            pred.next = node;<br>            return node;<br>        }<br>    }<br>    enq(node);<br>    return node;<br>}<br></code></pre><br><br><p>其中参数mode是独占锁还是共享锁，默认为null，独占锁。追加到队尾的动作分两步： <br><br>如果当前队尾已经存在(tail!=null)，则使用CAS把当前线程更新为Tail <br><br>如果当前<strong>Tail为null或则线程调用CAS设置队尾失败</strong>，则通过enq方法继续设置Tail <br><br>下面是enq方法：</p><br><br><pre><code>private Node enq(final Node node) {<br>    for (;;) {<br>        Node t = tail;<br>        if (t == null) { // Must initialize<br>            Node h = new Node(); // Dummy header<br>            h.next = node;<br>            node.prev = h;<br>            if (compareAndSetHead(h)) {<br>                tail = node;<br>                return h;<br>            }<br>        }<br>        else {<br>            node.prev = t;<br>            if (compareAndSetTail(t, node)) {<br>                t.next = node;<br>                return t;<br>            }<br>        }<br>    }<br>}<br></code></pre><br><br><p>该方法就是<strong>循环调用CAS</strong>，即使有高并发的场景，无限循环将会最终成功把当前线程追加到队尾（或设置队头）。总而言之，<strong>addWaiter的目的就是通过CAS把当前线程追加到队尾，并返回包装后的Node实例。</strong></p><br><br><p>把线程要包装为Node对象的主要原因，除了用Node构造供虚拟队列外，还用Node包装了各种线程状态，这些状态被精心设计为一些数字值：</p><br><br><ul><br><li>SIGNAL(-1) ：线程的后继线程正/已被阻塞，当该线程release或cancel时要重新这个后继线程(unpark)</li><br><li>CANCELLED(1)：因为超时或中断，该线程已经被取消</li><br><li>CONDITION(-2)：表明该线程被处于条件队列，就是因为调用了Condition.await而被阻塞</li><br><li>PROPAGATE(-3)：传播共享锁</li><br><li>0：0代表无状态</li><br></ul><br><br><br><br><h4 id="23-abstractqueuedsynchronizeracquirequeued">2.3 AbstractQueuedSynchronizer.acquireQueued</h4><br><br><p>acquireQueued的主要作用是把已经追加到队列的线程节点（addWaiter方法返回值）进行阻塞，但阻塞前又通过tryAccquire重试是否能获得锁，如果重试成功能则无需阻塞，直接返回</p><br><br><pre><code>final boolean acquireQueued(final Node node, int arg) {<br>    try {<br>        boolean interrupted = false;<br>        for (;;) {<br>            final Node p = node.predecessor();<br>            if (p == head &amp;&amp; tryAcquire(arg)) {<br>                setHead(node);<br>                p.next = null; // help GC<br>                return interrupted;<br>            }<br>            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = true;<br>        }<br>    } catch (RuntimeException ex) {<br>        cancelAcquire(node);<br>        throw ex;<br>    }<br>}<br></code></pre><br><br><p>仔细看看这个方法是个无限循环，感觉如果p == head &amp;&amp; tryAcquire(arg)条件不满足循环将永远无法结束，当然不会出现死循环，奥秘在于第12行的<strong>parkAndCheckInterrupt会把当前线程挂起</strong>，从而阻塞住线程的调用栈。</p><br><br><pre><code>private final boolean parkAndCheckInterrupt() {<br>    LockSupport.park(this);<br>    return Thread.interrupted();<br>}<br></code></pre><br><br><p>如前面所述，LockSupport.park最终把线程交给系统（Linux）内核进行阻塞。当然也不是马上把请求不到锁的线程进行阻塞，还要检查该线程的状态，比如如果该线程处于Cancel状态则没有必要，具体的检查在shouldParkAfterFailedAcquire中：</p><br><br><pre><code>  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {<br>      int ws = pred.waitStatus;<br>      if (ws == Node.SIGNAL)<br>          /<em> 
           </em> This node has already set status asking a release<br>           <em> to signal it, so it can safely park 
           </em>/<br>          return true;<br>      if (ws &gt; 0) {<br>          /<em> 
           </em> Predecessor was cancelled. Skip over predecessors and<br>           <em> indicate retry. 
           </em>/<br>   do {<br>            node.prev = pred = pred.prev;<br>    } while (pred.waitStatus &gt; 0);<br>            pred.next = node;<br>    } else {<br>          /<em> 
           </em> waitStatus must be 0 or PROPAGATE. Indicate that we<br>           <em> need a signal, but don’t park yet. Caller will need to 
           </em> retry to make sure it cannot acquire before parking.<br>           <em>/<br>          compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>      }<br>      return false;<br>  }<br></em></code></pre><br><br><p>检查原则在于：</p><br><br><ul><br><li><p>规则1：如果前继的节点状态为SIGNAL，表明当前节点需要unpark，则返回成功，此时acquireQueued方法的第12行（parkAndCheckInterrupt）将导致线程阻塞</p></li><br><li><p>规则2：如果前继节点状态为CANCELLED(ws&gt;0)，说明前置节点已经被放弃，则回溯到一个非取消的前继节点，返回false，acquireQueued方法的无限循环将递归调用该方法，直至规则1返回true，导致线程阻塞</p></li><br><li><p>规则3：如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL，返回false后进入acquireQueued的无限循环，与规则2同</p></li><br></ul><br><br><p>总体看来，shouldParkAfterFailedAcquire就是靠前继节点判断当前线程是否应该被阻塞，如果前继节点处于CANCELLED状态，<strong>则顺便删除这些节点重新构造队列。</strong> <br><br>至此，锁住线程的逻辑已经完成，下面讨论解锁的过程。</p><br><br><h3 id="解锁">解锁</h3><br><br><p>请求锁不成功的线程会被挂起在acquireQueued方法的第12行，12行以后的代码必须等线程被解锁锁才能执行，假如被阻塞的线程得到解锁，则执行第13行，即设置interrupted = true，之后又进入无限循环。</p><br><br><p>从无限循环的代码可以看出，并不是得到解锁的线程一定能获得锁，必须在第6行中调用tryAccquire重新竞争，因为锁是非公平的，有可能被新加入的线程获得，<strong>从而导致刚被唤醒的线程再次被阻塞</strong>，这个细节充分体现了“非公平”的精髓。通过之后将要介绍的解锁机制会看到，第一个被解锁的线程就是Head，因此p == head的判断基本都会成功。</p><br><br><p>至此可以看到，把tryAcquire方法延迟到子类中实现的做法非常精妙并具有极强的可扩展性，令人叹为观止！当然精妙的不是这个Template设计模式，而是Doug Lea对锁结构的精心布局。</p><br><br><p>解锁代码相对简单，主要体现在AbstractQueuedSynchronizer.release和Sync.tryRelease方法中： <br><br>class AbstractQueuedSynchronizer</p><br><br><pre><code>public final boolean release(int arg) {<br>    if (tryRelease(arg)) {<br>        Node h = head;<br>        if (h != null &amp;&amp; h.waitStatus != 0)<br>            unparkSuccessor(h);<br>        return true;<br>    }<br>    return false;<br>}<br></code></pre><br><br><p>class Sync</p><br><br><pre><code>protected final boolean tryRelease(int releases) {<br>    int c = getState() - releases;<br>    if (Thread.currentThread() != getExclusiveOwnerThread())<br>        throw new IllegalMonitorStateException();<br>    boolean free = false;<br>    if (c == 0) {<br>        free = true;<br>        setExclusiveOwnerThread(null);<br>    }<br>    setState(c);<br>    return free;<br>}<br></code></pre><br><br><p>tryRelease与tryAcquire语义相同，把如何释放的逻辑延迟到子类中。</p><br><br><p>tryRelease语义很明确：如果线程多次锁定，则进行多次释放，直至status==0则真正释放锁，所谓释放锁即设置status为0，因为无竞争所以没有使用CAS。 <br><br>release的语义在于：如果可以释放锁，则唤醒队列第一个线程（Head），具体唤醒代码如下：</p><br><br><pre><code>private void unparkSuccessor(Node node) {<br>    /<br>     <em> If status is negative (i.e., possibly needing signal) try 
     </em> to clear in anticipation of signalling. It is OK if this<br>     <em> fails or if status is changed by waiting thread. 
     </em>/<br>    int ws = node.waitStatus;<br>    if (ws &lt; 0)<br>        compareAndSetWaitStatus(node, ws, 0);<br><br>    /<em> 
     </em> Thread to unpark is held in successor, which is normally<br>     <em> just the next node.  But if cancelled or apparently null, 
     </em> traverse backwards from tail to find the actual<br>     <em> non-cancelled successor. 
     </em>/<br>    Node s = node.next;<br>    if (s == null || s.waitStatus &gt; 0) {<br>        s = null;<br>        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)<br>            if (t.waitStatus &lt;= 0)<br>                s = t;<br>    }<br>    if (s != null)<br>        LockSupport.unpark(s.thread);<br>}<br></code></pre><br><br><p>这段代码的意思在于找出第一个可以unpark的线程，一般说来head.next == head，Head就是第一个线程，但Head.next可能被取消或被置为null，因此比较稳妥的办法是从后往前找第一个可用线程。貌似回溯会导致性能降低，其实这个发生的几率很小，所以不会有性能影响。之后便是通知系统内核继续该线程，在Linux下是通过pthread_mutex_unlock完成。之后，被解锁的线程进入上面所说的重新竞争状态。</p><br><br><br><br><h3 id="lock-vs-synchronized">Lock VS Synchronized</h3><br><br><p>AbstractQueuedSynchronizer通过构造一个<strong>基于阻塞的CLH队列</strong>容纳所有的阻塞线程，而对该队列的操作均通过Lock-Free（CAS）操作，但对已经获得锁的线程而言，ReentrantLock实现了偏向锁的功能。</p><br><br><p>synchronized的底层也是一个基于CAS操作的等待队列，但JVM实现的更精细，把等待队列分为ContentionList和EntryList，目的是为了降低线程的出列速度；当然也实现了偏向锁，从数据结构来说二者设计没有本质区别。但synchronized还实现了自旋锁，并针对不同的系统和硬件体系进行了优化，而Lock则完全依靠系统阻塞挂起等待线程。</p><br><br><p>当然Lock比synchronized更适合在应用层扩展，可以继承AbstractQueuedSynchronizer定义各种实现，比如实现读写锁（ReadWriteLock），公平或不公平锁；同时，Lock对应的Condition也比wait/notify要方便的多、灵活的多。</p></div>

</div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/12/reflectASM-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/12/reflectASM-01/" itemprop="url">转载:JAVA下高效的反射工具包ReflectASM 使用例解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-12T17:06:29+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a title="ReflectASM" href="http://code.google.com/p/reflectasm/" target="_blank">ReflectASM</a>&nbsp;使用字节码生成的方式实现了更为高效的反射机制。执行时会生成一个存取类来 set/get&nbsp;字段，访问方法或创建实例。一看到&nbsp;ASM&nbsp;就能领悟到&nbsp;ReflectASM&nbsp;会用字节码生成的方式，而不是依赖于&nbsp;Java&nbsp;本身的反射机制来实现的，所以它更快，并且避免了访问原始类型因自动装箱而产生的问题。</p><br><p>下面三个图是 ReflectASM&nbsp;与&nbsp;Java&nbsp;自身反射机制的性能对比，表现很不错的。</p><br><p style="text-align: center;"><img class="aligncenter" alt="" src="http://chart.apis.google.com/chart?chma=100&amp;chtt=Field%20Set/Get&amp;chs=700x62&amp;chd=t:1402081,11339107&amp;chds=0,11339107&amp;chxl=0:%7CJava%20Reflection%7CFieldAccess&amp;cht=bhg&amp;chbh=10&amp;chxt=y&amp;chco=6600FF&amp;.png" width="700" height="62"></p><br><p style="text-align: center;"><img class="aligncenter" alt="" src="http://chart.apis.google.com/chart?chma=100&amp;chtt=Method%20Call&amp;chs=700x62&amp;chd=t:97390,208750&amp;chds=0,208750&amp;chxl=0:%7CJava%20Reflection%7CMethodAccess&amp;cht=bhg&amp;chbh=10&amp;chxt=y&amp;chco=6600AA&amp;.png" width="700" height="62"></p><br><p style="text-align: center;"><img class="aligncenter" alt="" src="http://chart.apis.google.com/chart?chma=100&amp;chtt=Constructor&amp;chs=700x62&amp;chd=t:2853063,5828993&amp;chds=0,5828993&amp;chxl=0:%7CJava%20Reflection%7CConstructorAccess&amp;cht=bhg&amp;chbh=10&amp;chxt=y&amp;chco=660066&amp;.png" width="700" height="62"></p><br><p>测试代码包含在项目文件中.&nbsp;上面图形是在&nbsp; Oracle 的 Java 7u3, server VM&nbsp;下测试出的结果。</p><br><p>下面我们自己来做个测试，测试环境是 Mac OS X 10.8, 2.4G Core 2 Duo, 4G RAM, 64 位&nbsp;JDK 1.6.<span id="more-4685"></span></p><br><p>待反射的类 SomeClass.java</p><br><pre class="brush:java">package cc.unmi.testreflect;<br><br>public class SomeClass {<br>&nbsp;&nbsp; &nbsp;private String name;<br><br>&nbsp;&nbsp; &nbsp;public void foo(String name) {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.name = name;<br>&nbsp;&nbsp; &nbsp;}<br>}</pre><br><p>测试类 ReflectasmClient.java</p><br><pre class="brush:java">package cc.unmi.testreflect;<br><br>import java.lang.reflect.Method;<br>import com.esotericsoftware.reflectasm.MethodAccess;<br><br>/<em>*<br>&nbsp;</em> @author Unmi<br>&nbsp;*/<br>public class ReflectasmClient {<br><br>&nbsp;&nbsp; &nbsp;public static void main(String[] args) throws Exception {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;testJdkReflect();<br>//&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;testReflectAsm();<br>&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;public static void testJdkReflect() throws Exception {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SomeClass someObject = new SomeClass();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; 5; i++) {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long begin = System.currentTimeMillis();<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int j = 0; j &lt; 100000000; j++) {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Method method = SomeClass.class.getMethod(“foo”, String.class);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;method.invoke(someObject, “Unmi”);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.print(System.currentTimeMillis() - begin +” “);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;public static void testReflectAsm() {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SomeClass someObject = new SomeClass();<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; 5; i++) {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long begin = System.currentTimeMillis();<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int j = 0; j &lt; 100000000; j++) {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;MethodAccess access = MethodAccess.get(SomeClass.class);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;access.invoke(someObject, “foo”, “Unmi”);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.print(System.currentTimeMillis() - begin + “ “);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;}<br>}</pre><br><p>分别运行 testJdkReflect()&nbsp;和 testReflectAsm 得出各自的运行时间数据，如下：</p><br><p>运行&nbsp;testJdkReflect():&nbsp; 31473 31663 31578 31658 31552</p><br><p>运行 testReflectAsm(): 312814 310666 312867 311234 311792</p><br><p>这个数据是非常恐怖的，似乎在带领我们往相反的方向上走，用 ReflectASM&nbsp;怎么反而耗时多的多，高一个数量级，为什么呢？原因是大部分的时间都耗费在了</p><br><p>MethodAccess access = MethodAccess.get(SomeClass.class);</p><br><p>上，正是生成字节码的环节上，也让你体验到 MethodAccess&nbsp;是个无比耗时的操作，如果把这行放到循环之外会是什么样的结果呢，同时也把方法 testJdkReflect()&nbsp;中的</p><br><p>Method method = SomeClass.class.getMethod(“foo”, String.class);</p><br><p>也提出去，改变后的 testJdkReflect()&nbsp;和 testReflectAsm()&nbsp;分别如下：</p><br><pre class="brush:java">&nbsp;&nbsp;&nbsp; public static void testJdkReflect() throws Exception {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SomeClass someObject = new SomeClass();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Method method = SomeClass.class.getMethod(“foo”, String.class);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; 5; i++) {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long begin = System.currentTimeMillis();<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int j = 0; j &lt; 100000000; j++) {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;method.invoke(someObject, “Unmi”);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.print(System.currentTimeMillis() - begin +” “);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;public static void testReflectAsm() {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SomeClass someObject = new SomeClass();<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;MethodAccess access = MethodAccess.get(SomeClass.class);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; 5; i++) {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long begin = System.currentTimeMillis();<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int j = 0; j &lt; 100000000; j++) {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;access.invoke(someObject, “foo”, “Unmi”);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.print(System.currentTimeMillis() - begin + “ “);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;}</pre><br><p>再次分别跑下 testJdkReflect()&nbsp;和&nbsp; testReflectAsm()，新的结果如下：</p><br><p>运行&nbsp;testJdkReflect():&nbsp; 1682 1696 1858 1774 1780 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ——&nbsp;平均&nbsp; 1758</p><br><p>运行 testReflectAsm(): 327 549 520 509 514 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ——&nbsp;平均 483.8</p><br><p>胜负十分明显，上面的实验两相一比较，用 ReflectAsm&nbsp;进行方法调用节省时间是 72.48％</p><br><p>也因此可以得到使用 ReflectASM&nbsp;时需特别注意的是，获得类似 MethodAccess&nbsp;实例只做一次，或它的实例应缓存起来，才是真正用好 ReflectASM。</p><br><p>进一步深入的话，不妨看看分别从 testJdkReflect()/testReflectAsm()&nbsp;到&nbsp;SomeClass.foo()&nbsp;过程中到底发生了什么，断点看调用栈。</p><br><p>testJdkReflect()&nbsp;到&nbsp;SomeClass.foo()&nbsp;的调用栈：</p><br><p style="text-align: center;"><img class="aligncenter  wp-image-4688" title="testJdkReflect_debug" alt="" src="http://unmi.cc/wp-content/uploads/2012/08/testJdkReflect_debug.png" srcset="https://unmi.cc/wp-content/uploads/2012/08/testJdkReflect_debug.png 645w, https://unmi.cc/wp-content/uploads/2012/08/testJdkReflect_debug-300x158.png 300w" sizes="(max-width: 645px) 100vw, 645px"></p><br><p>借助了&nbsp;JDK&nbsp;的 DelegatingMethodAccessorImpl&nbsp;和&nbsp; NativeMethodAccessorImpl。</p>

<!-- Easy Plugin for AdSense V8.7 -->
<!-- [midtext: 1 urCount: 1 urMax: 0] -->
<p><div class="ezAdsense adsense adsense-midtext" style="float:left;margin:12px;"><span class="inner_copyright"><!--POST_URL--></span></div><br><!-- Easy Plugin for AdSense V8.7 --></p>
<p>再看 testReflectAsm()&nbsp;到 SomeClass.foo(）的调用栈：</p><br><p style="text-align: center;"><img class="aligncenter  wp-image-4689" title="testReflectAsm_debug" alt="" src="http://unmi.cc/wp-content/uploads/2012/08/testReflectAsm_debug.png" srcset="https://unmi.cc/wp-content/uploads/2012/08/testReflectAsm_debug.png 645w, https://unmi.cc/wp-content/uploads/2012/08/testReflectAsm_debug-300x158.png 300w" sizes="(max-width: 645px) 100vw, 645px"></p><br><p>可以看到，ReflectAsm&nbsp;在执行 MethodAccess access = MethodAccess.get(SomeClass.class);&nbsp;为你生成了类 SomeClassMethodAccess，经由它来进行后续的方法调用，使得性能上有很可观的改善。</p><br><p>上面只是讲述了，调用方法时如何使用 ReflectAsm，以及怎么确保高效性。下面补上 ReflectAsm&nbsp;更多的用法，翻译自 ReflectAsm&nbsp;官方。</p><br><hr><br><p>ReflectASM&nbsp;反射调用方法:</p><br><pre class="brush:java">SomeClass someObject = …<br>MethodAccess access = MethodAccess.get(SomeClass.class);<br>access.invoke(someObject, “setName”, “Awesome McLovin”);<br>String name = (String)access.invoke(someObject, “getName”);</pre><br><p>用 ReflectASM&nbsp;反射来 set/get&nbsp;字段值:</p><br><pre class="brush:java">SomeClass someObject = …<br>FieldAccess access = FieldAccess.get(SomeClass.class);<br>access.set(someObject, “name”, “Awesome McLovin”);<br>String name = (String)access.get(someObject, “name”);</pre><br><p>用 ReflectASM&nbsp;反射来调用构造方法:</p><br><pre class="brush:java">ConstructorAccess&lt;SomeClass&gt; access = ConstructorAccess.get(SomeClass.class);<br>SomeClass someObject = access.newInstance();</pre><br><p><strong>避免用方法名来查找</strong></p><br><p>为了在重复性的反射来访问方法或字段时最大化性能，应该用方法和字段的索引来定位而不是名称：</p><br><pre class="brush:java">SomeClass someObject = …<br>MethodAccess access = MethodAccess.get(SomeClass.class);<br>int addNameIndex = access.getIndex(“addName”);<br>for (String name : names)<br>&nbsp; &nbsp; access.invoke(someObject, addNameIndex, “Awesome McLovin”);</pre><br><p>说到这，不妨再次来验证一下，把 testReflectAsm()&nbsp;方法改为如下：</p><br><pre class="brush:java">&nbsp;&nbsp;&nbsp; public static void testReflectAsm() {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SomeClass someObject = new SomeClass();<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;MethodAccess access = MethodAccess.get(SomeClass.class);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int fooIndex = access.getIndex(“foo”, String.class);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; 5; i++) {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long begin = System.currentTimeMillis();<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int j = 0; j &lt; 100000000; j++) {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;access.invoke(someObject, fooIndex, “Unmi”);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.print(System.currentTimeMillis() - begin + “ “);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;}</pre><br><p>运行的输出结果是，你可能想像不到的：</p><br><p>206 182 171 175 171</p><br><p>而用名称查找方法时的测试数据为：327 549 520 509 514</p><br><p>当然你调用的重复性应该带有一点夸张性质的。性能更优化的原因是用名称来查找最科要被转换成索引来查找。</p><br><p><strong>可见性</strong></p><br><p>ReflectASM&nbsp;总是能访问公有成员的.&nbsp;它会尝试在同一个 package&nbsp;中去定义访问类的，并且同一个类加载器去加载。所以，如果安全管理器允许 setAccessible&nbsp;调用成功的话，protected&nbsp;或包私有(package private)&nbsp;的成员也可被访问到.&nbsp;假如 setAccessible&nbsp;失败，仅当当有公有成员可被访问时，不会有异常抛出.&nbsp;私有成员总是无法访问到。</p><br><p><strong>有关异常</strong></p><br><p>当使用 ReflectASM&nbsp;有异常时，栈跟踪更清淅了。这是 Java&nbsp;在反射调用方法时抛出了一个 RuntimeException 异常：</p><br><pre class="brush:java">Exception in thread “main” java.lang.reflect.InvocationTargetException<br>&nbsp; &nbsp; &nbsp; &nbsp; at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>&nbsp; &nbsp; &nbsp; &nbsp; at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br>&nbsp; &nbsp; &nbsp; &nbsp; at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)<br>&nbsp; &nbsp; &nbsp; &nbsp; at java.lang.reflect.Method.invoke(Method.java:597)<br>&nbsp; &nbsp; &nbsp; &nbsp; at com.example.SomeCallingCode.doit(SomeCallingCode.java:22)<br>Caused by: java.lang.RuntimeException<br>&nbsp; &nbsp; &nbsp; &nbsp; at com.example.SomeClass.someMethod(SomeClass.java:48)<br>&nbsp; &nbsp; &nbsp; &nbsp; … 5 more</pre><br><p>再看用 ReflectASM&nbsp;时抛出的同样的异常:</p><br><pre class="brush:java">Exception in thread “main” java.lang.RuntimeException<br>&nbsp; &nbsp; &nbsp; &nbsp; at com.example.SomeClass.someMethod(SomeClass.java:48)<br>&nbsp; &nbsp; &nbsp; &nbsp; at com.example.SomeClassMethodAccess.invoke(Unknown Source)<br>&nbsp; &nbsp; &nbsp; &nbsp; at com.example.SomeCallingCode.doit(SomeCallingCode.java:22)</pre><br><p>如果被 ReflectASM&nbsp;调用的代码抛出了需检测的异常，也需要抛出需检测异常.&nbsp;因为如果你在用 try/catch&nbsp;捕获块中未声明抛出的具体类型的异常时会报编译错误。（Unmi&nbsp;注：这句话的意思是说，比如方法 foo()&nbsp;未声明抛出 IOException，而你 try&nbsp;它时却 catch(IOException)&nbsp;就会出现编译错误）所以当你在用 ReflectASM 反射调用，并需要关心其中抛出的异常时，你必须捕获的异常类型是 Exception。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://bloodorange2017.github.io/images/img_head_001.jpg"
               alt="XueCheng" />
          <p class="site-author-name" itemprop="name">XueCheng</p>
           
              <p class="site-description motion-element" itemprop="description">Do one thing at a time, and do well.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XueCheng</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

<script type="text/javascript"
color="160,160,233" opacity='0.4' zIndex="-2" count="16" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
