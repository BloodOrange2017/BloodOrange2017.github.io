<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Do one thing at a time, and do well.">
<meta property="og:type" content="website">
<meta property="og:title" content="XueCheng Notes">
<meta property="og:url" content="https://bloodorange2017.github.io/archives/page/9/index.html">
<meta property="og:site_name" content="XueCheng Notes">
<meta property="og:description" content="Do one thing at a time, and do well.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XueCheng Notes">
<meta name="twitter:description" content="Do one thing at a time, and do well.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bloodorange2017.github.io/archives/page/9/"/>





  <title>XueCheng Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XueCheng Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Where there is a will, there is a way.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/08/ConcurrentHashMap-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/08/ConcurrentHashMap-02/" itemprop="url">转载:深入分析ConcurrentHashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-08T18:19:39+08:00">
                2017-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h1><b>术语定义</b></h1><p></p>
<p><table border="1" cellspacing="0" cellpadding="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td valign="top" width="55"><strong>术语</strong></td></p>
<p><td valign="top" width="99"><strong>英文</strong></td></p>
<p><td valign="top" width="308"><strong>解释</strong></td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="55">哈希算法</td></p>
<p><td valign="top" width="99"><b>hash algorithm</b></td></p>
<p><td valign="top" width="308">是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。<b> </b></td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="55">哈希表</td></p>
<p><td valign="top" width="99"><b>hash table</b></td></p>
<p><td valign="top" width="308">根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</td><br><br><br></p>
<p></p><h1><b>线程不安全的HashMap</b></h1><p></p>
<p></p><p>因为多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。<br><br><span id="more-269"></span><br><br>如以下代码：</p><p></p>
<p><pre class="brush: java; title: ; notranslate" title=""><br>final HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(2);</pre></p>
<pre><code>Thread t = new Thread(new Runnable() {

    @Override

    public void run() {

        for (int i = 0; i &amp;lt; 10000; i++) {

            new Thread(new Runnable() {

                @Override

                public void run() {

                    map.put(UUID.randomUUID().toString(), &amp;quot;&amp;quot;);

                }

            }, &amp;quot;ftf&amp;quot; + i).start();

        }

    }

}, &amp;quot;ftf&amp;quot;);

t.start();

t.join();
</code></pre><p></p>
<p></p><h1><b>效率低下的</b><b>HashTable</b><b>容器</b></h1><p></p>
<p></p><p><b>     </b>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><p></p>
<p></p><h1><b>ConcurrentHashMap</b><b>的锁分段技术</b></h1><p></p>
<p></p><p><b>     </b>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p></p>
<p></p><h1><b>ConcurrentHashMap</b><b>的结构</b></h1><p></p>
<p></p><p>我们通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构。<br><br><a href="http://ifeve.com/concurrenthashmap/concurrenthashmap%e7%b1%bb%e5%9b%be/" rel="external" target="_blank"><img class="alignnone size-full wp-image-273" alt="ConcurrentHashMap类图" src="http://ifeve.com/wp-content/uploads/2012/12/ConcurrentHashMap类图.jpg" width="500" height="416"></a><br><br>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。<br><br><a href="http://ifeve.com/concurrenthashmap/concurrenthashmap%e7%bb%93%e6%9e%84%e5%9b%be/" rel="external" target="_blank"><img class="alignnone size-full wp-image-277" alt="ConcurrentHashMap结构图" src="http://ifeve.com/wp-content/uploads/2012/12/ConcurrentHashMap结构图.jpg" width="500" height="255"></a><br><br><b> </b></p><p></p>
<p></p><h1><b>ConcurrentHashMap</b><b>的初始化</b></h1><p></p>
<p></p><p>ConcurrentHashMap初始化方法是通过initialCapacity，loadFactor, concurrencyLevel几个参数来初始化segments数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组。</p><p></p>
<p></p><p><b>初始化</b><b>segments</b><b>数组</b>。让我们来看一下初始化segmentShift，segmentMask和segments数组的源代码。</p><p></p>
<p><pre class="brush: java; title: ; notranslate" title=""><br> if (concurrencyLevel &gt; MAX_SEGMENTS)</pre></p>
<p>concurrencyLevel = MAX_SEGMENTS;</p>
<p>// Find power-of-two sizes best matching arguments</p>
<p>int sshift = 0;</p>
<p>int ssize = 1;</p>
<p>while (ssize &lt; concurrencyLevel) {</p>
<p>++sshift;</p>
<p>ssize &lt;&lt;= 1;</p>
<p>}</p>
<p>segmentShift = 32 - sshift;</p>
<p>segmentMask = ssize - 1;</p>
<p>this.segments = Segment.newArray(ssize);</p>
<p></p><p>由上面的代码可知segments数组的长度ssize通过concurrencyLevel计算得出。为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位。</p><p></p>
<p></p><p><b>初始化segmentShift和segmentMask</b>。这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p><p></p>
<p></p><p><b>初始化每个</b>Segment。输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个<b>segment</b>的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个<b>segment</b><b>。 </b></p><p></p>
<p><pre class="brush: java; title: ; notranslate" title=""><br>  if (initialCapacity &gt; MAXIMUM_CAPACITY)</pre></p>
<pre><code>    initialCapacity = MAXIMUM_CAPACITY;

int c = initialCapacity / ssize;

if (c * ssize &amp;lt; initialCapacity)

    ++c;

int cap = 1;

while (cap &amp;lt; c)

    cap &amp;lt;&amp;lt;= 1;

for (int i = 0; i &amp;lt; this.segments.length; ++i)

    this.segments[i] = new Segment&amp;lt;K,V&amp;gt;(cap, loadFactor);
</code></pre><p></p>
<p></p><p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p><p></p>
<p></p><h2><b>定位</b><b>Segment</b></h2><p></p>
<p></p><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过哈希算法定位到Segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再哈希。</p><p></p>
<pre class="brush: java; title: ; notranslate" title="">

<p>private static int hash(int h) {</p>
<p>h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10);</p>
<p>h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6);</p>
<p>h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);</p>
<p>}<br></p></pre><p></p>
<p></p><p>再哈希，其目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。我做了一个测试，不通过再哈希而直接执行哈希计算。</p><p></p>
<pre class="brush: java; title: ; notranslate" title="">

<p>System.out.println(Integer.parseInt(&quot;0001111&quot;, 2) &amp; 15);</p>
<p>System.out.println(Integer.parseInt(&quot;0011111&quot;, 2) &amp; 15);</p>
<p>System.out.println(Integer.parseInt(&quot;0111111&quot;, 2) &amp; 15);</p>
<p>System.out.println(Integer.parseInt(&quot;1111111&quot;, 2) &amp; 15);</p>
<p></p></pre><p></p>
<p></p><p>计算后输出的哈希值全是15，通过这个例子可以发现如果不进行再哈希，哈希冲突会非常严重，因为只要低位一样，无论高位是什么数，其哈希值总是一样。我们再把上面的二进制数据进行再哈希后结果如下，为了方便阅读，不足32位的高位补了0，每隔四位用竖线分割下。</p><p></p>
<p><pre class="brush: java; title: ; notranslate" title=""><br>0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110</pre></p>
<p>1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000</p>
<p>0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110</p>
<p>1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010<br></p>
<p></p><p>可以发现每一位的数据都散列开了，通过这种再哈希能让数字的每一位都能参加到哈希运算当中，从而减少哈希冲突。ConcurrentHashMap通过以下哈希算法定位segment。</p><p></p>
<p></p><p>默认情况下segmentShift为28，segmentMask为15，再哈希后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到hash运算中， (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask的运算结果分别是4，15，7和8，可以看到hash值没有发生冲突。</p><p></p>
<p><pre class="brush: java; title: ; notranslate" title=""><br>final Segment&lt;K,V&gt; segmentFor(int hash) {</pre></p>
<pre><code>    return segments[(hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask];

}
</code></pre><p></p>
<p></p><h1><b>ConcurrentHashMap</b><b>的get操作</b></h1><p></p>
<p></p><p>Segment的get操作实现非常简单和高效。先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素，代码如下：</p><p></p>
<pre class="brush: java; title: ; notranslate" title="">

<p> public V get(Object key) {</p>
<pre><code>    int hash = hash(key.hashCode());

    return segmentFor(hash).get(key, hash);

}
</code></pre><p></p></pre><p></p>
<p></p><p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p><p></p>
<p><pre class="brush: java; title: ; notranslate" title=""><br>transient volatile int count;</pre></p>
<p>volatile V value;</p>
<p></p>
<p></p><p>在定位元素的代码里我们可以发现定位HashEntry和定位Segment的哈希算法虽然一样，都与数组的长度减去一相与，但是相与的值不一样，定位Segment使用的是元素的hashcode通过再哈希后得到的值的高位，而定位HashEntry直接使用的是再哈希后的值。其目的是避免两次哈希后的值一样，导致元素虽然在Segment里散列开了，但是却没有在HashEntry里散列开。</p><p></p>
<pre class="brush: java; title: ; notranslate" title="">

<p>hash &gt;&gt;&gt; segmentShift) &amp; segmentMask//定位Segment所使用的hash算法</p>
<p>int index = hash &amp; (tab.length - 1);// 定位HashEntry所使用的hash算法</p>
<p></p></pre><p></p>
<p></p><p><b>ConcurrentHashMap</b><b>的Put操作</b></p><p></p>
<p></p><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。</p><p></p>
<p></p><p><b>是否需要扩容</b>。在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。</p><p></p>
<p></p><p><b>如何扩容。</b>扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p><p></p>
<p></p><h1 align="left"><b>ConcurrentHashMap</b><b>的size操作</b></h1><p></p>
<p></p><p align="left">如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。</p><p></p>
<p></p><p align="left">因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p><p></p>
<p></p><p>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p><p></p>
<p></p><h1><b>参考资料</b></h1><p></p>
<p><ol></ol></p>
<p><li>JDK1.6源代码。</li></p>
<p><li>《Java并发编程实践》</li></p>
<p><li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/" target="_blank" rel="external">Java并发编程之ConcurrentHashMap</a></li><br></p>
<div style="margin-top: 15px; font-style: italic"><br><p><strong>原创文章，转载请注明：</strong> 转载自<a href="http://ifeve.com/" target="_blank" rel="external">并发编程网 &#8211; ifeve.com</a><strong>本文链接地址:</strong> <a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="external">聊聊并发（四）深入分析ConcurrentHashMap</a></p><br><p><a target="_blank" href="http://pro.badouxueyuan.cn/ifeve/"><img class="aligncenter size-full wp-image-31623" src="http://ifeve.com/wp-content/uploads/2017/04/WechatIMG1.jpeg"></a></p><br></div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/08/ConcurrentHashMap-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/08/ConcurrentHashMap-01/" itemprop="url">转载:ConcurrentHashMap简要原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-08T18:12:45+08:00">
                2017-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span class="Apple-style-span" style="color: rgb(42, 42, 42); font-family: 宋体; font-size: 14px; line-height: 21px; "><div> <wbr> <wbr> <wbr> 集合是编程中最常用的数据结构。而谈到并发，几乎总是离不开集合这类高级数据结构的支持。比如两个线程需要同时访问一个中间临界区（Queue），比如常会用缓存作为外部文件的副本（HashMap）。这篇文章主要分析jdk1.5的3种并发集合类型（concurrent，copyonright，queue）中的ConcurrentHashMap，让我们从原理上细致的了解它们，能够让我们在深度项目开发中获益非浅。</div><div> <wbr> <wbr> <wbr> 在tiger之前，我们使用得最多的数据结构之一就是HashMap和Hashtable。大家都知道，HashMap中未进行同步考虑，而Hashtable则使用了synchronized，带来的直接影响就是可选择，我们可以在单线程时使用HashMap提高效率，而多线程时用Hashtable来保证安全。</div><div> <wbr> <wbr> <wbr> 当我们享受着jdk带来的便利时同样承受它带来的不幸恶果。通过分析Hashtable就知道，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，安全的背后是巨大的浪费，慧眼独具的Doug Lee立马拿出了解决方案—-ConcurrentHashMap。</div><div> <wbr> <wbr> <wbr> ConcurrentHashMap和Hashtable主要区别就是围绕着锁的粒度以及如何锁。如图</div><div><span class="Apple-style-span" style="color: rgb(44, 88, 65);"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/liuzhengkang/EntryImages/20080912/58adc9e7b4725349c149a.jpg" alt="" align=""></span><a href="http://blog.photo.sina.com.cn/showpic.html#blogid=58adc9e701000a27&amp;url=http://static11.photo.sina.com.cn/orignal/58adc9e7b4725349c149a" target="_blank" style="color: rgb(44, 88, 65); "></a></div><div><a href="http://blog.photo.sina.com.cn/showpic.html#blogid=58adc9e701000a27&amp;url=http://static15.photo.sina.com.cn/orignal/58adc9e71d01f8da6db8e" target="_blank" style="color: rgb(44, 88, 65); "></a></div><div> <wbr> <wbr> <wbr> 左边便是Hashtable的实现方式—锁整个hash表；而右边则是ConcurrentHashMap的实现方式—锁桶（或段）。ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。试想，原来只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而读线程几乎不受限制，之后会提到），并发性的提升是显而易见的。</div><div> <wbr> <wbr> <wbr> 更令人惊讶的是ConcurrentHashMap的读取并发，因为在读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作，而写操作锁定的粒度又非常细，比起之前又更加快速（这一点在桶更多时表现得更明显些）。只有在求size等操作时才需要锁定整个表。而在迭代时，ConcurrentHashMap使用了不同于传统集合的快速失败迭代器（见之前的文章《JAVA API备忘—集合》）的另一种迭代方式，我们称为弱一致迭代器。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationEx<wbr>ception，取而代之的是在改变时new新的数据从而不影响原有的数据，iterator完成后再将头指针替换为新的数据，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。</div><div> <wbr> <wbr> <wbr> 接下来，让我们看看ConcurrentHashMap中的几个重要方法，心里知道了实现机制后，使用起来就更加有底气。</div><div> <wbr> <wbr> <wbr> ConcurrentHashMap中主要实体类就是三个：ConcurrentHashMap（整个Hash表）,Segment（桶），HashEntry（节点），对应上面的图可以看出之间的关系。</div><div> <wbr> <wbr> <wbr> get方法（请注意，这里分析的方法都是针对桶的，因为ConcurrentHashMap的最大改进就是将粒度细化到了桶上），首先判断了当前桶的数据个数是否为0，为0自然不可能get到什么，只有返回null，这样做避免了不必要的搜索，也用最小的代价避免出错。然后得到头节点（方法将在下面涉及）之后就是根据hash和key逐个判断是否是指定的值，如果是并且值非空就说明找到了，直接返回；程序非常简单，但有一个令人困惑的地方，这句return readValueUnderLock(e)到底是用来干什么的呢？研究它的代码，在锁定之后返回一个值。但这里已经有一句V v = e.value得到了节点的值，这句return readValueUnderLock(e)是否多此一举？事实上，这里完全是为了并发考虑的，这里当v为空时，可能是一个线程正在改变节点，而之前的get操作都未进行锁定，根据bernstein条件，读后写或写后读都会引起数据的不一致，所以这里要对这个e重新上锁再读一遍，以保证得到的是正确值，这里不得不佩服Doug Lee思维的严密性。整个get操作只有很少的情况会锁定，相对于之前的Hashtable，并发是不可避免的啊！</div><div><table align="center" style="border-right-color: rgb(153, 153, 153); border-right-width: 1px; border-right-style: solid; border-top-color: rgb(153, 153, 153); border-top-width: 1px; border-top-style: solid; font-size: 12px; border-left-color: rgb(153, 153, 153); border-left-width: 1px; border-left-style: solid; width: 80%; border-bottom-color: rgb(153, 153, 153); border-bottom-width: 1px; border-bottom-style: solid; "><tbody><tr><td><font face="Simsun"> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> V get(Object key, int hash) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> if (count != 0) { // read-volatile<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> HashEntry e = getFirst(hash);<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> while (e != null) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> if (e.hash == hash &amp;&amp; key.equals(e.key)) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> V v = e.value;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> if (v != null)<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> return v;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> return readValueUnderLock(e); // recheck<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> e = e.next;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> return null;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }</font></td></tr></tbody></table></div><p> <wbr></p><table align="center" style="border-right-color: rgb(153, 153, 153); border-right-width: 1px; border-right-style: solid; border-top-color: rgb(153, 153, 153); border-top-width: 1px; border-top-style: solid; font-size: 12px; border-left-color: rgb(153, 153, 153); border-left-width: 1px; border-left-style: solid; width: 80%; border-bottom-color: rgb(153, 153, 153); border-bottom-width: 1px; border-bottom-style: solid; "><tbody><tr><td><font face="Simsun"> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> V readValueUnderLock(HashEntry e) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> lock();<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> try {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> return e.value;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> } finally {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> unlock();<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }</font></td></tr></tbody></table><p> <wbr></p><p> <wbr> <wbr> <wbr> put操作一上来就锁定了整个segment，这当然是为了并发的安全，修改数据是不能并发进行的，必须得有个判断是否超限的语句以确保容量不足时能够rehash，而比较难懂的是这句int index = hash &amp; (tab.length - 1)，原来segment里面才是真正的hashtable，即每个segment是一个传统意义上的hashtable,如上图，从两者的结构就可以看出区别，这里就是找出需要的entry在table的哪一个位置，之后得到的entry就是这个链的第一个节点，如果e!=null，说明找到了，这是就要替换节点的值（onlyIfAbsent == false），否则，我们需要new一个entry，它的后继是first，而让tab[index]指向它，什么意思呢？实际上就是将这个新entry插入到链头，剩下的就非常容易理解了。</p><table align="center" style="border-right-color: rgb(153, 153, 153); border-right-width: 1px; border-right-style: solid; border-top-color: rgb(153, 153, 153); border-top-width: 1px; border-top-style: solid; font-size: 12px; border-left-color: rgb(153, 153, 153); border-left-width: 1px; border-left-style: solid; width: 80%; border-bottom-color: rgb(153, 153, 153); border-bottom-width: 1px; border-bottom-style: solid; "><tbody><tr><td><p><font face="Simsun"> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> V put(K key, int hash, V value, boolean onlyIfAbsent) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> lock();<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> try {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> int c = count;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> if (c++ &gt; threshold) // ensure capacity<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> rehash();<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> HashEntry[] tab = table;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> int index = hash &amp; (tab.length - 1);<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> HashEntry first = (HashEntry) tab[index];<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> HashEntry e = first;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> e = e.next;</font></p><p><font face="Simsun"> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> V oldValue;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> if (e != null) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> oldValue = e.value;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> if (!onlyIfAbsent)<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> e.value = value;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> else {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> oldValue = null;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> ++modCount;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> tab[index] = new HashEntry(key, hash, first, value);<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> count = c; // write-volatile<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> return oldValue;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> } finally {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> unlock();<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }</font></p></td></tr></tbody></table><p> <wbr></p><p> <wbr> <wbr> <wbr> remove操作非常类似put，但要注意一点区别，中间那个for循环是做什么用的呢？（<em>号标记）从代码来看，就是将定位之后的所有entry克隆并拼回前面去，但有必要吗？每次删除一个元素就要将那之前的元素克隆一遍？这点其实是由entry的不变性来决定的，仔细观察entry定义，发现除了value，其他所有属性都是用final来修饰的，这意味着在第一次设置了next域之后便不能再改变它，取而代之的是将它之前的节点全都克隆一次。至于entry为什么要设置为不变性，这跟不变性的访问不需要同步从而节省时间有关，关于不变性的更多内容，请参阅之前的文章《线程高级—线程的一些编程技巧》</em></p><table align="center" style="border-right-color: rgb(153, 153, 153); border-right-width: 1px; border-right-style: solid; border-top-color: rgb(153, 153, 153); border-top-width: 1px; border-top-style: solid; font-size: 12px; border-left-color: rgb(153, 153, 153); border-left-width: 1px; border-left-style: solid; width: 80%; border-bottom-color: rgb(153, 153, 153); border-bottom-width: 1px; border-bottom-style: solid; "><tbody><tr><td><p><font face="Simsun"> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> V remove(Object key, int hash, Object value) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> lock();<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> try {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> int c = count - 1;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> HashEntry[] tab = table;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> int index = hash &amp; (tab.length - 1);<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> HashEntry first = (HashEntry)tab[index];<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> HashEntry e = first;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> e = e.next;</font></p><p><font face="Simsun"> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> V oldValue = null;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> if (e != null) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> V v = e.value;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> if (value == null || value.equals(v)) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> oldValue = v;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> // All entries following removed node can stay<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> // in list, but all preceding ones need to be<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> // cloned.<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> ++modCount;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> HashEntry newFirst = e.next;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> for (HashEntry p = first; p != e; p = p.next)<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr>* <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> newFirst = new HashEntry(p.key, p.hash, <wbr><br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> newFirst, p.value);<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> tab[index] = newFirst;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> count = c; // write-volatile<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> return oldValue;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> } finally {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> unlock();<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }</font></p></td></tr></tbody></table><p> <wbr></p><table align="center" style="border-right-color: rgb(153, 153, 153); border-right-width: 1px; border-right-style: solid; border-top-color: rgb(153, 153, 153); border-top-width: 1px; border-top-style: solid; font-size: 12px; border-left-color: rgb(153, 153, 153); border-left-width: 1px; border-left-style: solid; width: 80%; border-bottom-color: rgb(153, 153, 153); border-bottom-width: 1px; border-bottom-style: solid; "><tbody><tr><td><p><font face="Simsun"> <wbr> <wbr> <wbr> static final class HashEntry {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> final K key;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> final int hash;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> volatile V value;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> final HashEntry next;</font></p><p><font face="Simsun"> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> HashEntry(K key, int hash, HashEntry next, V value) {<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> this.key = key;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> this.hash = hash;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> this.next = next;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> this.value = value;<br> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> <wbr> }<br> <wbr> <wbr> <wbr> }</font></p></td></tr></tbody></table><p> <wbr></p><p> <wbr> <wbr> <wbr> 以上，分析了几个最简单的操作，限于篇幅，这里不再对rehash或iterator等实现进行讨论，有兴趣可以参考src。</p><p> <wbr> <wbr> <wbr> 接下来实际上还有一个疑问，ConcurrentHashMap跟HashMap相比较性能到底如何。这在Brian Goetz的文章中已经有过评测<font face="Simsun"><a href="http://www.ibm.com/developerworks/cn/java/j-jtp07233/" style="color: rgb(44, 88, 65); " target="_blank" rel="external"><font color="#0000FF">http://www.ibm.com/developerworks/cn/java/j-jtp07233/</font></a>。</font></p></span><br></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/07/Mysql-db-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/07/Mysql-db-01/" itemprop="url">转载:MySQL中的存储引擎讲解（InnoDB,MyISAM,Memory等各存储引擎对比）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-07T17:17:06+08:00">
                2017-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content"><br><br><p><span style="font-size:18px; color:#009900"><strong>MySQL中的存储引擎：</strong></span></p><br><p><span style="color:rgb(0,153,0)"><span style="font-size:14px">1、存储引擎的概念</span></span></p><br><p><span style="color:rgb(0,153,0)"><span style="font-size:14px">2、查看MySQL所支持的存储引擎</span></span></p><br><p><span style="color:rgb(0,153,0)"><span style="font-size:14px">3、MySQL中几种常用存储引擎的特点</span></span></p><br><p><span style="color:rgb(0,153,0)"><span style="font-size:14px">4、存储引擎之间的相互转化</span></span></p><br><p><span style="font-size:18px"><strong><span style="color:#ff6600">一、存储引擎</span></strong></span></p><br><p><span style="font-size:14px; color:#009900">1、存储引擎其实就是如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。</span></p><br><p><span style="font-size:14px; color:#009900">2、MySQL中的数据用各种不同的技术存储在文件（或内存）中，这些技术中的每一种技术都使用不同的存储机制，索引技巧，锁定水平并且最终提供广泛的不同功能和能力。在MySQL中将这些不同的技术及配套的相关功能称为存储引擎。</span></p><br><p><span style="font-size:18px"><span style="color:#ff6600"><strong>二、MySQL 中查看引擎</strong></span></span></p><br><p><span style="color:rgb(0,153,0)"><span style="font-size:14px">1、show&nbsp; engines;&nbsp;&nbsp; // 查看mysql所支持的存储引擎，以及从中得到mysql默认的存储引擎。</span></span></p><br><p><span style="color:rgb(0,153,0)"><span style="font-size:14px">2、show&nbsp; variables&nbsp; like ‘% storage_engine’;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;查看mysql&nbsp;默认的存储引擎</span></span></p><br><p><img src="http://img.blog.csdn.net/20150106223151155?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUUhfSkFWQQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" height="135" width="570"><br><br></p><br><p><span style="font-size:18px; color:#009900">3、show&nbsp;&nbsp;create&nbsp;&nbsp; table&nbsp; tablename ;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;查看具体某一个表所使用的存储引擎，这个默认存储引擎<span style="font-size:18px; color:#009900">被修改了！</span><br><br></span></p><br><p><span style="font-size:18px; color:#009900"><img src="http://img.blog.csdn.net/20150106222921332?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUUhfSkFWQQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" height="291" width="646"></span></p><br><p><br><br></p><br><p><span style="font-size:18px; color:#009900">4、show&nbsp; table&nbsp;&nbsp; status&nbsp; from&nbsp; database&nbsp; where&nbsp; name=&quot;tablename&quot;</span></p><br><p><span style="font-size:18px; color:#009900">//准确查看某个数据库中的某一表所使用的存储引擎</span></p><br><p><span style="font-size:18px; color:#009900"><img src="http://img.blog.csdn.net/20150106224114456?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUUhfSkFWQQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" height="198" width="907"><br><br></span></p><br><p><span style="font-size:18px"><span style="color:#ff6600"><strong>三、MySQL中常用的几种存储引擎：innoDB、myisam、memory、<span style="font-size:18px">BlackHole</span>以及这几个引擎的讲解</strong></span></span></p><br><p><span style="font-size:18px">innoDB存储引擎<br><br></span></p><br><p><span style="font-size:18px; color:#009900">（1） innodb存储引擎的mysql表提供了事务，回滚以及系统崩溃修复能力和多版本迸发控制的事务的安全。</span></p><br><p><span style="font-size:18px; color:#009900">（2）innodb支持自增长列（auto_increment）,自增长列的&#20540;不能为空，如果在使用的时候为空的话怎会进行自动存现有的&#20540;开始增&#20540;，如果有但是比现在的还大，则就保存这个&#20540;。</span></p><br><p><span style="font-size:18px; color:#009900">（3）innodb存储引擎支持外键（foreign key） ,外键所在的表称为子表而所依赖的表称为父表。</span></p><br><p><span style="font-size:18px; color:#009900">（4）innodb存储引擎最重要的是支持事务，以及事务相关联功能。</span></p><br><p><span style="font-size:18px; color:#009900">（5）innodb存储引擎支持mvcc的行级锁。</span></p><br><p><span style="color:#009900"><span style="font-size:18px">（6）innodb存储引擎索引使用的是B&#43;Tree</span></span></p><br><p><span style="font-size:18px; color:#009900">&nbsp; &nbsp;mvcc类&#20284;于java中的读锁具体介绍可以看这篇文章：<a href="http://blog.csdn.net/chosen0ne/article/details/18093187" target="_blank" rel="external">http://blog.csdn.net/chosen0ne/article/details/18093187</a></span></p><br><p><span style="font-size:18px">MyISAM存储引擎</span></p><br><p><span style="font-size:18px; color:#009900">1、MyISAM&nbsp;&nbsp; 这种存储引擎不支持事务，不支持行级锁，</span><span style="font-size:18px"><span style="color:#cc0000">只支持并发插入的表锁</span></span><span style="font-size:18px; color:#009900">，主要用于高负载的select。</span></p><br><p><span style="font-size:18px; color:#009900">2、<span style="color:rgb(0,153,0); font-size:18px">MyISAM&nbsp;&nbsp;&nbsp;</span>类型的表支持三种不同的存储结构：静态型、动态型、压缩型。</span></p><br><p><span style="font-size:18px; color:#009900">（1）静态型：就是定义的表列的大小是固定（即不含有：xblob、xtext、varchar等长度可变的数据类型），这样mysql就会自动使用静态myisam&#26684;式。</span></p><br><p><span style="font-size:18px; color:#009900">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用静态&#26684;式的表的性能比较高，因为在维护和访问的时候以预定&#26684;式存储数据时需要的开销很低。但是这高性能是有空间换来的，因为在定义的时候是固定的，所以不管列中的&#20540;有多大，都会以最大&#20540;为准，占据了整个空间。</span></p><br><p><span style="font-size:18px; color:#009900">（2）动态型：如果列（即使只有一列）定义为动态的（xblob, xtext, varchar等数据类型），这时myisam就自动使用动态型，虽然动态型的表占用了比静态型表较少的空间，但带来了性能的降低，因为如果某个字段的内容发生改变则其位置很可能需要移动，这样就会导致碎片的产生。随着数据变化的怎多，碎片就会增加，数据访问性能就会相应的降低。</span></p><br><p><span style="font-size:18px; color:#009900">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于因为碎片的原因而降低数据访问性，有两种解决办法：</span></p><br><p><span style="font-size:18px; color:#009900">&nbsp;&nbsp;&nbsp;&nbsp; @1、尽可能使用静态数据类型</span></p><br><p><span style="font-size:18px; color:#009900">&nbsp;&nbsp;&nbsp;&nbsp; @2、经常使用optimize&nbsp;&nbsp; table语句，他会整理表的碎片，恢复由于表的更新和删除导致的空间丢失。</span></p><br><p><span style="font-size:18px; color:#009900">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (如果存储引擎不支持&nbsp;optimize&nbsp; table&nbsp;&nbsp;&nbsp; 则可以转储并重新加载数据，这样也可以减少碎片)</span></p><br><p><span style="font-size:18px; color:#009900">（3）压缩型：如果在这个数据库中创建的是在整个生命周期内只读的表，则这种情况就是用myisam的压缩型表来减少空间的占用。</span></p><br><p><span style="font-size:18px; color:#009900">3、<span style="color:rgb(0,153,0); font-size:18px">MyISAM也是使用B&#43;tree索引但是和Innodb的在具体实现上有些不同。</span></span></p><br><p><span style="font-size:18px">MEMORY存储引擎</span></p><br><p><span style="font-size:18px; color:#009900">（1）memory存储引擎相比前面的一些存储引擎，有点不一样，其使用存储在内从中的数据来创建表，而且所有的数据也都存储在内存中。</span></p><br><p><span style="font-size:18px; color:#009900">（2）每个基于memory存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为.frm。该文件只存储表的结构，而其数据文件，都是存储在内存中，这样有利于对数据的快速处理，提高整个表的处理能力。</span></p><br><p><span style="font-size:18px; color:#009900">（3）memory存储引擎默认使用哈希（HASH）索引，其速度比使用B-&#43;Tree型要快，如果读者希望使用B树型，则在创建的时候可以引用。</span></p><br><p><span style="font-size:18px; color:#009900">（4）memory存储引擎文件数据都存储在内存中，如果mysqld进程发生异常，重启或关闭机器这些数据都会消失。所以memory存储引擎中的表的生命周期很短，一般只使用一次。</span></p><br><p><span style="font-size:18px">BlackHole存储引擎（黑洞引擎）</span></p><br><p><span style="font-size:18px; color:#009900">（1）支持事务，而且支持mvcc的行级锁，主要用于日志记录或同步归档，这个存储引擎除非有特别目的，否则不适合使用！</span></p><br><p><span style="font-size:18px"><span style="color:#ff6600"><strong>四、各存储引擎相互转化</strong></span></span></p><br><p><span style="font-size:18px; color:#009900">1、alter&nbsp; table&nbsp; tablename&nbsp; engine = INnodb /MyISAM/Memory&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 修改了这个表的存储引擎<br><br></span></p><br><p><span style="font-size:18px; color:#009900">优点：简单，而且适合所有的引擎。</span></p><br><p><span style="font-size:18px; color:#009900">缺点：（1）、这种转化方式需要大量的时间&nbsp;和I/O，mysql要执行从旧表&nbsp;到新表的一行一行的复制所以效率比较低</span></p><br><p><span style="font-size:18px; color:#009900">（2）、在转化这期间源表加了读锁</span></p><br><p><span style="font-size:18px; color:#009900">（3）、从一种引擎到另一种引擎做表转化，所有属于原始引擎的专用特性都会丢失，比如从innodb到&nbsp;myisam&nbsp;则&nbsp;innodb的索引会丢失！</span></p><br><p><span style="font-size:18px; color:#009900">2、使用dump（转储）&nbsp;import（导入）</span></p><br><p><span style="font-size:18px; color:#009900">优点：使用mysqldump这个工具将修改的数据导出后会以 .sql&nbsp;的文件保存，你可以对这个文件进行操作，所以你有更多更好的控制，&nbsp;如修改表名，修改存储引擎等！</span></p><br><p><span style="font-size:18px; color:#009900">看看导出的一个表：</span></p><br><p><span style="font-size:18px; color:#009900"><img src="http://img.blog.csdn.net/20150106232647565?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUUhfSkFWQQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" height="90" width="600"></span></p><br><p><span style="font-size:18px; color:#009900"><img src="http://img.blog.csdn.net/20150106232849355?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUUhfSkFWQQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p><br><p><span style="font-size:18px; color:#009900"><img src="http://img.blog.csdn.net/20150106232845781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUUhfSkFWQQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p><br><p><span style="font-size:18px; color:#009900">以上就是使用mysqldump&nbsp;导出来的表&nbsp;即&nbsp;一个 .sql&nbsp;文件&nbsp;你可以按照需求编写这个文件，在将这个文件导入就ok!</span></p><br><p><span style="font-size:18px; color:#009900">3、第一种方式简便，第二种方式安全，这第三种方式就算是前两种方式的折中吧，&nbsp;create&nbsp; select:</span></p><br><p><span style="font-size:18px; color:#009900">(1)、&nbsp;create&nbsp;&nbsp;table&nbsp;&nbsp; newtable&nbsp; like&nbsp; oldtable;</span></p><br><p><span style="font-size:18px; color:#009900">(2)、alter&nbsp; table&nbsp; newtable engine= innodb/ myisam / memory<br><br></span></p><br><p><span style="font-size:18px; color:#009900">(3)、insert&nbsp; into&nbsp; newtable&nbsp; select <em> from&nbsp; oldtable;</em></span></p><br><p><span style="font-size:18px; color:#009900">如果数据量不大的话这种方式还是挺好的！</span></p><br><p><span style="font-size:18px; color:#009900">还有更高效的办法就是&nbsp;增量填充，在填充完每个增量数据块之后提交一次事务，这样就不会导致撤销日志文件过大；</span></p><br><p><span style="font-size:18px; color:#009900">（1）start&nbsp; transaction</span></p><br><p><span style="font-size:18px; color:#009900">（2）insert&nbsp;into&nbsp;newtable&nbsp;&nbsp;select &nbsp;&nbsp;from&nbsp;oldtable&nbsp; where&nbsp; id(主键)&nbsp;between x and y;</span></p><br><p><span style="font-size:18px; color:#009900">（3）&nbsp;commit</span></p><br><p><span style="font-size:18px; color:#009900">这样等数据填充之后有了需要的新表，旧表也存在，不需要的haunt可以删除，很方便！<br><br></span></p><br><p><br><br></p><br><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/05/sysgc_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/05/sysgc_01/" itemprop="url">转载:java 垃圾回收 常用算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-05T17:05:04+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="blog_content" class="blog_content"><br>    <div style="font-size: 14px;" class="iteye-blog-content-contain"><br>    <h2 style="margin-top: 5px; margin-bottom: 5px; border: 0px; vertical-align: baseline; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial; font-size: 1.6em !important;">垃圾收集基础</h2><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; margin-top: 5px !important; font-size: 1.166em !important;">Java 语言的一大特点就是可以进行自动垃圾回收处理，而无需开发人员过于关注系统资源，例如内存资源的释放情况。自动垃圾收集虽然大大减轻了开发人员的工作量，但是也增加了软件系统的负担。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">拥有垃圾收集器可以说是 Java 语言与 C++语言的一项显著区别。在 C++语言中，程序员必须小心谨慎地处理每一项内存分配，且内存使用完后必须手工释放曾经占用的内存空间。当内存释放不够完全时，即存在分配但永不释放的内存块，就会引起内存泄漏，严重时甚至导致程序瘫痪。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">以下列举了垃圾回收器常用的算法及实验原理：</p><br>    <ul style="border: 0px; font-size: 1.166em; vertical-align: baseline; margin-bottom: 0px; padding-bottom: 8px; color: #333333; line-height: 1.5em; font-family: Arial, sans-serif;" class="ibm-bullet-list"><br>    <li style="margin-bottom: 0px; margin-left: 0px; padding-top: 5px; padding-bottom: 5px; padding-left: 11px; border: 0px; font-size: inherit; vertical-align: baseline; height: 27px; clear: left;"><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; color: #222222; line-height: 1.5em; font-size: 1em !important;">引用计数法 (Reference Counting)</p><br>    </li><br>    </ul><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">引用计数器在微软的 COM 组件技术中、Adobe 的 ActionScript3 种都有使用。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">引用计数器的实现也非常简单，只需要为每个对象配置一个整形的计数器即可。但是引用计数器有一个严重的问题，即无法处理循环引用的情况。因此，在 Java 的垃圾回收器中没有使用这种算法。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">一个简单的循环引用问题描述如下：有对象 A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;"><strong>关键词：被引用对象计数+1，引用失效计数-1，但是循环引用就有问题了。</strong></p><br>    <ul style="border: 0px; font-size: 1.166em; vertical-align: baseline; margin-bottom: 0px; padding-bottom: 8px; color: #333333; line-height: 1.5em; font-family: Arial, sans-serif;" class="ibm-bullet-list"><br>    <li style="margin-bottom: 0px; margin-left: 0px; padding-top: 5px; padding-bottom: 5px; padding-left: 11px; border: 0px; font-size: inherit; vertical-align: baseline; height: 27px; clear: left;"><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; color: #222222; line-height: 1.5em; font-size: 1em !important;">标记-清除算法 (Mark-Sweep)</p><br>    </li><br>    </ul><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。该算法最大的问题是存在大量的空间碎片，因为回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;"><strong>关键词：从根开始扫描，被引用对象被标记，未被引用的对象在清除阶段被删除，但是删除后的内存不连续了，不利于大对象的内存分配</strong></p><br>    <ul style="border: 0px; font-size: 1.166em; vertical-align: baseline; margin-bottom: 0px; padding-bottom: 8px; color: #333333; line-height: 1.5em; font-family: Arial, sans-serif;" class="ibm-bullet-list"><br>    <li style="margin-bottom: 0px; margin-left: 0px; padding-top: 5px; padding-bottom: 5px; padding-left: 11px; border: 0px; font-size: inherit; vertical-align: baseline; height: 27px; clear: left;"><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; color: #222222; line-height: 1.5em; font-size: 1em !important;">复制算法 (Copying)</p><br>    </li><br>    </ul><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">Java 的新生代串行垃圾回收器中使用了复制算法的思想。新生代分为 eden 空间、from 空间、to 空间 3 个部分。其中 from 空间和 to 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。from 和 to 空间也称为 survivor 空间，即幸存者空间，用于存放未被回收的对象。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">在垃圾回收时，eden 空间中的存活对象会被复制到未使用的 survivor 空间中 (假设是 to)，正在使用的 survivor 空间 (假设是 from) 中的年轻对象也会被复制到 to 空间中 (大对象，或者老年对象会直接进入老年带，如果 to 空间已满，则对象也会直接进入老年代)。此时，eden 空间和 from 空间中的剩余对象就是垃圾对象，可以直接清空，to 空间则存放此次回收后的存活对象。这种改进的复制算法既保证了空间的连续性，又避免了大量的内存空间浪费。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;"><strong>关键词：两个内存空间，复制引用对象至另一个内存空间，删除剩余全部对象，需要建立在存活对象少，垃圾对象多的前提下，且内存折半了。</strong></p><br>    <ul style="border: 0px; font-size: 1.166em; vertical-align: baseline; margin-bottom: 0px; padding-bottom: 8px; color: #333333; line-height: 1.5em; font-family: Arial, sans-serif;" class="ibm-bullet-list"><br>    <li style="margin-bottom: 0px; margin-left: 0px; padding-top: 5px; padding-bottom: 5px; padding-left: 11px; border: 0px; font-size: inherit; vertical-align: baseline; height: 27px; clear: left;"><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; color: #222222; line-height: 1.5em; font-size: 1em !important;">标记-压缩算法 (Mark-Compact)</p><br>    </li><br>    </ul><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。也首先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;"><strong>关键词：从根开始扫描，将存活对象压缩至内存一端，然后清理边界所有内存空间</strong></p><br>    <ul style="border: 0px; font-size: 1.166em; vertical-align: baseline; margin-bottom: 0px; padding-bottom: 8px; color: #333333; line-height: 1.5em; font-family: Arial, sans-serif;" class="ibm-bullet-list"><br>    <li style="margin-bottom: 0px; margin-left: 0px; padding-top: 5px; padding-bottom: 5px; padding-left: 11px; border: 0px; font-size: inherit; vertical-align: baseline; height: 27px; clear: left;"><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; color: #222222; line-height: 1.5em; font-size: 1em !important;">增量算法 (Incremental Collecting)</p><br>    </li><br>    </ul><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">在垃圾回收过程中，应用软件将处于一种 CPU 消耗很高的状态。在这种 CPU 消耗很高的状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;"><strong>关键词：垃圾回收时应用程序被挂起，交替垃圾回收和应用程序执行，减少系统停顿时间。</strong></p><br>    <ul style="border: 0px; font-size: 1.166em; vertical-align: baseline; margin-bottom: 0px; padding-bottom: 8px; color: #333333; line-height: 1.5em; font-family: Arial, sans-serif;" class="ibm-bullet-list"><br>    <li style="margin-bottom: 0px; margin-left: 0px; padding-top: 5px; padding-bottom: 5px; padding-left: 11px; border: 0px; font-size: inherit; vertical-align: baseline; height: 27px; clear: left;"><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; color: #222222; line-height: 1.5em; font-size: 1em !important;">分代 (Generational Collecting)</p><br>    </li><br>    </ul><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">根据垃圾回收对象的特性，不同阶段最优的方式是使用合适的算法用于本阶段的垃圾回收，分代算法即是基于这种思想，它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。以 Hot Spot 虚拟机为例，它将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。在老生代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老生代，将需要复制大量对象。再加上老生代的回收性价比也要低于新生代，因此这种做法也是不可取的。根据分代的思想，可以对老年代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;"><strong>关键词：不同代使用不同算法，新建对象放入年轻代内存-&gt;对象很快会回收，使用复制算法， 几次回收依然存活的放入老年代内存 -&gt;使用标记-压缩算法</strong></p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">从不同角度分析垃圾收集器，可以将其分为不同的类型。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">1. 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。串行垃圾回收器一次只使用一个线程进行垃圾回收；并行垃圾回收器一次将开启多个线程同时进行垃圾回收。在并行能力较强的 CPU 上，使用并行垃圾回收器可以缩短 GC 的停顿时间。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">2. 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间；独占式垃圾回收器 (Stop the world) 一旦运行，就停止应用程序中的其他所有线程，直到垃圾回收过程完全结束。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">3. 按碎片处理方式可分为压缩式垃圾回收器和非压缩式垃圾回收器。压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片；非压缩式的垃圾回收器不进行这步操作。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">4. 按工作的内存区间，又可分为新生代垃圾回收器和老年代垃圾回收器。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">可以用以下指标评价一个垃圾处理器的好坏。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">吞吐量：指在应用程序的生命周期内，应用程序所花费的时间和系统总运行时间的比值。系统总运行时间=应用程序耗时+GC 耗时。如果系统运行了 100min，GC 耗时 1min，那么系统的吞吐量就是 (100-1)/100=99%。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">垃圾回收器负载：和吞吐量相反，垃圾回收器负载指来记回收器耗时与系统运行总时间的比值。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">停顿时间：指垃圾回收器正在运行时，应用程序的暂停时间。对于独占回收器而言，停顿时间可能会比较长。使用并发的回收器时，由于垃圾回收器和应用程序交替运行，程序的停顿时间会变短，但是，由于其效率很可能不如独占垃圾回收器，故系统的吞吐量可能会较低。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">垃圾回收频率：指垃圾回收器多长时间会运行一次。一般来说，对于固定的应用而言，垃圾回收器的频率应该是越低越好。通常增大堆空间可以有效降低垃圾回收发生的频率，但是可能会增加回收产生的停顿时间。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">反应时间：指当一个对象被称为垃圾后多长时间内，它所占据的内存空间会被释放。</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;">堆分配：不同的垃圾回收器对堆内存的分配方式可能是不同的。一个良好的垃圾收集器应该有一个合理的堆内存区间划</p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;"> </p><br>    <p style="padding-top: 6px; padding-bottom: 6px; border: 0px; vertical-align: baseline; font-family: Arial, sans-serif; color: #222222; line-height: 1.5em; font-size: 1.166em !important;"> </p><br>    <h2>Java的内存分布</h2><br>    <p>在JVM中，内存是按照分代进行组织的。<br><img alt="" src="http://www.processon.com/chart_image/53698d6e0cf21db1c3ec9394.png"></p><br>    <p>其中，堆内存分为年轻代和年老代，非堆内存主要是Permanent区域，主要用于存储一些类的元数据，常量池等信息。而年轻代又分为两种，一种是Eden区域，另外一种是两个大小对等的Survivor区域。之所以将Java内存按照分代进行组织，主要是基于这样一个<strong>“弱假设” - 大多数对象都在年轻时候死亡</strong>。同时，将内存按照分代进行组织，使得我们可以在不同的分代上使用不同的垃圾回收算法，使得整个内存的垃圾回收更加有效。</p><br>    <h2>年轻代的垃圾回收</h2><br>    <p>在年轻代上采用的垃圾回收算法是“Mark-Copy”算法，并不同于我们前面所了解的任何一种基本垃圾回收算法，但是Mark算法是一样的，基于根对象找到所有的可达对象，具体可看<a href="http://jianshu.io/p/b0f5d21fe031" target="_blank">Mark-Sweep算法</a>中的Mark步骤. 而对于Copy算法，它仅仅是简单的将符合一定年龄的对象从一个分代拷贝到另一个分代。具体的回收过程如下：</p><br>    <p><img alt="" src="http://www.processon.com/chart_image/536999160cf21db1c3ecd182.png"></p><br>    <p>首先，新对象的内存分配都是先在Eden区域中进行的，当Eden区域的空间不足于分配新对象时，就会触发年轻代上的垃圾回收（发生在Eden和Survivor内存区域上），我们称之为”minor garbage collection”.同时，每个对象都有一个“年龄”，这个年龄实际上指的就是该对象经历过的minor gc的次数。如图1所示，当对象刚分配到Eden区域时，对象的年龄为“0”，当minor gc被触发后，所有存活的对象（仍然可达对象）会被拷贝到其中一个Survivor区域，同时年龄增长为“1”。并清除整个Eden内存区域中的非可达对象。</p><br>    <p>当第二次minor gc被触发时（如图2所示），JVM会通过Mark算法找出所有在Eden内存区域和Survivor1内存区域存活的对象，并将他们拷贝到新的Survivor2内存区域(这也就是为什么需要两个大小一样的Survivor区域的原因)，同时对象的年龄加1. 最后，清除所有在Eden内存区域和Survivor1内存区域的非可达对象。</p><br>    <p>当对象的年龄足够大（这个年龄可以通过JVM参数进行指定，这里假定是2），当minor gc再次发生时，它会从Survivor内存区域中升级到年老代中，如图3所示。</p><br>    <p>其实，即使对象的年龄不够大，但是Survivor内存区域中没有足够的空间来容纳从Eden升级过来的对象时，也会有部分对象直接升级到Tenured内存区域中。</p><br>    <h2>年老代的垃圾回收</h2><br>    <p>当minor gc发生时，又有对象从Survivor区域升级到Tenured区域，但是Tenured区域已经没有空间容纳新的对象了，那么这个时候就会触发年老代上的垃圾回收，我们称之为”major garbage collection”.</p><br>    <p>而在年老代上选择的垃圾回收算法则取决于JVM上采用的是什么垃圾回收器。通过的垃圾回收器有两种：Parallel Scavenge(PS) 和Concurrent Mark Sweep(CMS)。这两种垃圾回收器的不同更多的是体现在年老代的垃圾回收过程中，年轻代的垃圾回收过程在这两种垃圾回收器中基本上是一致的。</p><br>    <p>就像其名字所表示的那样，Parallel Scavenge垃圾回收器在执行垃圾回收时使用了多线程来一起进行垃圾回收，这样可以提高垃圾回收的效率。而Concurrent Mark Sweep垃圾回收器在进行垃圾回收时，应用程序可以同时运行。</p><br>    <h3>Parallel Scavenge</h3><br>    <p>PS垃圾回收器在年老代上采用的垃圾回收算法可以看作是<a href="http://jianshu.io/p/b0f5d21fe031" target="_blank">标记-清除算法</a>和<a href="http://jianshu.io/p/698eb5e1ccb9" target="_blank">标记-压缩算法</a>的结合体。</p><br>    <p>首先，PS垃圾回收器先是会在年老代上使用标记-清除算法来回收掉非可达对象所占有的空间，但是我们知道，标记清除算法的一个缺陷就是它会引起内存碎片问题。继而有可能会引发连续的major gc。假设当前存在的内存碎片有10M，但最大的内存碎片只能容纳2M的对象，这个时候如果有一个3M的对象从Survivor区域升级到Tenured区域，那Tenured区域也没有办法存放这个3M的对象。结果就是不断的触发major gc，直到Out of Memory。所以，PS垃圾回收器在清除非可达对象后，还会进行一次compact，来消除内存碎片。</p><br>    <p><img alt="" src="http://www.processon.com/chart_image/5369c0e90cf21db1c3edb1aa.png"></p><br>    <h3>Concurrent Mark Sweep</h3><br>    <p>CMS垃圾收集器相比于PS垃圾收集器，它成功的减少了垃圾收集时暂停应用程序的时间，因为CMS在进行垃圾收集时，应用程序是可以并行运行的。下面让我们来看看它是怎么做到的。</p><br>    <p>从它的名字可以看出，CMS垃圾收集器在年老代上采用的垃圾回收算法是标记-清除算法。但是，它跟标准的标记-清除算法略有不同。它主要分为四个阶段：</p><br>    <ol><br>    <li><br>    <strong>Initial Mark阶段</strong> - 这个阶段是Stop-The-World的，它会暂停应用程序的运行，但是在这里阶段，它不会标记出在Tenured区域中所有的可达对象。它只会从根对象开始出发，标记到根对象的第一层孩子节点即停止。然后恢复应用程序的运行。所以，这个暂停应用程序的时间是很短的。</li><br>    <li><br>    <strong>Concurrent Mark阶段</strong> - 在这个阶段中，CMS垃圾回收器以Initial Mark阶段标记的节点为根对象，重新开始标记Tenured区域中的可达对象。当然，在这个阶段中是不需要暂停应用程序的。这也是它称为”Concurrent Mark”的原因。这同时也造成了一个问题，那就是由于CMS垃圾回收器和应用程序同时运行，Concurrent Mark阶段它并不保证在Tenured区域的可达对象都被标记了 - 应用程序一直在分配新对象。</li><br>    <li><br>    <strong>Remark阶段</strong> - 由于Concurrent Mark阶段它并不保证在Tenured区域的可达对象都被标记了，所以我们需要再次暂停应用程序，确保所有的可达对象都被标记。为了加快速度，这里也采用了多线程来同时标记可达对象。</li><br>    <li><br>    <strong>Concurrent Sweep阶段</strong> - 最后，恢复应用程序的执行，同时CMS执行sweep，来清除所有非可达对象所占用的内存空间。</li><br>    </ol><br>    <p>从下图可以看到PS和CMS垃圾收集器的区别：<br><img alt="" src="http://www.processon.com/chart_image/5369dd770cf21db1c3ee6a1a.png"></p><br>    <p>黑色箭头代表应用程序的运行，绿色箭头代表CMS垃圾收集器的运行。一根线条表示单线程，多个线条表示多线程。</p><br>    <p>所以，相比于PS垃圾收集器，CMS垃圾收集器成功的减少了应用程序暂时的时间。</p><br>    <h2>Garbage First(G1)垃圾收集器</h2><br>    <p>但是很不幸的是，CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是由于它没有Compact阶段，它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器 - G1垃圾收集器。它会在未来逐步替换掉CMS垃圾收集器。</p><br>    <p>G1垃圾收集器和CMS垃圾收集器有几点不同。首先，最大的不同是内存的组织方式变了。Eden，Survivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region - 每个region从1M到32M不等。</p><br>    <p><img alt="" src="http://www.processon.com/chart_image/536b116e0cf290134a2ef1d9.png"></p><br>    <p>一个region有可能属于Eden，Survivor或者Tenured内存区域。图中的E表示该region属于Eden内存区域，S表示属于Survivor内存区域，T表示属于Tenured内存区域。图中空白的表示未使用的内存空间。G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。这种内存区域主要用于存储大对象-即大小超过一个region大小的50%的对象。</p><br>    <p>在G1垃圾收集器中，年轻代的垃圾回收过程跟PS垃圾收集器和CMS垃圾收集器差不多，新对象的分配还是在Eden region中，当所有Eden region的大小超过某个值时，触发minor gc，回收Eden region和Survivor region上的非可达对象，同时升级存活的可达对象到对应的Survivor region和Tenured region上。对象从Survivor region升级到Tenured region依然是取决于对象的年龄。<br><img alt="" src="http://www.processon.com/chart_image/536b17f90cf290134a2f01fd.png"></p><br>    <p>对于年老代上的垃圾收集，G1垃圾收集器也分为4个阶段，基本跟CMS垃圾收集器一样，但略有不同：</p><br>    <ol><br>    <li><br>    <strong>Initial Mark阶段</strong> - 同CMS垃圾收集器的Initial Mark阶段一样，G1也需要暂停应用程序的执行，它会标记从根对象出发，在根对象的第一层孩子节点中标记所有可达的对象。但是G1的垃圾收集器的Initial Mark阶段是跟minor gc一同发生的。也就是说，在G1中，你不用像在CMS那样，单独暂停应用程序的执行来运行Initial Mark阶段，而是在G1触发minor gc的时候一并将年老代上的Initial Mark给做了。</li><br>    <li><br>    <strong>Concurrent Mark阶段</strong> - 在这个阶段G1做的事情跟CMS一样。但G1同时还多做了一件事情，那就是，如果在Concurrent Mark阶段中，发现哪些Tenured region中对象的存活率很小或者基本没有对象存活，那么G1就会在这个阶段将其回收掉，而不用等到后面的clean up阶段。这也是Garbage First名字的由来。同时，在该阶段，G1会计算每个 region的对象存活率，方便后面的clean up阶段使用 。</li><br>    <li><br>    <strong>Remark阶段</strong> - 在这个阶段G1做的事情跟CMS一样, 但是采用的算法不同，G1采用一种叫做SATB(snapshot-at-the-begining)的算法能够在Remark阶段更快的标记可达对象。</li><br>    <li><br>    <strong>Clean up/Copy阶段</strong> - 在G1中，没有CMS中对应的Sweep阶段。相反 它有一个Clean up/Copy阶段，在这个阶段中,G1会挑选出那些对象存活率低的region进行回收，这个阶段也是和minor gc一同发生的,如下图所示：<br><img alt="" src="http://www.processon.com/chart_image/536b68100cf290134a30ecb4.png"><br>    </li><br>    </ol><br>    <p>从上可以看到，由于<strong>Initial Mark阶段</strong>和<strong>Clean up/Copy阶段</strong>都是跟minor gc同时发生的，相比于CMS，G1暂停应用程序的时间更少，从而提高了垃圾回收的效率。</p><br></div><br>    </div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/05/jvm-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/05/jvm-01/" itemprop="url">转载:JVM原理及性能调优</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-05T16:53:53+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_details" class="details"><br>    <div class="article_title"><br>         <span class="ico ico_type_Repost"></span><br><br><br>    <h1><br>        <span class="link_title"><a href="/ning109314/article/details/10411495"><br>        JVM原理和优化<br>        </a></span><br>    </h1><br></div><br><p>JVM工作原理和特点主要是指操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境. </p><br><p>1.创建JVM装载环境和配置 </p><br><p>2.装载JVM.dll </p><br><p>3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例 </p><br><p>4.调用JNIEnv实例装载并处理class类。 </p><br><p></p><br><p>在我们运行和调试Java程序的时候,经常会提到一个JVM的概念.JVM是Java程序运行的环境,但是他同时一个操作系统的一个应用程序一个进程,因此他也有他自己的运行的生命周期,也有自己的代码和数据空间.<br></p><br><p>首先来说一下JVM工作原理中的jdk这个东西,不管你是初学者还是高手,是j2ee程序员还是j2se程序员,jdk总是在帮我们做一些事情.我们在了解Java之前首先大师们会给我们提供说jdk这个东西.它在Java整个体系中充当着什么角色呢?我很惊叹sun大师们设计天才,能把一个如此完整的体系结构化的如此完美.jdk在这个体系中充当一个生产加工中心,产生所有的数据输出,是所有指令和战略的执行中心.本身它提供了Java的完整方案,可以开发目前Java能支持的所有应用和系统程序.这里说一个问题,大家会问,那为什么还有j2me,j2ee这些东西,这两个东西目的很简单,分别用来简化各自领域内的开发和构建过程.jdk除了JVM之外,还有一些核心的API,集成API,用户工具,开发技术,开发工具和API等组成<br></p><br><p>好了,废话说了那么多,来点于主题相关的东西吧.JVM在整个jdk中处于最底层,负责于操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也就虚拟计算机. 操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境.<br></p><br><p>1.创建JVM装载环境和配置 </p><br><p>2.装载JVM.dll </p><br><p>3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例 </p><br><p>4.调用JNIEnv实例装载并处理class类。 </p><br><p><strong>一．JVM装入环境，JVM提供的方式是操作系统的动态连接文件．</strong>既然是文件那就一个装入路径的问题，Java是怎么找这个路径的呢？当你在调用Java test的时候，操作系统会在path下在你的Java.exe程序，Java.exe就通过下面一个过程来确定JVM的路径和相关的参数配置了．下面基于Windows的实现的分析．<br></p><br><p>首先查找jre路径，Java是通过GetApplicationHome api来获得当前的Java.exe绝对路径，c:\j2sdk1.4.2_09\bin\Java.exe,那么它会截取到绝对路径c:\j2sdk1.4.2_09\，判断c:\j2sdk1.4.2_09\bin\Java.dll文件是否存在，如果存在就把c:\j2sdk1.4.2_09\作为jre路径，如果不存在则判断c:\j2sdk1.4.2_09\jre\bin\Java.dll是否存在，如果存在这c:\j2sdk1.4.2_09\jre作为jre路径．如果不存在调用GetPublicJREHome查HKEY_LOCAL_MACHINE\Software\JavaSoft\Java<br> Runtime Environment\“当前JRE版本号”\JavaHome的路径为jre路径。 </p><br><p>然后装载JVM.cfg文件JRE路径&#43;\lib&#43;\ARCH（CPU构架）&#43;\JVM.cfgARCH（CPU构架）的判断是通过Java_md.c中GetArch函数判断的，该函数中windows平台只有两种情况：WIN64的‘ia64’，其他情况都为‘i386’。以我的为例：C:\j2sdk1.4.2_09\jre\lib\i386\JVM.cfg.主要的内容如下：<br></p><br><pre><ol class="dp-xml"><li class="alt"><span>-client&nbsp;KNOWN&nbsp; &nbsp;</span></li><li><span>-server&nbsp;KNOWN&nbsp; &nbsp;</span></li><li class="alt"><span>-hotspot&nbsp;ALIASED_TO&nbsp;-client&nbsp; &nbsp;</span></li><li><span>-classic&nbsp;WARN&nbsp; &nbsp;</span></li><li class="alt"><span>-native&nbsp;ERROR&nbsp; &nbsp;</span></li><li><span>-green&nbsp;ERROR&nbsp;&nbsp;</span></li></ol></pre><br><p>在我们的jdk目录中jre\bin\server和jre\bin\client都有JVM.dll文件存在，而Java正是通过JVM.cfg配置文件来管理这些不同版本的JVM.dll的．通过文件我们可以定义目前jdk中支持那些JVM,前面部分（client）是JVM名称，后面是参数，KNOWN表示JVM存在，ALIASED_TO表示给别的JVM取一个别名，WARN表示不存在时找一个JVM替代，ERROR表示不存在抛出异常．在运行Java XXX是，Java.exe会通过CheckJVMType来检查当前的JVM类型，Java可以通过两种参数的方式来指定具体的JVM类型，一种按照JVM.cfg文件中的JVM名称指定，第二种方法是直接指定，它们执行的方法分别是“Java<br> -J”、“Java -XXaltJVM=”或“Java -J-XXaltJVM=”。如果是第一种参数传递方式，CheckJVMType函数会取参数‘-J’后面的JVM名称，然后从已知的JVM配置参数中查找如果找到同名的则去掉该JVM名称前的‘-’直接返回该&#20540;；而第二种方法，会直接返回“-XXaltJVM=”或“-J-XXaltJVM=”后面的JVM类型名称；如果在运行Java时未指定上面两种方法中的任一一种参数，CheckJVMType会取配置文件中第一个配置中的JVM名称，去掉名称前面的‘-’返回该&#20540;。CheckJVMType函数的这个返回&#20540;会在下面的函数中汇同jre路径组合成JVM.dll的绝对路径。如果没有指定这会使用JVM.cfg中第一个定义的JVM.可以通过set<br> _Java_LAUNCHER_DEBUG=1在控制台上测试． </p><br><p>最后获得JVM.dll的路径，JRE路径&#43;\bin&#43;\JVM类型字符串&#43;\JVM.dll就是JVM的文件路径了，但是如果在调用Java程序时用-XXaltJVM=参数指定的路径path,就直接用path&#43;\JVM.dll文件做为JVM.dll的文件路径．<br></p><br><p><strong>二：装载JVM.dll</strong> </p><br><p>通过第一步已经找到了JVM的路径，Java通过LoadJavaVM来装入JVM.dll文件．装入工作很简单就是调用Windows API函数： </p><br><p>LoadLibrary装载JVM.dll动态连接库．然后把JVM.dll中的导出函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMInitArgs挂接到InvocationFunctions变量的CreateJavaVM和GetDefaultJavaVMInitArgs函数指针变量上。JVM.dll的装载工作宣告完成。<br></p><br><p><strong>三：初始化JVM，获得本地调用接口，</strong>这样就可以在Java中调用JVM的函数了．调用InvocationFunctions－&gt;CreateJavaVM也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例．<br></p><br><p><strong>四：运行Java程序．</strong> </p><br><p>Java程序有两种方式一种是jar包，一种是class. 运行jar,Java -jar XXX.jar运行的时候，Java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用Java类Java.util.jar.JarFileJNIEnv中方法getManifest()并从返回的Manifest对象中取getAttributes(&quot;Main-Class&quot;)的&#20540;即jar包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。main函数直接调用Java.c中LoadClass方法装载该类。如果是执行class方法。main函数直接调用Java.c中LoadClass方法装载该类。<br></p><br><p>然后main函数调用JNIEnv实例的GetStaticMethodID方法查找装载的class主类中 </p><br><p>“public static void main(String[] args)”方法，并判断该方法是否为public方法，然后调用JNIEnv实例的 </p><br><p>CallStaticVoidMethod方法调用该Java类的main方法。&nbsp; </p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br>以下转自：<a target="_blank" href="http://blog.csdn.net/cnhzgb/article/details/7179419">http://blog.csdn.net/cnhzgb/article/details/7179419</a><span style="font-size:24px"><strong></strong></span></p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; padding-top:2px"><br><span style="font-size:24px"><strong>= GC 基础 =====================</strong></span></p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; font-size:12px; padding-top:2px"><br><br><br></p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; font-size:12px; padding-top:2px"><br>JAVA堆的描述如下：</p><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial,Verdana,sans-serif; font-size:12px; padding-top:2px"><br><img alt="" src="http://hi.csdn.net/attachment/201201/6/0_1325814932X3Ts.gif"><br style="line-height:normal"><br>内存由 Perm 和 Heap 组成. 其中<br><br>Heap = {Old &#43; NEW = { Eden , from, to } }<br><br>JVM内存模型中分两大块，一块是 NEW Generation, 另一块是Old Generation. 在New Generation中，有一个叫Eden的空间，主要是用来存放新生的对象，还有两个Survivor Spaces（from,to）, 它们用来存放每次垃圾回收后存活下来的对象。在Old Generation中，主要存放应用程序中生命周期长的内存对象，还有个Permanent Generation，主要用来放JVM自己的反射对象，比如类对象和方法对象等。<br><br>垃圾回收描述：<br><br>在New Generation块中，垃圾回收一般用Copying的算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个Survivor Space, 当Survivor Space空间满了后, 剩下的live对象就被直接拷贝到Old Generation中去。因此，每次GC后，Eden内存块会被清空。在Old Generation块中，垃圾回收一般用mark-compact的算法，速度慢些，但减少内存要求.<br><br>垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收NEW中的垃圾，内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。<br><br><br><br><br><br>当一个URL被访问时，内存申请过程如下：<br><br>A. JVM会试图为相关Java对象在Eden中初始化一块内存区域<br><br>B. 当Eden空间足够时，内存申请结束。否则到下一步<br><br>C. JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）, 释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区<br><br>D. Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区<br><br>E. 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级）<br><br>F. 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”<br><br>JVM调优建议:<br><br>ms/mx：定义YOUNG&#43;OLD段的总尺寸，ms为JVM启动时YOUNG&#43;OLD的内存大小；mx为最大可占用的YOUNG&#43;OLD内存大小。在用户生产环境上一般将这两个&#20540;设为相同，以减少运行期间系统在内存申请上所花的开销。<br><br>NewSize/MaxNewSize：定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小；MaxNewSize为最大可占用的YOUNG内存大小。在用户生产环境上一般将这两个&#20540;设为相同，以减少运行期间系统在内存申请上所花的开销。<br><br>PermSize/MaxPermSize：定义Perm段的尺寸，PermSize为JVM启动时Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个&#20540;设为相同，以减少运行期间系统在内存申请上所花的开销。<br><br>SurvivorRatio：设置Survivor空间和Eden空间的比例<br><br>内存溢出的可能性<br><br><br><br><br><br>1. OLD段溢出<br><br>这种内存溢出是最常见的情况之一，产生的原因可能是：<br><br>1) 设置的内存参数过小(ms/mx, NewSize/MaxNewSize)<br><br>2) 程序问题<br><br>单个程序持续进行消耗内存的处理，如循环几千次的字符串处理，对字符串处理应建议使用StringBuffer。此时不会报内存溢出错，却会使系统持续垃圾收集，无法处理其它请求，相关问题程序可通过Thread Dump获取（见系统问题诊断一章）单个程序所申请内存过大，有的程序会申请几十乃至几百兆内存，此时JVM也会因无法申请到资源而出现内存溢出，对此首先要找到相关功能，然后交予程序员修改，要找到相关程序，必须在Apache日志中寻找。<br><br>当Java对象使用完毕后，其所引用的对象却没有销毁，使得JVM认为他还是活跃的对象而不进行回收，这样累计占用了大量内存而无法释放。由于目前市面上还没有对系统影响小的内存分析工具，故此时只能和程序员一起定位。<br><br>2. Perm段溢出<br><br>通常由于Perm段装载了大量的Servlet类而导致溢出，目前的解决办法：<br><br>1) 将PermSize扩大，一般256M能够满足要求<br><br>2) 若别无选择，则只能将servlet的路径加到CLASSPATH中，但一般不建议这么处理<br><br><br><br><br><br>3. C Heap溢出<br><br>系统对C Heap没有限制，故C Heap发生问题时，Java进程所占内存会持续增长，直到占用所有可用系统内存<br><br>其他：<br><br>JVM有2个GC线程。第一个线程负责回收Heap的Young区。第二个线程在Heap不足时，遍历Heap，将Young 区升级为Older区。Older区的大小等于-Xmx减去-Xmn，不能将-Xms的&#20540;设的过大，因为第二个线程被迫运行会降低JVM的性能。<br><br>为什么一些程序频繁发生GC？有如下原因：<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; 程序内调用了System.gc()或Runtime.gc()。<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; 一些中间件软件调用自己的GC方法，此时需要设置参数禁止这些GC。<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; Java的Heap太小，一般默认的Heap&#20540;都很小。<br><br>l &nbsp; &nbsp; &nbsp; &nbsp; 频繁实例化对象，Release对象。此时尽量保存并重用对象，例如使用StringBuffer()和String()。<br><br>如果你发现每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态。许多Server端的Java程序每次GC后最好能有65%的剩余空间。<br><br>经验之谈：<br><br>1．Server端JVM最好将-Xms和-Xmx设为相同&#20540;。为了优化GC，最好让-Xmn&#20540;约等于-Xmx的1/3[2]。<br><br>2．一个GUI程序最好是每10到20秒间运行一次GC，每次在半秒之内完成[2]。<br><br>注意：<br><br>1．增加Heap的大小虽然会降低GC的频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。<br><br>2．Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的&#20540;，因为Java为其他任务分配内存，例如每个线程的Stack等。<br><br>2．Stack的设定<br><br>每个线程都有他自己的Stack。<br><br></p><br><div style="line-height:normal; background-color:white; zoom:1!important; word-wrap:break-word; visibility:visible!important; font-size:12px; word-break:break-all"><br><p style="padding-bottom:2px; line-height:normal; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><table border="1" cellspacing="0" cellpadding="0" width="90%" style="line-height:normal; background-color:rgb(238,204,255); width:856px; table-layout:auto!important"><br><tbody style="line-height:normal"><br><tr style="line-height:normal"><br><td style="padding-bottom:1.5pt; line-height:normal; padding-left:1.5pt; padding-right:1.5pt; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:12px; word-break:break-all; padding-top:1.5pt"><br><div align="left" style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><span style="line-height:normal; font-size:12pt">-Xss</span></div><br></td><br><td style="padding-bottom:1.5pt; line-height:normal; padding-left:1.5pt; padding-right:1.5pt; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:12px; word-break:break-all; padding-top:1.5pt"><br><div align="left" style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><span style="line-height:normal; font-size:12pt">每个线程的</span><span style="line-height:normal; font-size:12pt">Stack</span><span style="line-height:normal; font-size:12pt">大小</span></div><br></td><br></tr><br></tbody><br></table><br></p><br><div style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br>Stack的大小限制着线程的数量。如果Stack过大就好导致内存溢漏。-Xss参数决定Stack大小，例如-Xss1024K。如果Stack太小，也会导致Stack溢漏。<br><br>3．硬件环境<br><br>硬件环境也影响GC的效率，例如机器的种类，内存，swap空间，和CPU的数量。<br><br>如果你的程序需要频繁创建很多transient对象，会导致JVM频繁GC。这种情况你可以增加机器的内存，来减少Swap空间的使用[2]。<br><br>4．4种GC<br><br>第一种为单线程GC，也是默认的GC。，该GC适用于单CPU机器。<br><br>第二种为Throughput GC，是多线程的GC，适用于多CPU，使用大量线程的程序。第二种GC与第一种GC相&#20284;，不同在于GC在收集Young区是多线程的，但在Old区和第一种一样，仍然采用单线程。-XX:&#43;UseParallelGC参数启动该GC。<br><br>第三种为Concurrent Low Pause GC，类&#20284;于第一种，适用于多CPU，并要求缩短因GC造成程序停滞的时间。这种GC可以在Old区的回收同时，运行应用程序。-XX:&#43;UseConcMarkSweepGC参数启动该GC。<br><br>第四种为Incremental Low Pause GC，适用于要求缩短因GC造成程序停滞的时间。这种GC可以在Young区回收的同时，回收一部分Old区对象。-Xincgc参数启动该GC。<br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial; word-wrap:break-word; visibility:visible!important; font-size:14px; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px"></span><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br><strong>按照基本回收策略分</strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">引用计数（Reference Counting）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">标记-清除（Mark-Sweep）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;<img alt="标记清楚" src="http://hi.csdn.net/attachment/201003/6/1981948_1267862317X1a1.png" width="573" height="230" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">复制（Copying）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><img alt="复制" src="http://hi.csdn.net/attachment/201003/6/1981948_1267862317ZvYy.png" width="573" height="230" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none">&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">标记-整理（Mark-Compact）:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;<img alt="标记整理" src="http://hi.csdn.net/attachment/201003/6/1981948_1267862317X1a1.png" width="573" height="230" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p><br><h2 style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:0px"><br><a target="_blank" name="t0"></a><br><br>&nbsp;</h2><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br><strong>按分区对待的方式分</strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>增量收集（Incremental Collecting）:</strong></span>实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>分代收集（Generational Collecting）:</strong></span>基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br><strong>按系统线程分</strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">串行收集:</span></strong>串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">并行收集:</span></strong>并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。（串型收集的并发版本，需要暂停jvm） 并行paralise指的是多个任务在多个cpu中一起并行执行，最后将结果合并。效率是N倍。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>并发收集:</strong></span>相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。（和并行收集不同，并发只有在开头和结尾会暂停jvm）并发concurrent指的是多个任务在一个cpu伪同步执行，但其实是串行调度的，效率并非直接是N倍。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; padding-top:2px"><br><strong><span style="font-size:13px">分代垃圾回收</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp;&nbsp; 分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="font-size:16px"><img alt="jvm分代" src="http://hi.csdn.net/attachment/201003/6/1981948_12678645142BKS.png" width="574" height="318" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>如图所示：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;虚拟机中的共划分为三个代：<strong>年轻代（Young Generation）、年老点（Old Generation）和持久代（Permanent Generation）</strong>。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">年轻代:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来<br> 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">年老代:</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="color:#00ff"><strong>持久代:</strong></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=&lt;N&gt;进行设置。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; padding-top:2px"><br><strong><span style="font-size:13px">什么情况下触发垃圾回收&nbsp;</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<strong>Scavenge GC</strong>和<strong>Full GC</strong>。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">Scavenge GC</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong><span style="color:#00ff">Full GC</span></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;&nbsp; &nbsp;对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><br><blockquote style="font-family:Arial; font-size:14px"><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>· 年老代（Tenured）被写满</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>· 持久代（Perm）被写满&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>· System.gc()被显示调用&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br>·上一次GC之后Heap的各域分配策略动态变化</p><br></blockquote><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程1" src="http://hi.csdn.net/attachment/201004/18/1981948_1271591242sfBp.jpg" width="482" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程2" src="http://hi.csdn.net/attachment/201004/18/1981948_12715912450bkp.png" width="413" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程3" src="http://hi.csdn.net/attachment/201004/18/1981948_1271591246383f.png" width="413" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-size:16px"><img alt="分代垃圾回收流程" src="http://hi.csdn.net/attachment/201004/18/1981948_1271591249sb6K.png" width="415" height="768" style="border-bottom-style:none; border-right-style:none; border-top-style:none; border-left-style:none"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><h2><a target="_blank" name="t1"></a><strong><span style="font-size:16px">= G1 ===================================</span></strong></h2><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><strong></strong></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br>传说中的G1，传说中的low-pause垃圾收集。Java SE 6的update14版本中已经包含测试版，可以在启动时加JVM参数来启用</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'">-XX:&#43;UnlockExperimentalVMOptions -XX:&#43;UseG1GC</span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><a target="_blank" href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html">http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html</a><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'">本文摘自《构建高性能的大型分布式Java应用》一书，Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率，将作为CMS的替代者在JDK 7中闪亮登场，其最大的特色在于允许指定在某个时间段内GC所导致的应用暂停的时间最大为多少，例如在100秒内最多允许GC导致的应用暂停时间为1秒，这个特性对于准实时响应的系统而言非常的吸引人，这样就再也不用担心系统突然会暂停个两三秒了。</span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>G1要做到这样的效果，也是有前提的，一方面是硬件环境的要求，必须是多核的CPU以及较大的内存（从规范来看，512M以上就满足条件了），另外一方面是需要接受吞吐量的稍微降低，对于实时性要求高的系统而言，这点应该是可以接受的。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>为了能够达到这样的效果，G1在原有的各种GC策略上进行了吸收和改进，在G1中可以看到增量收集器和CMS的影子，但它不仅仅是吸收原有GC策略的优点，并在此基础上做出了很多的改进，简单来说，G1吸收了增量GC以及CMS的精髓，将整个jvm Heap划分为多个固定大小的region，扫描时采用Snapshot-at-the-beginning的并发marking算法（具体在后面内容详细解释）对整个heap中的region进行mark，回收时根据region中活跃对象的bytes进行排序，首先回收活跃对象bytes小以及回收耗时短（预估出来的时间）的region，回收的方法为将此region中的活跃对象复制到另外的region中，根据指定的GC所能占用的时间来估算能回收多少region，这点和以前版本的Full<br> GC时得处理整个heap非常不同，这样就做到了能够尽量短时间的暂停应用，又能回收内存，由于这种策略在回收时首先回收的是垃圾对象所占空间最多的region，因此称为Garbage First。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>看完上面对于G1策略的简短描述，并不能清楚的掌握G1，在继续详细看G1的步骤之前，必须先明白G1对于JVM Heap的改造，这些对于习惯了划分为new generation、old generation的大家来说都有不少的新意。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>G1将Heap划分为多个固定大小的region，这也是G1能够实现控制GC导致的应用暂停时间的前提，region之间的对象引用通过remembered set来维护，每个region都有一个remembered set，remembered set中包含了引用当前region中对象的region的对象的pointer，由于同时应用也会造成这些region中对象的引用关系不断的发生改变，G1采用了Card Table来用于应用通知region修改remembered sets，Card Table由多个512字节的Card构成，这些Card在Card<br> Table中以1个字节来标识，每个应用的线程都有一个关联的remembered set log，用于缓存和顺序化线程运行时造成的对于card的修改，另外，还有一个全局的filled RS buffers，当应用线程执行时修改了card后，如果造成的改变仅为同一region中的对象之间的关联，则不记录remembered set log，如造成的改变为跨region中的对象的关联，则记录到线程的remembered set log，如线程的remembered set log满了，则放入全局的filled RS<br> buffers中，线程自身则重新创建一个新的remembered set log，remembered set本身也是一个由一堆cards构成的哈希表。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>尽管G1将Heap划分为了多个region，但其默认采用的仍然是分代的方式，只是仅简单的划分为了年轻代（young）和非年轻代，这也是由于G1仍然坚信大多数新创建的对象都是不需要长的生命周期的，对于应用新创建的对象，G1将其放入标识为young的region中，对于这些region，并不记录remembered set logs，扫描时只需扫描活跃的对象，G1在分代的方式上还可更细的划分为：fully young或partially young，fully young方式暂停的时候仅处理young regions，partially同样处理所有的young<br> regions，但它还会根据允许的GC的暂停时间来决定是否要加入其他的非young regions，G1是运行到fully-young方式还是partially young方式，外部是不能决定的，在启动时，G1采用的为fully-young方式，当G1完成一次Concurrent Marking后，则切换为partially young方式，随后G1跟踪每次回收的效率，如果回收fully-young中的regions已经可以满足内存需要的话，那么就切换回fully young方式，但当heap size的大小接近满的情况下，G1会切换到partially<br> young方式，以保证能提供足够的内存空间给应用使用。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>除了分代方式的划分外，G1还支持另外一种pure G1的方式，也就是不进行代的划分，pure方式和分代方式的具体不同在下面的具体执行步骤中进行描述。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>掌握了这些概念后，继续来看G1的具体执行步骤：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initial Marking</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>G1对于每个region都保存了两个标识用的bitmap，一个为previous marking bitmap，一个为next marking bitmap，bitmap中包含了一个bit的地址信息来指向对象的起始点。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>开始Initial Marking之前，首先并发的清空next marking bitmap，然后停止所有应用线程，并扫描标识出每个region中root可直接访问到的对象，将region中top的&#20540;放入next top at mark start（TAMS）中，之后恢复所有应用线程。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>触发这个步骤执行的条件为：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;G1定义了一个JVM Heap大小的百分比的阀&#20540;，称为h，另外还有一个H，H的&#20540;为(1-h)<em>Heap Size，目前这个h的&#20540;是固定的，后续G1也许会将其改为动态的，根据jvm的运行情况来动态的调整，在分代方式下，G1还定义了一个u以及soft limit，soft limit的&#20540;为H-u</em>Heap Size，当Heap中使用的内存超过了soft limit&#20540;时，就会在一次clean up执行完毕后在应用允许的GC暂停时间范围内尽快的执行此步骤；</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;在pure方式下，G1将marking与clean up组成一个环，以便clean up能充分的使用marking的信息，当clean up开始回收时，首先回收能够带来最多内存空间的regions，当经过多次的clean up，回收到没多少空间的regions时，G1重新初始化一个新的marking与clean up构成的环。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concurrent Marking</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>按照之前Initial Marking扫描到的对象进行遍历，以识别这些对象的下层对象的活跃状态，对于在此期间应用线程并发修改的对象的以来关系则记录到remembered set logs中，新创建的对象则放入比top&#20540;更高的地址区间中，这些新创建的对象默认状态即为活跃的，同时修改top&#20540;。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Final Marking Pause</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>当应用线程的remembered set logs未满时，是不会放入filled RS buffers中的，在这样的情况下，这些remebered set logs中记录的card的修改就会被更新了，因此需要这一步，这一步要做的就是把应用线程中存在的remembered set logs的内容进行处理，并相应的修改remembered sets，这一步需要暂停应用，并行的运行。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Live Data Counting and Cleanup</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>&#20540;得注意的是，在G1中，并不是说Final Marking Pause执行完了，就肯定执行Cleanup这步的，由于这步需要暂停应用，G1为了能够达到准实时的要求，需要根据用户指定的最大的GC造成的暂停时间来合理的规划什么时候执行Cleanup，另外还有几种情况也是会触发这个步骤的执行的：</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;G1采用的是复制方法来进行收集，必须保证每次的”to space”的空间都是够的，因此G1采取的策略是当已经使用的内存空间达到了H时，就执行Cleanup这个步骤；</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>l&nbsp;&nbsp;对于full-young和partially-young的分代模式的G1而言，则还有情况会触发Cleanup的执行，full-young模式下，G1根据应用可接受的暂停时间、回收young regions需要消耗的时间来估算出一个yound regions的数量&#20540;，当JVM中分配对象的young regions的数量达到此&#20540;时，Cleanup就会执行；partially-young模式下，则会尽量频繁的在应用可接受的暂停时间范围内执行Cleanup，并最大限度的去执行non-young regions的Cleanup。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>这一步中GC线程并行的扫描所有region，计算每个region中低于next TAMS&#20540;中marked data的大小，然后根据应用所期望的GC的短延时以及G1对于region回收所需的耗时的预估，排序region，将其中活跃的对象复制到其他region中。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br>&nbsp;</p><br><span style="font-size:14px">G1为了能够尽量的做到准实时的响应，例如估算暂停时间的算法、对于经常被引用的对象的特殊处理等，G1为了能够让GC既能够充分的回收内存，又能够尽量少的导致应用的暂停，可谓费尽心思，从G1的论文中的性能评测来看效果也是不错的，不过如果G1能允许开发人员在编写代码时指定哪些对象是不用mark的就更完美了，这对于有巨大缓存的应用而言，会有很大的帮助，G1将随JDK 6 Update 14&nbsp;beta发布。</span><br><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><h2><a target="_blank" name="t2"></a><span style="font-family:'Courier New'">= CMS ==================================</span></h2><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><a target="_blank" href="http://www.iteye.com/topic/1119491">http://www.iteye.com/topic/1119491</a><br><br></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-family:Arial; font-size:14px; padding-top:2px"><br><span style="font-family:'Courier New'"><span></span></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><span style="font-size:13px"><strong>1.总体介绍：</strong></span></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:2px"><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。并发意味着除了开头和结束阶段，需要暂停JVM，其它时间gc和应用一起执行。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上<span style="color:#ff00">-XX:&#43;UseConcMarkSweepGC</span>&nbsp;，这个参数表示对于老年代的回收采用CMS。CMS采用的基础算法是：标记—清除。默认会开启 -XX :&#43;UseParNewGC，在年轻代使用并行复制收集。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><strong><span style="font-size:13px">2.CMS过程：</span></strong></p><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>初始标记(STW initial mark) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发标记(Concurrent marking) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发预清理(Concurrent precleaning) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>重新标记(STW remark) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发清理(Concurrent sweeping) </li><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>并发重置(Concurrent reset)</li></ul><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>初始标记</strong>&nbsp;</span>：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的&quot;根对象&quot;开始，只扫描到能够和&quot;根对象&quot;直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>并发标记</strong>&nbsp;</span>：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><strong><span style="color:#3366ff">并发预清理</span>&nbsp;</strong>：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段&quot;重新标记&quot;的工作，因为下一个阶段会Stop The World。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>重新标记</strong>&nbsp;</span>：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从&quot;跟对象&quot;开始向下追溯，并处理对象关联。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><strong><span style="color:#3366ff">并发清理</span>&nbsp;</strong>：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#3366ff"><strong>并发重置</strong>&nbsp;</span>：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>&nbsp;</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="color:#ff00">CSM执行过程：</span>&nbsp;<br><br><img class="magplus" title="点击查看原始大小图片" alt="" src="http://dl.iteye.com/upload/attachment/612577/2b525609-ce63-3a42-bf19-b2fbcd42f26c.png" width="700" height="151" style="border-right-width:0px; border-top-width:0px; border-bottom-width:0px; border-left-width:0px"></p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><strong><span style="font-size:13px">3.CMS缺点</span></strong></p><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>CMS回收器采用的基础算法是Mark-Sweep。所有CMS不会整理、压缩堆空间。这样就会有一个问题：经过CMS收集的堆会产生空间碎片。 CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空 间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。</li></ul><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>需要更多的CPU资源。从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。并且，重新标记阶段，为空保证STW快速完成，也要用到更多的甚至所有的CPU资源。当然，多核多CPU也是未来的趋势！</li></ul><br><ul style="padding-bottom:0px; margin:0px 0px 1.5em; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><li style="padding-bottom:0px; margin:0px 0px 0.25em 30px; padding-left:0px; padding-right:0px; padding-top:0px"><br>CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回 收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，已 避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用68%的时候，CMS就开始行动了。 – XX:CMSInitiatingOccupancyFraction =n 来设置这个阀&#20540;。</li></ul><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>总得来说，CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。</p><br><p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px"><br><span style="font-size:13px"><strong>4.啥时候用CMS</strong></span></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>如果你的应用程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU(也就是硬件牛&#36924;)，那么使用CMS来收集会给你带来好处。还有，如果在JVM中，有相对较多存活时间较长的对象(老年代比较大)会更适合使用CMS。</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><h2><a target="_blank" name="t3"></a>= 调试工具 ==================================</h2><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px"><br><strong><span style="font-size:13px">jmap</span></strong></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jmap -heap pid &nbsp;(不能观察G1模式）</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>using parallel threads in the new generation.<br><br>using thread-local object allocation.<br><br>Concurrent Mark-Sweep GC<br><br><br><br>Heap Configuration:<br><br>&nbsp; &nbsp;MinHeapFreeRatio = 40<br><br>&nbsp; &nbsp;MaxHeapFreeRatio = 70<br><br>&nbsp; &nbsp;MaxHeapSize &nbsp; &nbsp; &nbsp;= 2147483648 (2048.0MB)<br><br>&nbsp; &nbsp;NewSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 268435456 (256.0MB)<br><br>&nbsp; &nbsp;MaxNewSize &nbsp; &nbsp; &nbsp; = 268435456 (256.0MB)<br><br>&nbsp; &nbsp;OldSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 805306368 (768.0MB)<br><br>&nbsp; &nbsp;NewRatio &nbsp; &nbsp; &nbsp; &nbsp; = 7<br><br>&nbsp; &nbsp;SurvivorRatio &nbsp; &nbsp;= 8<br><br>&nbsp; &nbsp;PermSize &nbsp; &nbsp; &nbsp; &nbsp; = 134217728 (128.0MB)<br><br>&nbsp; &nbsp;MaxPermSize &nbsp; &nbsp; &nbsp;= 134217728 (128.0MB)<br><br><br><br>Heap Usage:<br><br>New Generation (Eden &#43; 1 Survivor Space):<br><br>&nbsp; &nbsp;capacity = 241631232 (230.4375MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 145793088 (139.03912353515625MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 95838144 (91.39837646484375MB)<br><br>&nbsp; &nbsp;60.33702133340114% used<br><br>Eden Space:<br><br>&nbsp; &nbsp;capacity = 214827008 (204.875MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 132689456 (126.54252624511719MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 82137552 (78.33247375488281MB)<br><br>&nbsp; &nbsp;61.7657236095752% used<br><br>From Space:<br><br>&nbsp; &nbsp;capacity = 26804224 (25.5625MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 13103632 (12.496597290039062MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 13700592 (13.065902709960938MB)<br><br>&nbsp; &nbsp;48.886444166411984% used<br><br>To Space:<br><br>&nbsp; &nbsp;capacity = 26804224 (25.5625MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 0 (0.0MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 26804224 (25.5625MB)<br><br>&nbsp; &nbsp;0.0% used<br><br>concurrent mark-sweep generation: （old区）<br><br>&nbsp; &nbsp;capacity = 1879048192 (1792.0MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 1360638440 (1297.6059341430664MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 518409752 (494.3940658569336MB)<br><br>&nbsp; &nbsp;72.41104543209076% used<br><br>Perm Generation:<br><br>&nbsp; &nbsp;capacity = 134217728 (128.0MB)<br><br>&nbsp; &nbsp;used &nbsp; &nbsp; = 65435064 (62.40373992919922MB)<br><br>&nbsp; &nbsp;free &nbsp; &nbsp; = 68782664 (65.59626007080078MB)<br><br>&nbsp; &nbsp;48.75292181968689% used<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jmap -histo:live pid</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>num &nbsp; &nbsp; #instances &nbsp; &nbsp; &nbsp; &nbsp; #bytes &nbsp;class name<br><br>———————————————-<br><br>&nbsp; &nbsp;1: &nbsp; &nbsp; &nbsp; 3148147 &nbsp; &nbsp; &nbsp;209172848 &nbsp;[B<br><br>&nbsp; &nbsp;2: &nbsp; &nbsp; &nbsp; 2584345 &nbsp; &nbsp; &nbsp;144723320 &nbsp;java.lang.ref.SoftReference<br><br>&nbsp; &nbsp;3: &nbsp; &nbsp; &nbsp; 2578827 &nbsp; &nbsp; &nbsp;123783696 &nbsp;sun.misc.CacheEntry<br><br>&nbsp; &nbsp;4: &nbsp; &nbsp; &nbsp; &nbsp;781560 &nbsp; &nbsp; &nbsp;112544640 &nbsp;com.sun.net.ssl.internal.ssl.SSLSessionImpl<br><br>&nbsp; &nbsp;5: &nbsp; &nbsp; &nbsp; 1385200 &nbsp; &nbsp; &nbsp; 89970592 &nbsp;[C<br><br>&nbsp; &nbsp;6: &nbsp; &nbsp; &nbsp; &nbsp;783287 &nbsp; &nbsp; &nbsp; 87807200 &nbsp;[Ljava.util.Hashtable$Entry;<br><br>&nbsp; &nbsp;7: &nbsp; &nbsp; &nbsp; 1421399 &nbsp; &nbsp; &nbsp; 56855960 &nbsp;java.lang.String<br><br>&nbsp; &nbsp;8: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 &nbsp; &nbsp; &nbsp; 56828880 &nbsp;[Lsun.misc.CacheEntry;<br><br>&nbsp; &nbsp;9: &nbsp; &nbsp; &nbsp; 2343358 &nbsp; &nbsp; &nbsp; 56240592 &nbsp;com.sun.net.ssl.internal.ssl.SessionId<br><br>&nbsp; 10: &nbsp; &nbsp; &nbsp; &nbsp;783185 &nbsp; &nbsp; &nbsp; 50123840 &nbsp;java.util.Hashtable<br><br>&nbsp; 11: &nbsp; &nbsp; &nbsp; &nbsp;783094 &nbsp; &nbsp; &nbsp; 50118016 &nbsp;java.lang.ref.Finalizer<br><br>&nbsp; 12: &nbsp; &nbsp; &nbsp; &nbsp;287243 &nbsp; &nbsp; &nbsp; 36086720 &nbsp;[Ljava.lang.Object;<br><br>&nbsp; 13: &nbsp; &nbsp; &nbsp; &nbsp;263376 &nbsp; &nbsp; &nbsp; 33712128 &nbsp;org.apache.commons.pool.impl.GenericObjectPool<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><strong>jstat</strong></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jstat -gccause 31169 60000 1000<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>(sweep 1,2) (Eden) (Old) (Perm) (Young GC, GCTime)(Full GC, GCTime)</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>&nbsp; S0 &nbsp; &nbsp; &nbsp; &nbsp; S1 &nbsp; &nbsp; E &nbsp; &nbsp; &nbsp; &nbsp; O &nbsp; &nbsp; &nbsp; &nbsp; P &nbsp; &nbsp; YGC &nbsp; &nbsp; YGCT &nbsp; &nbsp; FGC &nbsp; &nbsp;FGCT &nbsp; &nbsp; &nbsp;GCT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LGCC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GCC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp;48.80 &nbsp; 0.00 &nbsp;68.94 &nbsp;69.55 &nbsp;48.86 &nbsp;30202 &nbsp;725.319 51835 5083.298 5808.616 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp;47.98 &nbsp; 0.00 &nbsp;37.47 &nbsp;69.61 &nbsp;48.86 &nbsp;30206 &nbsp;725.385 51835 5083.298 5808.682 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp;50.73 &nbsp; 0.00 &nbsp;51.72 &nbsp;69.65 &nbsp;48.86 &nbsp;30210 &nbsp;725.459 51835 5083.298 5808.757 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br>&nbsp; 0.00 &nbsp;50.02 &nbsp;82.67 &nbsp;69.60 &nbsp;48.84 &nbsp;30213 &nbsp;725.508 51836 5091.572 5817.081 unknown GCCause &nbsp; &nbsp; &nbsp;No GC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>jstat -gcutil $pid</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>&nbsp; S0 &nbsp; &nbsp; &nbsp; &nbsp; S1 &nbsp; &nbsp; E &nbsp; &nbsp; &nbsp; &nbsp; O &nbsp; &nbsp; &nbsp; P &nbsp; &nbsp; &nbsp; YGC &nbsp; &nbsp; YGCT &nbsp; &nbsp;FGC &nbsp; &nbsp;FGCT &nbsp; &nbsp; GCT &nbsp;&nbsp;<br><br>&nbsp;74.79 &nbsp; 0.00 &nbsp;95.15 &nbsp; 0.86 &nbsp;37.35 &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp;0.112 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;0.000 &nbsp; &nbsp; &nbsp;0.112<br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>O = old occupied</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>YGC = young gc time ( new part )</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>YGCT = young gc total cost time</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>FGC = full gc time ( old part )</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>FGCT = full gc total cost time</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br>GCT = all gc cost time</p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; font-size:14px; padding-top:0px"><br><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px"></span></p><br><p><strong>jvisualvm</strong></p><br><p>window下启动远程监控，并在被监控服务端，启动jstatd服务。</p><br><p><br><br></p><br><p><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px">创建安全策略文件，并命名为jstatd.all.policy<br style="line-height:25px"><br>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {<br style="line-height:25px"><br>&nbsp;&nbsp;&nbsp; permission java.security.AllPermission;<br style="line-height:25px"><br>};</span><br><br></p><br><p><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px"><span style="font-family:Arial; font-size:14px; color:#333333; line-height:26px">jstatd -J-Djava.security.policy=jstatd.all.policy -p 8080 &amp;</span></span></p><br><br><br><strong>======================== Tunning =================</strong></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>典型配置：</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><pre>-server -Xmx2g -Xms2g -Xmn512m -XX:PermSize=128m -Xss256k -XX:&#43;DisableExplicitGC -XX:&#43;UseConcMarkSweepGC -XX:&#43;UseParNewGC -XX:&#43;CMSParallelRemarkEnabled -XX:&#43;UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:&#43;UseFastAccessorMethods -XX:&#43;UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true<br></pre><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><a target="_blank" href="http://java.sun.com/performance/reference/whitepapers/tuning.html">http://java.sun.com/performance/reference/whitepapers/tuning.html</a><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><a target="_blank" href="http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html">http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html</a><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>&#43;AggressiveOpts 激进优化，默认开启，使用java新特性优化</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>1. 默认使用串行收集器， 单个cpu时适用</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>2. 吞吐收集器（throughput collector）：命令行参数：-XX:&#43;UseParallelGC。在新生代使用并行清除收集策略，在旧生代和默认收集器相同。</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>适用：a、拥有2个以上cpu， b、临时对象较多的程序</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><span style="font-family:Arial,Verdana,sans-serif">-XX:ParallelGCThreads 并行收集线程数量，最好和cpu数量相当</span><br><br><br><br>3. 并发收集器（concurrent low pause collector）：命令行参数：-XX:&#43;UseConcMarkSweepGC。在旧生代使用并发收集策略，大部分收集工作都是和应用并发进行的，在进行收集的时候，应用的暂停时间很短。默认配套打开 -XX:&#43;UseParNewGC，会在新生代使用并行复制收集。</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>适用：a、拥有多个cpu， b、老对象较多的程序</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>如果使用了UseParNewGC，那么同时使用CMSParallelRemarkEnabled参数可以降低标识暂停</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:&#43;UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片<br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:&#43;UseFastAccessorMethods 原始类型的快速优化</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:SurvivorRatio 新生区中，eden&amp;survivor的比例，设置为8</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>-XX:TargetSurvivorRatio 生存区需要做垃圾回收的比例&#20540;，默认为50%，设置高些可以更好的利用该区</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><img alt="" src="http://img.my.csdn.net/uploads/201207/09/1341820867_5296.gif"><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>各个垃圾收集器之间的区别：</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><a target="_blank" href="http://www.javaperformancetuning.com/news/qotm026.shtml">http://www.javaperformancetuning.com/news/qotm026.shtml</a><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br>新生代，单独区域单独收集，不会影响老生代，因为区域小，且允许漏收集，采用复制清除的方法，更快。</div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><br><br></div><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br></div><br><span style="font-family:Arial,'Liberation Sans','DejaVu Sans',sans-serif; font-size:14px; line-height:18px; border-collapse:collapse"></span><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>The&nbsp;<span style="font-size:14px; padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px; padding-left:0px; padding-right:0px; border-top-width:0px; border-bottom-width:0px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><em>(original)<br> copying collector</em></span>&nbsp;(Enabled by default). When this collector kicks in, all application threads are stopped, and the copying collection proceeds using one thread (which means only one CPU even if on a multi-CPU machine). This is known as a stop-the-world<br> collection, because basically the JVM pauses everything else until the collection is completed.</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>The&nbsp;<span style="font-size:14px; padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px; padding-left:0px; padding-right:0px; border-top-width:0px; border-bottom-width:0px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><em>parallel<br> copying collector</em></span>&nbsp;(Enabled using -XX:&#43;UseParNewGC). Like the original copying collector, this is a stop-the-world collector. However this collector parallelizes the copying collection over multiple threads, which is more efficient than the original<br> single-thread copying collector for multi-CPU machines (though not for single-CPU machines). This algorithm potentially speeds up young generation collection by a factor equal to the number of CPUs available, when compared to the original singly-threaded copying<br> collector.</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>The&nbsp;<span style="font-size:14px; padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px; padding-left:0px; padding-right:0px; border-top-width:0px; border-bottom-width:0px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><em>parallel<br> scavenge collector</em></span>&nbsp;(Enabled using -XX:UseParallelGC). This is like the previous parallel copying collector, but the algorithm is tuned for gigabyte heaps (over 10GB) on multi-CPU machines. This collection algorithm is designed to maximize throughput<br> while minimizing pauses. It has an optional adaptive tuning policy which will automatically resize heap spaces. If you use this collector, you can only use the the original mark-sweep collector in the old generation (i.e. the newer old generation concurrent<br> collector cannot work with this young generation collector).</p><br><div style="line-height:normal; zoom:1!important; font-family:Arial,Verdana,sans-serif; word-wrap:break-word; visibility:visible!important; word-break:break-all"><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br></p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>UserParallelGC使用了更高效的算法，用于处理大规模内存&gt;10G场景，提供了大吞吐量功能。但是，同时在老生代，只能使用串行的标记清除方法。</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br><br><br></p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br>老生代，必须做fullgc，必须从root开始全面标识收集。</p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br></p><br><ul style="font-family:Simsun; font-size:16px"><br><li>The&nbsp;<em>(original) mark-sweep collector</em>&nbsp;(Enabled by default). This uses a stop-the-world mark-and-sweep collection algorithm. The collector is single-threaded, the entire JVM is paused and the collector uses only one CPU until completed.</li><li>The&nbsp;<em>concurrent collector</em>&nbsp;(Enabled using -XX:&#43;UseConcMarkSweepGC). This collector tries to allow application processing to continue as much as possible during the collection. Splitting the collection into six phases described shortly, four are concurrent<br> while two are stop-the-world:<br><br>1. the initial-mark phase (stop-the-world, snapshot the old generation so that we can run most of the rest of the collection concurrent to the application threads);<br><br>2. the mark phase (concurrent, mark the live objects traversing the object graph from the roots);<br><br>3. the pre-cleaning phase (concurrent);<br><br>4. the re-mark phase (stop-the-world, another snapshot to capture any changes to live objects since the collection started);<br><br>5. the sweep phase (concurrent, recycles memory by clearing unreferenced objects);<br><br>6. the reset phase (concurrent).<br><br>If &quot;the rate of creation&quot; of objects is too high, and the concurrent collector is not able to keep up with the concurrent collection, it falls back to the traditional mark-sweep collector.</li><li>The&nbsp;<em>incremental collector</em>&nbsp;(Enabled using -Xincgc). The incremental collector uses a &quot;train&quot; algorithm to collect small portions of the old generation at a time. This collector has higher overheads than the mark-sweep collector, but because small<br> numbers of objects are collected each time, the (stop-the-world) garbage collection pause is minimized at the cost of total garbage collection taking longer. The &quot;train&quot; algorithm does not guarantee a maximum pause time, but pause times are typically less<br> than ten milliseconds.</li></ul><br><br><br><p></p><br><p style="padding-bottom:0px; border-right-width:0px; background-color:transparent; margin:0px 0px 1em; padding-left:0px; padding-right:0px; word-wrap:break-word; border-top-width:0px; border-bottom-width:0px; clear:both; font-size:14px; vertical-align:baseline; border-left-width:0px; padding-top:0px"><br><br><br></p><br></div><br></div>

<p></p></div><p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/05/05/first/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/05/first/" itemprop="url">HEXO教程-搭建一个属于自己的HEXO博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-05T15:18:31+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="show-content"><br>          <p><a href="https://github.com/BloodOrange2017/BloodOrange2017.github.io" target="_blank">原文 : BIGCC个人博客(gonghonglou.com)</a></p><br><p>这是一篇详细文章来讲述用Mac搭建Hexo博客于Github上的完整历程， 也是踩了无数的坑搭起来的，现在写下些经验来分享，希望能帮大家少踩些坑。</p><br><p>曾买过一款阿里的云虚拟主机，后来才发现不能自己装软件只能上传网站程序，除非另买<a href="https://www.aliyun.com/easybuy" target="_blank">ECS</a>，对于第一个月的实习工资还没拿到手的我想想还是算了，先用Wordpress搭起来玩玩吧。然而在上传网站程序中几次失败，本就觉得没劲，遂一怒转向Github。好了，废话少说，开始吧。</p><br><h2>环境配置</h2><br><br><p><a href="https://hexo.io/docs" target="_blank">Hexo官网</a>上本就有对Hexo安装及使用的详细介绍，墙裂推荐。这里来讲述自己安装的亲身步骤，或有区别。</p><br><h3>1.Node.js</h3><br><br><p>用来生成静态页面。移步<a href="https://nodejs.org/en/" target="_blank">Node.js官网</a>，下载v5.5.0 Stable 一路安装即可。</p><br><h3>2.Git</h3><br><br><p>用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考<a href="https://hexo.io/docs" target="_blank">Hexo官网</a>上的安装方法。    </p><br><h2>安装Hexo</h2><br><br><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p><br><pre><code>$ sudo npm install -g hexo</code></pre><br><p>输入管理员密码（Mac登录密码）即开始安装 (<code>sudo</code>:linux系统管理指令  <code>-g</code>:全局安装)</p><br><blockquote><p>注意坑一：<a href="https://hexo.io/docs" target="_blank">Hexo官网</a>上的安装命令是<code>$ npm install -g hexo-cli</code>，安装时不要忘记前面加上<code>sudo</code>，否则会因为权限问题报错。</p></blockquote><br><h3>初始化</h3><br><br><p>终端cd到一个你选定的目录，执行<code>hexo init</code>命令：</p><br><pre><code>$ hexo init blog</code></pre><br><p><code>blog</code>是你建立的文件夹名称。cd到<code>blog</code>文件夹下，执行如下命令，安装npm：</p><br><pre><code>$ npm install</code></pre><br><p>执行如下命令，开启hexo服务器：</p><br><pre><code>$ hexo s</code></pre><br><p>此时，浏览器中打开网址<a href="http://0.0.0.0:4000" target="_blank">http://localhost:4000</a>，能看到如下页面：</p><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/985173-6538ff6c494aeb9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/985173-6538ff6c494aeb9d.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption"><a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></div><br></div><br><p>本地设置好后，接下来开始关联Github。</p><br><h2>关联Github</h2><br><br><h3>1.创建仓库</h3><br><br><p>登录你的Github帐号，新建仓库，名为<code>用户名.github.io</code>固定写法，如<code>gonghonglou.github.io</code>即下图中<code>1</code>所示：</p><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/985173-e04632cf98208a52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/985173-e04632cf98208a52.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption"></div><br></div><br><p>本地的<code>blog</code>文件夹下内容为：</p><br><pre><code>_config.yml<br>db.json<br>node_modules<br>package.json<br>scaffolds<br>source<br>themes</code></pre><br><p>终端cd到<code>blog</code>文件夹下，<code>vim</code>打开<code>_config.yml</code>，命令如下：</p><br><pre><code>$ vim _config.yml</code></pre><br><p>打开后往下滑到最后，修改成下边的样子：</p><br><pre><code>deploy:<br>    type: git<br>    repository: <a href="https://github.com/BloodOrange2017/BloodOrange2017.github.io.git" target="_blank" rel="external">https://github.com/BloodOrange2017/BloodOrange2017.github.io.git</a><br>    branch: master</code></pre><br><p>你需要将<code>repository</code>后<code>gonghonglou</code>换成你自己的用户名，地址在上图<code>2</code>位置获取。hexo 3.1.1版本后<code>type:</code>值为<code>git</code>。</p><br><blockquote><p>注意坑二：在配置所有的<code>_config.yml</code>文件时（包括theme中的），在所有的冒号<code>:</code>后边都要加一个空格，否则执行hexo命令会报错，切记 切记</p></blockquote><br><p>在<code>blog</code>文件夹目录下执行生成静态页面命令：</p><br><pre><code>$ hexo generate        或者：hexo g</code></pre><br><pre>此时若出现如下报错：<br>ERROR Local hexo not found in ~/blog<br>ERROR Try runing: ‘npm install hexo –save’<br>则执行命令：<br>npm install hexo –save<br>若无报错，自行忽略此步骤。</pre><br><br><p>再执行配置命令：</p><br><pre><code>$ hexo deploy            或者：hexo d</code></pre><br><blockquote><br><p>注意坑三：若执行命令<code>hexo deploy</code>仍然报错：无法连接git或找不到git，则执行如下命令来安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank">hexo-deployer-git</a>：</p><br><pre><code>   $ npm install hexo-deployer-git –save</code></pre><br></blockquote><br><p>再次执行<code>hexo generate</code>和<code>hexo deploy</code>命令。</p><br><p>若你未关联Github，则执行<code>hexo deploy</code>命令时终端会提示你输入Github的用户名和密码，即</p><br><pre><code>Username for ‘<a href="https://github.com" target="_blank" rel="external">https://github.com</a>‘:<br>Password for ‘<a href="https://github.com" target="_blank" rel="external">https://github.com</a>‘:</code></pre><br><p><code>hexo deploy</code>命令执行成功后，浏览器中打开网址<a href="http://gonghonglou.github.io" target="_blank">http://gonghonglou.github.io</a>（将<code>gonghonglou</code>换成你的用户名）能看到和打开<code><a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></code>时一样的页面。</p><br><p><strong>为避免每次输入Github用户名和密码的麻烦，可参照第二节方法</strong></p><br><h3>2.添加ssh key到Github</h3><br><br><h4>1.1.检查SSH keys是否存在Github</h4><br><br><p>执行如下命令，检查SSH keys是否存在。如果有文件<code>id_rsa.pub</code>或<code>id_dsa.pub</code>，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p><br><pre><code>$ ls -al ~/.ssh</code></pre><br><h4>1.2.生成新的ssh key</h4><br><br><p>执行如下命令生成public/private rsa key pair，注意将<code>your_email@example.com</code>换成你自己注册Github的邮箱地址。</p><br><pre><code>$ ssh-keygen -t rsa -C “your_email@example.com”</code></pre><br><p>默认会在相应路径下（<code>~/.ssh/id_rsa.pub</code>）生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p><br><h4>1.3.将ssh key添加到Github中</h4><br><br><p>Find前往文件夹<code>~/.ssh/id_rsa.pub</code>打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p><br><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p><br><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方<code>Add key</code>绿色按钮即可。</p><br><h3>3.发布文章</h3><br><br><p>终端cd到<code>blog</code>文件夹下，执行如下命令新建文章：</p><br><pre><code>hexo new “postName”</code></pre><br><p>名为<code>postName.md</code>的文件会建在目录<code>/blog/source/_posts</code>下。你当然可以用vim来编辑文章。我在用Mou编辑器，支持预览，虽然其预览主题并非我喜欢，如果你有好用的markdown编辑器请推荐给我，感激不尽！</p><br><p>文章编辑完成后，终端cd到<code>blog</code>文件夹下，执行如下命令来发布：</p><br><pre><code>hexo generate             //生成静态页面</code></pre><br><pre>hexo deploy            //将文章部署到Github</pre><br><br><p><strong>至此，Mac上搭建基于Github的Hexo博客就完成了。下面的内容是介绍安装theme，添加评论功能和绑定个人域名，如果有兴趣且还有耐心的话，请继续吧。</strong></p><br><h2>安装theme</h2><br><br><p>你可以到<a href="https://hexo.io/themes/" target="_blank">Hexo官网主题页</a>去搜寻自己喜欢的theme。这里以<a href="https://github.com/iissnan/hexo-theme-next" target="_blank">hexo-theme-next</a>为例</p><br><p>终端cd到 <code>blog</code> 目录下执行如下命令：</p><br><pre><code>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next</code></pre><br><p>将<code>blog</code>目录下<code>_config.yml</code>里<code>theme</code>的名称<code>landscape</code>修改为<code>next</code></p><br><p>终端cd到<code>blog</code>目录下执行如下命令(每次部署文章的步骤)：</p><br><pre><code>$ hexo clean           //清除缓存文件 (db.json) 和已生成的静态文件 (public)</code></pre><br><pre>$ hexo g             //生成缓存和静态文件</pre><br><br><pre>$ hexo d             //重新部署到服务器</pre><br><br><p>至于更改theme内容，比如名称，描述，头像等去修改<code>blog/_config.yml</code>文件和<code>blog/themes/next/_config.yml</code>文件中对应的属性名称即可， 不要忘记冒号<code>:</code>后加空格。  <a href="http://theme-next.iissnan.com/" target="_blank"> NexT 使用文档</a>里有极详细的介绍。</p><br><h2>绑定个人域名</h2><br><br><p>现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到<a href="https://sg.godaddy.com/zh/" target="_blank">GoDaddy官网</a>，网友亲切称呼为：狗爹，也可以到<a href="http://wanwang.aliyun.com/" target="_blank">阿里万网</a>购买。我是在万网买的，可直接在其网站做域名解析。</p><br><h3>1.Github端</h3><br><br><p>在<code>/blog/themes/landscape/source</code>目录下新建文件名为：<code>CNAME</code>文件，注意没有后缀名！直接将自己的域名如：<code>gonghonglou.com</code>写入。</p><br><p>终端cd到<code>blog</code>目录下执行如下命令重新部署：</p><br><pre><code>$ hexo clean</code></pre><br><pre>$ hexo g</pre>                                                        <pre>$ hexo d</pre><br><br><blockquote><p>注意坑四：网上许多都是说在Github上直接新建<code>CNAME</code>文件，如果这样的话，在你下一次执行<code>hexo d</code>部署命令后<code>CNAME</code>文件就消失了，因为本地没有此文件嘛。</p></blockquote><br><h3>2.域名解析</h3><br><br><p>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析 –&gt; 添加解析</p><br><p>记录类型：CNAME</p><br><p>主机记录：将域名解析为example.com（不带www），填写@或者不填写</p><br><p>记录值：gonghonglou.github.io.    (不要忘记最后的<code>.</code>，<code>gonghonglou</code>改为你自己的用户名)，点击保存即可，如下图：</p><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/985173-f1c2cd896991e05f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/985173-f1c2cd896991e05f.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">域名解析</div><br></div><br><p>此时，点击访问<a href="http://gonghonglou.com" target="_blank">http://gonghonglou.com</a>和访问<a href="http://gonghonglou.github.io" target="_blank">http://gonghonglou.github.io</a>效果一致，大功告成！</p><br><h4>——11.10更新 以下————————————————</h4><br><h4>1、解决 deploy 后博客空白问题</h4><br><p>昨晚更新了一下 blog 做了个部署，结果blog就挂了，打开 <code>gonghonglou.com</code> 页面显示一片空白。然而 <code>hexo s</code> 开启本地服务器 <code>localhost:4000</code> 访问是没问题的。<br>上网查了一下，原来是 GitHub Pages 禁止了 <code>source/vendors</code> 目录的访问。Github 在 11 月 3 日更新了版本。其中包括升级了 Jekyll 到 3.3。Jekyll 为了加快构建速度，忽略 <code>vendor</code> 和 <code>node_modules</code> 文件夹。所以部署到 GitHub 后，识别不到本地下的的这个文件夹 <code>blog/themes/next/source/vendor</code>，你只需要给这个文件夹换个名字再重新部署一次就 OK 了。<code>nexT</code> 在 GitHub 上的 isusses 已经给出了解决方案：<a href="https://github.com/iissnan/hexo-theme-next/issues/1214" target="_blank">#1214<br></a></p><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/985173-31f883a8da001b85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/985173-31f883a8da001b85.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">#1214</div><br></div><br><p>还有另一种解决方案就是升级 <code>nexT</code> 主题，cd 到 <code>blog/themes/next/</code> 下执行命令 <code>git pull</code> 更新。<br>然而，有可能升级后多说评论等第三方工具会失效，慎用。</p><br><h4>2、将个人博客同时部署到 GitHub 和 Coding</h4><br><p>1、首先到 <a href="https://coding.net" target="_blank">Coding</a> 上注册并开一个项目，项目名称和用户个性后缀相同（方便二级域名访问博客），拿到项目的 https 地址</p><br><p>2、打开本地 <code>blog</code> 目录下的 <code>_config.yml</code> 文件，修改如下</p><br><pre><code>deploy:<br>  type: git<br>  repository:<br>            github: <a href="https://github.com/gonghonglou/gonghonglou.github.io.git" target="_blank" rel="external">https://github.com/gonghonglou/gonghonglou.github.io.git</a><br>            coding: <a href="https://git.coding.net/gonghonglou/gonghonglou.git" target="_blank" rel="external">https://git.coding.net/gonghonglou/gonghonglou.git</a><br>  branch: master</code></pre><br><p>3、cd 到本地 <code>blog/source</code> 目录下执行如下命令新建 <code>Staticfile</code> 文件</p><br><pre><code>$ touch Staticfile  #名字必须是Staticfile</code></pre><br><p>原因是 coding.net 需要以这个文件来作为静态文件部署的标志，就是说看到这个 Staticfile 就知道按照静态文件来发布。</p><br><p>4、执行发布命令 <code>hexo g</code> 、 <code>hexo d</code>  </p><br><p>5、个人域名添加两条 <code>CNAME</code> 解析。将 <code>gonghonglou.github.io.</code> 解析为 [海外] ，将 <code>gonghonglou.coding.me.</code> 解析为 [默认]<br></p><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/985173-d560ebb84b300986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/985173-d560ebb84b300986.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption"></div><br></div><br><p>这样就是为了从国内访问 <code>gonghonglou.com</code> 就是访问 Coding 上的博客项目，从国外访问 <code>gonghonglou.com</code> 就是访问 GitHub 上的博客项目。</p><br><p>6、到 Coding 上的博客项目主页，点击 <code>Pages服务</code> 输入部署分支 <code>master</code> 立即开启</p><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/985173-ea5b4dad460b4f8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/985173-ea5b4dad460b4f8d.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption"></div><br></div><br><p>这样就可以访问自己在 Coding 上的个人博客了 <a href="http://gonghonglou.coding.me/gonghonglou" target="_blank">gonghonglou.coding.me/gonghonglou</a> 如果像这样你的用户后缀名与博客项目名称相同你还可以省略项目名称直接访问 <a href="http://gonghonglou.coding.me" target="_blank">gonghonglou.coding.me</a> </p><br><p>7、添加域名绑定，输入个人域名就 OK 了，可能需要耐心等待几分钟，这样在国内访问自己的博客就快得多了。</p><br><p>试了一下在国内访问 <a href="http://gonghonglou.com" target="_blank">gonghonglou.com</a> 拦不住 要飞起来了😂</p><br><h4>——11.10更新 以上————————————————</h4><br><h2>参考链接</h2><br><br><ul><br><li><a href="https://hexo.io/docs" target="_blank">Hexo官网</a></li><br><li><a href="http://leopardpan.github.io/2015/08/12/hexo/" target="_blank">HEXO</a></li><br><li><a href="http://www.jianshu.com/p/31cbbbc5f9fa/" target="_blank">如何生成SSH key</a></li><br></ul><br><br>        </div><br>        <!--  --><br><br>        <div class="show-foot"><br>          <a class="notebook" href="/nb/2004750"><br>            <i class="iconfont ic-search-notebook"></i> <span></span><br></a>          <div class="copyright" data-toggle="tooltip" data-html="true" data-original-title=""><br>          </div><br>          <div class="modal-wrap" data-report-note=""><br><br>          </div><br>        </div><br>    

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2016/05/11/game-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/11/game-01/" itemprop="url">cat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-11T10:38:59+08:00">
                2016-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <iframe frameborder="0" width="800" height="600" marginheight="0" marginwidth="0" scrolling="no" src="https://dtbfiles.oss-cn-shenzhen.aliyuncs.com/img/2017/05/11/cat.html"></iframe>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://bloodorange2017.github.io/images/img_head_001.jpg"
               alt="XueCheng" />
          <p class="site-author-name" itemprop="name">XueCheng</p>
           
              <p class="site-description motion-element" itemprop="description">Do one thing at a time, and do well.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XueCheng</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

<script type="text/javascript"
color="160,160,233" opacity='0.4' zIndex="-2" count="16" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
