<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Do one thing at a time, and do well.">
<meta property="og:type" content="website">
<meta property="og:title" content="XueCheng Notes">
<meta property="og:url" content="https://bloodorange2017.github.io/archives/index.html">
<meta property="og:site_name" content="XueCheng Notes">
<meta property="og:description" content="Do one thing at a time, and do well.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XueCheng Notes">
<meta name="twitter:description" content="Do one thing at a time, and do well.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bloodorange2017.github.io/archives/"/>





  <title>XueCheng Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XueCheng Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Where there is a will, there is a way.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2099/09/09/img-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2099/09/09/img-01/" itemprop="url">欢迎来到薛成的博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2099-09-09T12:00:00+08:00">
                2099-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://dtbfiles.oss-cn-shenzhen.aliyuncs.com/img/2017/05/05/asong.jpg"></p>
<div class="collection-title" style="width:800px;height: 100%"><br>          <iframe src="http://dtbfiles.oss-cn-shenzhen.aliyuncs.com/img/2017/12/19/15923255448_1513681779330.html" style="width:800px;height: 100%"><br>        </iframe></div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2099/09/07/download-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2099/09/07/download-file/" itemprop="url">框架软件-下载页</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2099-09-07T11:45:53+08:00">
                2099-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://bloodorange2017.github.io//software/dubbo简易依赖包.zip"><h4>Dubbo-简易依赖包</h4></a><br><a href="https://bloodorange2017.github.io//software/dobbo-admin.war"><h4>Dubbo-admin</h4></a><br><a href="https://bloodorange2017.github.io//software/dobbo-admin.war"><img src="https://bloodorange2017.github.io//images/bubbo_01.png"> </a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2099/09/07/myProject-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2099/09/07/myProject-01/" itemprop="url">案例项目-下载页</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2099-09-07T10:13:49+08:00">
                2099-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h4>maven项目</h4><br><a href="https://bloodorange2017.github.io//myProject/base_maven/base-pom.zip">maven基础分层项目</a><br><a href="https://bloodorange2017.github.io//myProject/maven+activemq/base-pom.zip">maven分层工程结合activemq</a><br><a href="https://bloodorange2017.github.io//myProject/maven+activemq+dubbo+zookeeper/base-pom.zip">maven分层工程结合activemq+dubbo+zookeeper</a><br><a href="https://bloodorange2017.github.io//myProject/maven+activemq+dubbo+zookeeper+transaction/base-pom.zip">注解式解决分布式事务最终一致性问题(采用actionmq做消息中间件)</a><br><img src="https://bloodorange2017.github.io//images/dubbo_02.png"><br><a href="https://bloodorange2017.github.io//myProject/maven+dubbo+readAndWrite/dtb-base-pom.zip">dubbo微服务结合mysql集群+一键导出jar包</a><br><a href="https://bloodorange2017.github.io//myProject/maven+dubbo+readAndWrite+web/dtb-base-pom.zip">dubbo微服务结合mysql集群+tomcat容器</a><br><a href="https://bloodorange2017.github.io//myProject/dubbox/dubbox-demo.zip">当当网dubbox</a><br><a href="https://bloodorange2017.github.io//myProject/dubbox-end/dtb-base-pom.zip">maven+dubbox+注解式解决分mysql集群+tomcat容器</a><br><a href="https://BloodOrange2017.github.io/myProject/dubbox-rest/dtb-base-pom.zip">maven+dubbox+注解式解决分mysql集群+tomcat容器+rest风格+redis</a><br><a href="https://bloodorange2017.github.io//myProject/dubbo-2.8.4.jar">dubbox-2.8.4.jar</a><br><a href="https://BloodOrange2017.github.io/myProject/dubbox-1.0/dtb-base-pom.zip">maven+dubbox+restful完整版</a><br><a href="https://BloodOrange2017.github.io/myProject/dubbo-monitor/dubbo-monitor.zip">dubbox监控monitor</a><br><a href="https://BloodOrange2017.github.io/myProject/algorithm.zip">非对称加密工具类，附带BASE64加密算法</a><p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/11/28/encryptionAlgorithm-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/encryptionAlgorithm-01/" itemprop="url">常见加密算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-28T14:15:07+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br>        <div class="markdown_views"><p>本文整理了常见的安全算法，包括MD5、SHA、DES、AES、RSA等，并写了完整的工具类（Java 版），工具类包含测试。</p><br><br><br><br><h2 id="一数字摘要算法">一、数字摘要算法</h2><br><br><blockquote><br>  <p>数字摘要也称为消息摘要，它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash函数对消息进行计算而产生。如果消息在传递的途中改变了，接收者通过对收到消息采用相同的Hash重新计算，新产生的摘要与原摘要进行比较，就可知道消息是否被篡改了，因此消息摘要能够验证消息的完整性。消息摘要采用单向Hash函数将需要计算的内容”摘要”成固定长度的串，这个串亦称为数字指纹。这个串有固定的长度，且不同的明文摘要成密文，其结果总是不同的(相对的)，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是”真身”的”指纹”了。</p><br></blockquote><br><br><br><br><h3 id="1-md5">1. Md5</h3><br><br><p>MD5即Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法一种实现，用于确保信息传输完整性和一致性，摘要长度为128位。 MD5由MD4、 MD3、 MD2改进而来，主要增强算法复杂度和不可逆性，该算法因其普遍、稳定、快速的特点，在产业界得到了极为广泛的使用，目前主流的编程语言普遍都已有MD5算法实现。</p><br><br><br><br><pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><br><span class="hljs-javadoc">/<strong><br> <em> Message Digest Algorithm 5(信息摘要算法5)
 </em>/</strong></span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MD5Util</span> {</span><br>    <span class="hljs-javadoc">/<br>     <em> Constructs the MD5Util object and sets the string whose MD5Util is to be
     </em> computed.<br>     <em> 
     </em><span class="hljs-javadoctag"> @param</span> inStr<br>     <em>    the &lt;code&gt;String&lt;/code&gt; whose MD5Util is to be computed
     </em>/</span><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String COMMON_KEY=<span class="hljs-string">“zhongzhuoxin#@!321”</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title">MD5Util</span>() {<br><br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">str2MD5</span>(String inStr) {<br>        <span class="hljs-keyword">char</span> hexDigits[] = { <span class="hljs-string">‘0’</span>, <span class="hljs-string">‘1’</span>, <span class="hljs-string">‘2’</span>, <span class="hljs-string">‘3’</span>, <span class="hljs-string">‘4’</span>, <span class="hljs-string">‘5’</span>, <span class="hljs-string">‘6’</span>, <span class="hljs-string">‘7’</span>, <span class="hljs-string">‘8’</span>, <span class="hljs-string">‘9’</span>,<br>                <span class="hljs-string">‘a’</span>, <span class="hljs-string">‘b’</span>, <span class="hljs-string">‘c’</span>, <span class="hljs-string">‘d’</span>, <span class="hljs-string">‘e’</span>, <span class="hljs-string">‘f’</span> };<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">byte</span>[] strTemp = inStr.getBytes(<span class="hljs-string">“UTF-8”</span>);<br>            MessageDigest mdTemp = MessageDigest.getInstance(<span class="hljs-string">“MD5”</span>);<br>            mdTemp.update(strTemp);<br>            <span class="hljs-keyword">byte</span>[] md = mdTemp.digest();<br>            <span class="hljs-keyword">int</span> j = md.length;<br>            <span class="hljs-keyword">char</span> str[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[j <em> <span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) {<br>                <span class="hljs-keyword">byte</span> byte0 = md[i];<br>                str[k++] = hexDigits[byte0 &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xf</span>];<br>                str[k++] = hexDigits[byte0 &amp; <span class="hljs-number">0xf</span>];<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(str);<br>        } <span class="hljs-keyword">catch</span> (Exception e) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        }<br>    }<br><br><br><br><br>    <span class="hljs-comment">//–MD5Util</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> HEX_DIGITS[] = { <span class="hljs-string">‘0’</span>, <span class="hljs-string">‘1’</span>, <span class="hljs-string">‘2’</span>, <span class="hljs-string">‘3’</span>, <span class="hljs-string">‘4’</span>, <span class="hljs-string">‘5’</span>,<br>            <span class="hljs-string">‘6’</span>, <span class="hljs-string">‘7’</span>, <span class="hljs-string">‘8’</span>, <span class="hljs-string">‘9’</span>, <span class="hljs-string">‘A’</span>, <span class="hljs-string">‘B’</span>, <span class="hljs-string">‘C’</span>, <span class="hljs-string">‘D’</span>, <span class="hljs-string">‘E’</span>, <span class="hljs-string">‘F’</span> };<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toHexString</span>(<span class="hljs-keyword">byte</span>[] b) { <span class="hljs-comment">// String to byte</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(b.length </em> <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.length; i++) {<br>            sb.append(HEX_DIGITS[(b[i] &amp; <span class="hljs-number">0xf0</span>) &gt;&gt;&gt; <span class="hljs-number">4</span>]);<br>            sb.append(HEX_DIGITS[b[i] &amp; <span class="hljs-number">0x0f</span>]);<br>        }<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">AndroidMd5</span>(String s) {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// Create MD5Util Hash</span><br>            MessageDigest digest = MessageDigest<br>                    .getInstance(<span class="hljs-string">“MD5”</span>);<br>            digest.update(s.getBytes());<br>            <span class="hljs-keyword">byte</span> messageDigest[] = digest.digest();<br><br>            <span class="hljs-keyword">return</span> toHexString(messageDigest);<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            e.printStackTrace();<br>        }<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">“”</span>;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {<br><br>        String m = MD5Util.str2MD5(<span class="hljs-string">“swwwwwwwwwwdkinner”</span>);<br><br>        System.out.print(m.length() + <span class="hljs-string">“    “</span>);<br>        System.out.println(m);<br><br>    }<br>}<br></code></pre><br><br><br><br><h3 id="2sha">2.SHA</h3><br><br><p>SHA的全称是Secure Hash Algorithm，即安全散列算法。 1993年，安全散列算法(SHA)由美国国家标准和技术协会（NIST)提出，并作为联邦信息处理标准(FIPS PUB 180)公布， 1995年又发布了一个修订版FIPS PUB 180-1，通常称之为SHA-1。 SHA-1是基于MD4算法的，现在已成为公认的最安全的散列算法之一，并被广泛使用。SHA-1算法生成的摘要信息的长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上， SHA-1的运行速度比MD5更慢，但是也更为安全。</p><br><br><br><br><pre class="prettyprint"><code class=" hljs http"><br><br><span class="java"><span class="hljs-keyword">import</span> com.google.common.base.Strings;<br><br><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><br><span class="hljs-javadoc">/<strong><br> <em> SHA的全称是Secure Hash Algorithm，即安全散列算法
 </em> Created by fangzhipeng on 2017/3/21.<br> */</strong></span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SHAUtil</span> {</span><br><br>    <span class="hljs-javadoc">/<br>     <em> 定义加密方式
     </em>/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String KEY_SHA = <span class="hljs-string">“SHA”</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String KEY_SHA1 = <span class="hljs-string">“SHA-1”</span>;<br>    <span class="hljs-javadoc">/<strong><br>     <em> 全局数组
     </em>/</strong></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String[] hexDigits = { <span class="hljs-string">“0”</span>, <span class="hljs-string">“1”</span>, <span class="hljs-string">“2”</span>, <span class="hljs-string">“3”</span>, <span class="hljs-string">“4”</span>, <span class="hljs-string">“5”</span>,<br>            <span class="hljs-string">“6”</span>, <span class="hljs-string">“7”</span>, <span class="hljs-string">“8”</span>, <span class="hljs-string">“9”</span>, <span class="hljs-string">“a”</span>, <span class="hljs-string">“b”</span>, <span class="hljs-string">“c”</span>, <span class="hljs-string">“d”</span>, <span class="hljs-string">“e”</span>, <span class="hljs-string">“f”</span> };<br><br>    <span class="hljs-javadoc">/<br>     <em> 构造函数
     </em>/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title">SHAUtil</span>() {<br><br>    }<br><br>    <span class="hljs-javadoc">/<strong><br>     <em> SHA 加密
     </em><span class="hljs-javadoctag"> @param</span> data 需要加密的字节数组<br>     <em><span class="hljs-javadoctag"> @return</span> 加密之后的字节数组
     </em><span class="hljs-javadoctag"> @throws</span> Exception<br>     */</strong></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">encryptSHA</span>(<span class="hljs-keyword">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-comment">// 创建具有指定算法名称的信息摘要</span><br><span class="hljs-comment">//        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);</span><br>        MessageDigest sha = MessageDigest.getInstance(KEY_SHA1);<br>        <span class="hljs-comment">// 使用指定的字节数组对摘要进行最后更新</span><br>        sha.update(data);<br>        <span class="hljs-comment">// 完成摘要计算并返回</span><br>        <span class="hljs-keyword">return</span> sha.digest();<br>    }<br><br>    <span class="hljs-javadoc">/<br>     <em> SHA 加密
     </em><span class="hljs-javadoctag"> @param</span> data 需要加密的字符串<br>     <em><span class="hljs-javadoctag"> @return</span> 加密之后的字符串
     </em><span class="hljs-javadoctag"> @throws</span> Exception<br>     <em>/</em></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encryptSHA</span>(String data) <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-comment">// 验证传入的字符串</span><br>        <span class="hljs-keyword">if</span> (Strings.isNullOrEmpty(data)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">“”</span>;<br>        }<br>        <span class="hljs-comment">// 创建具有指定算法名称的信息摘要</span><br>        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);<br>        <span class="hljs-comment">// 使用指定的字节数组对摘要进行最后更新</span><br>        sha.update(data.getBytes());<br>        <span class="hljs-comment">// 完成摘要计算</span><br>        <span class="hljs-keyword">byte</span>[] bytes = sha.digest();<br>        <span class="hljs-comment">// 将得到的字节数组变成字符串返回</span><br>        <span class="hljs-keyword">return</span> byteArrayToHexString(bytes);<br>    }<br><br>    <span class="hljs-javadoc">/**
      将一个字节转化成十六进制形式的字符串<br>     <em><span class="hljs-javadoctag"> @param</span> b 字节数组
     </em><span class="hljs-javadoctag"> @return</span> 字符串<br>     <em>/</em></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteToHexString</span>(<span class="hljs-keyword">byte</span> b) {<br>        <span class="hljs-keyword">int</span> ret = b;<br>        <span class="hljs-comment">//System.out.println(“ret = “ + ret);</span><br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) {<br>            ret += <span class="hljs-number">256</span>;<br>        }<br>        <span class="hljs-keyword">int</span> m = ret / <span class="hljs-number">16</span>;<br>        <span class="hljs-keyword">int</span> n = ret % <span class="hljs-number">16</span>;<br>        <span class="hljs-keyword">return</span> hexDigits[m] + hexDigits[n];<br>    }<br><br>    <span class="hljs-javadoc">/**
      转换字节数组为十六进制字符串<br>     <em><span class="hljs-javadoctag"> @param</span> bytes 字节数组
     </em><span class="hljs-javadoctag"> @return</span> 十六进制字符串<br>     <em>/</em></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteArrayToHexString</span>(<span class="hljs-keyword">byte</span>[] bytes) {<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bytes.length; i++) {<br>            sb.append(byteToHexString(bytes[i]));<br>        }<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    }<br><br>    <span class="hljs-javadoc">/**
      测试方法<br>     <em><span class="hljs-javadoctag"> @param</span> args
     </em>/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> Exception {<br>        String key = <span class="hljs-string">“123”</span>;<br>        System.out.println(encryptSHA(key));<br>    }<br>}<br></span></code></pre><br><br><br><br><h2 id="二对称加密">二、对称加密</h2><br><br><blockquote><br>  <p>对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发送方将明文(原始数据)和加密密钥一起经过特殊加密算法处理后，生成复杂的加密密文进行发送，数据接收方收到密文后，若想读取原文，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行加密和解密，这就要求加密和解密方事先都必须知道加密的密钥。</p><br></blockquote><br><br><br><br><h3 id="1-des算法">1. DES算法</h3><br><br><p>1973 年，美国国家标准局(NBS)在认识到建立数据保护标准既明显又急迫的情况下，开始征集联邦数据加密标准的方案。 1975 年3月17日， NBS公布了IBM公司提供的密码算法，以标准建议的形式在全国范围内征求意见。经过两年多的公开讨论之后， 1977 年7月15日， NBS宣布接受这建议，作为联邦信息处理标准46 号数据加密标准(Data Encryptin Standard)，即DES正式颁布，供商业界和非国防性政府部门使用。DES算法属于对称加密算法，明文按64位进行分组，密钥长64位，但事实上只有56位参与DES <br><br>运算(第8、 16、 24、 32、 40、 48、 56、 64位是校验位，使得每个密钥都有奇数个1),分组后的明文和56位的密钥按位替代或交换的方法形成密文。由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解，因此演变出了3DES算法。 3DES是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密，是DES的一个更安全的变形</p><br><br><br><br><pre class="prettyprint"><code class=" hljs http"><br><br><span class="java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.SecretKey;<br><span class="hljs-keyword">import</span> javax.crypto.SecretKeyFactory;<br><span class="hljs-keyword">import</span> javax.crypto.spec.DESKeySpec;<br><br><br><span class="hljs-keyword">import</span> sun.misc.BASE64Decoder;<br><span class="hljs-keyword">import</span> sun.misc.BASE64Encoder;<br><br><span class="hljs-javadoc">/<strong><br> <em> Data Encryptin Standard
 </em> 数据加密标准<br> */</strong></span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DESUtil</span> {</span><br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String DES = <span class="hljs-string">“DES”</span>;<br><br>    <span class="hljs-javadoc">/<br>     <em> Description 根据键值进行加密
     </em><br>     <em><span class="hljs-javadoctag"> @param</span> data
     </em><span class="hljs-javadoctag"> @param</span> key  加密键byte数组<br>     <em><span class="hljs-javadoctag"> @return</span>
     </em><span class="hljs-javadoctag"> @throws</span> Exception<br>     <em>/</em></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span>(String data, String key) <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-keyword">byte</span>[] bt = encrypt(data.getBytes(), key.getBytes());<br>        String strs = <span class="hljs-keyword">new</span> BASE64Encoder().encode(bt);<br>        <span class="hljs-keyword">return</span> strs;<br>    }<br><br>    <span class="hljs-javadoc">/**
      Description 根据键值进行解密<br>     <em>
     </em><span class="hljs-javadoctag"> @param</span> data<br>     <em><span class="hljs-javadoctag"> @param</span> key  加密键byte数组
     </em><span class="hljs-javadoctag"> @return</span><br>     <em><span class="hljs-javadoctag"> @throws</span> IOException
     </em><span class="hljs-javadoctag"> @throws</span> Exception<br>     <em>/</em></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span>(String data, String key) <span class="hljs-keyword">throws</span> Exception,<br>            Exception {<br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        BASE64Decoder decoder = <span class="hljs-keyword">new</span> BASE64Decoder();<br>        <span class="hljs-keyword">byte</span>[] buf = decoder.decodeBuffer(data);<br>        <span class="hljs-keyword">byte</span>[] bt = decrypt(buf, key.getBytes());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bt);<br>    }<br><br>    <span class="hljs-javadoc">/**
      Description 根据键值进行加密<br>     <em>
     </em><span class="hljs-javadoctag"> @param</span> data<br>     <em><span class="hljs-javadoctag"> @param</span> key  加密键byte数组
     </em><span class="hljs-javadoctag"> @return</span><br>     <em><span class="hljs-javadoctag"> @throws</span> Exception
     </em>/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">encrypt</span>(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key) <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-comment">// 生成一个可信任的随机数源</span><br>        SecureRandom sr = <span class="hljs-keyword">new</span> SecureRandom();<br><br>        <span class="hljs-comment">// 从原始密钥数据创建DESKeySpec对象</span><br>        DESKeySpec dks = <span class="hljs-keyword">new</span> DESKeySpec(key);<br><br>        <span class="hljs-comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span><br>        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);<br>        SecretKey securekey = keyFactory.generateSecret(dks);<br><br>        <span class="hljs-comment">// Cipher对象实际完成加密操作</span><br>        Cipher cipher = Cipher.getInstance(DES);<br><br>        <span class="hljs-comment">// 用密钥初始化Cipher对象</span><br>        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);<br><br>        <span class="hljs-keyword">return</span> cipher.doFinal(data);<br>    }<br><br><br>    <span class="hljs-javadoc">/<strong><br>     <em> Description 根据键值进行解密
     </em><br>     <em><span class="hljs-javadoctag"> @param</span> data
     </em><span class="hljs-javadoctag"> @param</span> key  加密键byte数组<br>     <em><span class="hljs-javadoctag"> @return</span>
     </em><span class="hljs-javadoctag"> @throws</span> Exception<br>     */</strong></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">decrypt</span>(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key) <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-comment">// 生成一个可信任的随机数源</span><br>        SecureRandom sr = <span class="hljs-keyword">new</span> SecureRandom();<br><br>        <span class="hljs-comment">// 从原始密钥数据创建DESKeySpec对象</span><br>        DESKeySpec dks = <span class="hljs-keyword">new</span> DESKeySpec(key);<br><br>        <span class="hljs-comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span><br>        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);<br>        SecretKey securekey = keyFactory.generateSecret(dks);<br><br>        <span class="hljs-comment">// Cipher对象实际完成解密操作</span><br>        Cipher cipher = Cipher.getInstance(DES);<br><br>        <span class="hljs-comment">// 用密钥初始化Cipher对象</span><br>        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);<br><br>        <span class="hljs-keyword">return</span> cipher.doFinal(data);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[]args)<span class="hljs-keyword">throws</span> Exception{<br>       String  sStr=encrypt(<span class="hljs-string">“122222112222:12343232323:jajwwwwslwskwkkwksk”</span>,<span class="hljs-string">“wew2323w233321ws233w”</span>);<br>       System.out.println(sStr);<br>       String mStr=decrypt(sStr,<span class="hljs-string">“wew2323w233321ws233w”</span>);<br>       System.out.println(mStr);<br>    }<br>}<br></span></code></pre><br><br><br><br><h3 id="2-aes">2. AES</h3><br><br><p>AES的全称是Advanced Encryption Standard，即高级加密标准，该算法由比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，又称Rijndael加密算法，是美国联邦政府采用的一种对称加密标准，这个标准用来替代原先的DES算法，已经广为全世界所使用，已然成为对称加密算法中最流行的算法之一。AES算法作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优 <br><br>点，设计有三个密钥长度:128,192,256位，比DES算法的加密强度更高，更为安全。</p><br><br><br><br><pre class="prettyprint"><code class=" hljs java"><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<br><span class="hljs-keyword">import</span> java.security.InvalidKeyException;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">import</span> javax.crypto.BadPaddingException;<br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.IllegalBlockSizeException;<br><span class="hljs-keyword">import</span> javax.crypto.KeyGenerator;<br><span class="hljs-keyword">import</span> javax.crypto.NoSuchPaddingException;<br><span class="hljs-keyword">import</span> javax.crypto.SecretKey;<br><span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<br><br><span class="hljs-keyword">import</span> sun.misc.BASE64Decoder;<br><span class="hljs-keyword">import</span> sun.misc.BASE64Encoder;<br><br><span class="hljs-javadoc">/<br> <em> Created by fangzhipeng on 2017/3/21.
 </em>/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESUtil</span> {</span><br><br>    <span class="hljs-keyword">static</span>  <span class="hljs-keyword">byte</span>[]  key = <span class="hljs-string">“w@#$4@#$s^&amp;3<em>&amp;^4”</em></span>.getBytes();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String algorithm=<span class="hljs-string">“AES”</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span>(String data){<br><br>        <span class="hljs-keyword">byte</span>[] dataToSend = data.getBytes();<br>        Cipher c = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            c = Cipher.getInstance(algorithm);<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        } <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        }<br>        SecretKeySpec k =  <span class="hljs-keyword">new</span> SecretKeySpec(key, algorithm);<br>        <span class="hljs-keyword">try</span> {<br>            c.init(Cipher.ENCRYPT_MODE, k);<br>        } <span class="hljs-keyword">catch</span> (InvalidKeyException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        }<br>        <span class="hljs-keyword">byte</span>[] encryptedData = <span class="hljs-string">“”</span>.getBytes();<br>        <span class="hljs-keyword">try</span> {<br>            encryptedData = c.doFinal(dataToSend);<br>        } <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        } <span class="hljs-keyword">catch</span> (BadPaddingException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        }<br>        <span class="hljs-keyword">byte</span>[] encryptedByteValue =     Base64.getEncoder().encode(encryptedData);<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> String(encryptedByteValue);<span class="hljs-comment">//.toString();</span><br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span>(String data){<br><br>        <span class="hljs-keyword">byte</span>[] encryptedData  =  Base64.getDecoder().decode(data);<br>        Cipher c = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            c = Cipher.getInstance(algorithm);<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        } <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        }<br>        SecretKeySpec k =<br>                <span class="hljs-keyword">new</span> SecretKeySpec(key, algorithm);<br>        <span class="hljs-keyword">try</span> {<br>            c.init(Cipher.DECRYPT_MODE, k);<br>        } <span class="hljs-keyword">catch</span> (InvalidKeyException e1) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e1.printStackTrace();<br>        }<br>        <span class="hljs-keyword">byte</span>[] decrypted = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            decrypted = c.doFinal(encryptedData);<br>        } <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        } <span class="hljs-keyword">catch</span> (BadPaddingException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decrypted);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args){<br>        String password=encrypt(<span class="hljs-string">“12233440988:1239874389888:dd333”</span>);<br>        System.out.println(password);<br>        System.out.println(decrypt(password));<br>    }<br>}<br><br></code></pre><br><br><br><br><h2 id="三非对称加密">三、非对称加密</h2><br><br><blockquote><br>  <p>非对称加密算法又称为公开密钥加密算法，它需要两个密钥，一个称为公开密钥(public key)，即公钥，另一个称为私有密钥(private key)，即私钥。公钥与私钥需要配对使用，如果用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它人公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再使用自己保存的另一把专用密钥，即私钥，对加密后的信息进行解密。</p><br></blockquote><br><br><br><br><h3 id="rsa">RSA</h3><br><br><p>RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发的， RSA取名来自开发他们三者的名字。 RSA是目前最有影响力的非对称加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。 RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但反过来想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><br><br><br><br><pre class="prettyprint"><code class=" hljs java"><br><span class="hljs-javadoc">/**
  Created by fangzhipeng on 2017/3/21.<br> <em> RSA ：RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发   </em>  的， RSA取名来<br> <em>  自开发他们三者的名字。
 </em> 参考：<a href="http://blog.csdn.net/wangqiuyun/article/details/42143957" target="_blank" rel="external">http://blog.csdn.net/wangqiuyun/article/details/42143957</a><br> <em>/</em></span><br><br><span class="hljs-keyword">import</span> java.io.;<br><span class="hljs-keyword">import</span> java.security.InvalidKeyException;<br><span class="hljs-keyword">import</span> java.security.KeyFactory;<br><span class="hljs-keyword">import</span> java.security.KeyPair;<br><span class="hljs-keyword">import</span> java.security.KeyPairGenerator;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><br><span class="hljs-keyword">import</span> java.security.interfaces.RSAPrivateKey;<br><span class="hljs-keyword">import</span> java.security.interfaces.RSAPublicKey;<br><span class="hljs-keyword">import</span> java.security.spec.InvalidKeySpecException;<br><span class="hljs-keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;<br><span class="hljs-keyword">import</span> java.security.spec.X509EncodedKeySpec;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">import</span> javax.crypto.BadPaddingException;<br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.IllegalBlockSizeException;<br><span class="hljs-keyword">import</span> javax.crypto.NoSuchPaddingException;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RSAUtil</span> {</span><br><br><br>    <span class="hljs-javadoc">/<strong><br>     <em> 字节数据转字符串专用集合
     </em>/</strong></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] HEX_CHAR = { <span class="hljs-string">‘0’</span>, <span class="hljs-string">‘1’</span>, <span class="hljs-string">‘2’</span>, <span class="hljs-string">‘3’</span>, <span class="hljs-string">‘4’</span>, <span class="hljs-string">‘5’</span>, <span class="hljs-string">‘6’</span>,<br>            <span class="hljs-string">‘7’</span>, <span class="hljs-string">‘8’</span>, <span class="hljs-string">‘9’</span>, <span class="hljs-string">‘a’</span>, <span class="hljs-string">‘b’</span>, <span class="hljs-string">‘c’</span>, <span class="hljs-string">‘d’</span>, <span class="hljs-string">‘e’</span>, <span class="hljs-string">‘f’</span> };<br><br>    <span class="hljs-javadoc">/<br>     <em> 随机生成密钥对
     </em>/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genKeyPair</span>(String filePath) {<br>        <span class="hljs-comment">// KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象</span><br>        KeyPairGenerator keyPairGen = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            keyPairGen = KeyPairGenerator.getInstance(<span class="hljs-string">“RSA”</span>);<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        }<br>        <span class="hljs-comment">// 初始化密钥对生成器，密钥大小为96-1024位</span><br>        keyPairGen.initialize(<span class="hljs-number">1024</span>,<span class="hljs-keyword">new</span> SecureRandom());<br>        <span class="hljs-comment">// 生成一个密钥对，保存在keyPair中</span><br>        KeyPair keyPair = keyPairGen.generateKeyPair();<br>        <span class="hljs-comment">// 得到私钥</span><br>        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();<br>        <span class="hljs-comment">// 得到公钥</span><br>        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 得到公钥字符串</span><br>            <span class="hljs-comment">// 得到私钥字符串</span><br>            String privateKeyString =<span class="hljs-keyword">new</span> String( Base64.getEncoder().encode(privateKey.getEncoded()));<br>            String publicKeyString =<span class="hljs-keyword">new</span> String( Base64.getEncoder().encode(publicKey.getEncoded()));<br>            <span class="hljs-comment">// 将密钥对写入到文件</span><br><br>            File file1=<span class="hljs-keyword">new</span> File(filePath + <span class="hljs-string">“publicKey.keystore”</span>);<br>            File file2=<span class="hljs-keyword">new</span> File(filePath + <span class="hljs-string">“privateKey.keystore”</span>);<br>            <span class="hljs-keyword">if</span>(!file1.exists()) {<br>                file1.createNewFile();<br>            }<br>            <span class="hljs-keyword">if</span>(!file2.exists()) {<br>                file2.createNewFile();<br>            }<br>            FileWriter pubfw = <span class="hljs-keyword">new</span> FileWriter(filePath + <span class="hljs-string">“/publicKey.keystore”</span>);<br>            FileWriter prifw = <span class="hljs-keyword">new</span> FileWriter(filePath + <span class="hljs-string">“/privateKey.keystore”</span>);<br>            BufferedWriter pubbw = <span class="hljs-keyword">new</span> BufferedWriter(pubfw);<br>            BufferedWriter pribw = <span class="hljs-keyword">new</span> BufferedWriter(prifw);<br>            pubbw.write(publicKeyString);<br>            pribw.write(privateKeyString);<br>            pubbw.flush();<br>            pubbw.close();<br>            pubfw.close();<br>            pribw.flush();<br>            pribw.close();<br>            prifw.close();<br>        } <span class="hljs-keyword">catch</span> (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-javadoc">/<strong><br>     <em> 从文件中输入流中加载公钥
     </em><br>     <em><span class="hljs-javadoctag"> @param</span>
     </em><br>     <em><span class="hljs-javadoctag"> @throws</span> Exception
     </em>             加载公钥时产生的异常<br>     */</strong></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">loadPublicKeyByFile</span>(String path) <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-keyword">try</span> {<br>            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(path<br>                    + <span class="hljs-string">“/publicKey.keystore”</span>));<br>            String readLine = <span class="hljs-keyword">null</span>;<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">while</span> ((readLine = br.readLine()) != <span class="hljs-keyword">null</span>) {<br>                sb.append(readLine);<br>            }<br>            br.close();<br>            <span class="hljs-keyword">return</span> sb.toString();<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“公钥数据流读取错误”</span>);<br>        } <span class="hljs-keyword">catch</span> (NullPointerException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“公钥输入流为空”</span>);<br>        }<br>    }<br><br>    <span class="hljs-javadoc">/<br>     <em> 从字符串中加载公钥
     </em><br>     <em><span class="hljs-javadoctag"> @param</span> publicKeyStr
     </em>            公钥数据字符串<br>     <em><span class="hljs-javadoctag"> @throws</span> Exception
     </em>             加载公钥时产生的异常<br>     <em>/</em></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RSAPublicKey <span class="hljs-title">loadPublicKeyByStr</span>(String publicKeyStr)<br>            <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">byte</span>[] buffer = Base64.getDecoder().decode(publicKeyStr);<br>            KeyFactory keyFactory = KeyFactory.getInstance(<span class="hljs-string">“RSA”</span>);<br>            X509EncodedKeySpec keySpec = <span class="hljs-keyword">new</span> X509EncodedKeySpec(buffer);<br>            <span class="hljs-keyword">return</span> (RSAPublicKey) keyFactory.generatePublic(keySpec);<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“无此算法”</span>);<br>        } <span class="hljs-keyword">catch</span> (InvalidKeySpecException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“公钥非法”</span>);<br>        } <span class="hljs-keyword">catch</span> (NullPointerException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“公钥数据为空”</span>);<br>        }<br>    }<br><br>    <span class="hljs-javadoc">/**
      从文件中加载私钥<br>     <em>
     </em><span class="hljs-javadoctag"> @param</span><br>     <em>
     </em><span class="hljs-javadoctag"> @return</span> 是否成功<br>     <em><span class="hljs-javadoctag"> @throws</span> Exception
     </em>/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">loadPrivateKeyByFile</span>(String path) <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-keyword">try</span> {<br>            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(path<br>                    + <span class="hljs-string">“/privateKey.keystore”</span>));<br>            String readLine = <span class="hljs-keyword">null</span>;<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">while</span> ((readLine = br.readLine()) != <span class="hljs-keyword">null</span>) {<br>                sb.append(readLine);<br>            }<br>            br.close();<br>            <span class="hljs-keyword">return</span> sb.toString();<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“私钥数据读取错误”</span>);<br>        } <span class="hljs-keyword">catch</span> (NullPointerException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“私钥输入流为空”</span>);<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RSAPrivateKey <span class="hljs-title">loadPrivateKeyByStr</span>(String privateKeyStr)<br>            <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">byte</span>[] buffer = Base64.getDecoder().decode(privateKeyStr);<br>            PKCS8EncodedKeySpec keySpec = <span class="hljs-keyword">new</span> PKCS8EncodedKeySpec(buffer);<br>            KeyFactory keyFactory = KeyFactory.getInstance(<span class="hljs-string">“RSA”</span>);<br>            <span class="hljs-keyword">return</span> (RSAPrivateKey) keyFactory.generatePrivate(keySpec);<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“无此算法”</span>);<br>        } <span class="hljs-keyword">catch</span> (InvalidKeySpecException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“私钥非法”</span>);<br>        } <span class="hljs-keyword">catch</span> (NullPointerException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“私钥数据为空”</span>);<br>        }<br>    }<br><br>    <span class="hljs-javadoc">/<strong><br>     <em> 公钥加密过程
     </em><br>     <em><span class="hljs-javadoctag"> @param</span> publicKey
     </em>            公钥<br>     <em><span class="hljs-javadoctag"> @param</span> plainTextData
     </em>            明文数据<br>     <em><span class="hljs-javadoctag"> @return</span>
     </em><span class="hljs-javadoctag"> @throws</span> Exception<br>     <em>             加密过程中的异常信息
     </em>/</strong></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">encrypt</span>(RSAPublicKey publicKey, <span class="hljs-keyword">byte</span>[] plainTextData)<br>            <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-keyword">if</span> (publicKey == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“加密公钥为空, 请设置”</span>);<br>        }<br>        Cipher cipher = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 使用默认RSA</span><br>            cipher = Cipher.getInstance(<span class="hljs-string">“RSA”</span>);<br>            <span class="hljs-comment">// cipher= Cipher.getInstance(“RSA”, new BouncyCastleProvider());</span><br>            cipher.init(Cipher.ENCRYPT_MODE, publicKey);<br>            <span class="hljs-keyword">byte</span>[] output = cipher.doFinal(plainTextData);<br>            <span class="hljs-keyword">return</span> output;<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“无此加密算法”</span>);<br>        } <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) {<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        } <span class="hljs-keyword">catch</span> (InvalidKeyException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“加密公钥非法,请检查”</span>);<br>        } <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“明文长度非法”</span>);<br>        } <span class="hljs-keyword">catch</span> (BadPaddingException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“明文数据已损坏”</span>);<br>        }<br>    }<br><br>    <span class="hljs-javadoc">/<br>     <em> 私钥加密过程
     </em><br>     <em><span class="hljs-javadoctag"> @param</span> privateKey
     </em>            私钥<br>     <em><span class="hljs-javadoctag"> @param</span> plainTextData
     </em>            明文数据<br>     <em><span class="hljs-javadoctag"> @return</span>
     </em><span class="hljs-javadoctag"> @throws</span> Exception<br>     <em>             加密过程中的异常信息
     </em>/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">encrypt</span>(RSAPrivateKey privateKey, <span class="hljs-keyword">byte</span>[] plainTextData)<br>            <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-keyword">if</span> (privateKey == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“加密私钥为空, 请设置”</span>);<br>        }<br>        Cipher cipher = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 使用默认RSA</span><br>            cipher = Cipher.getInstance(<span class="hljs-string">“RSA”</span>);<br>            cipher.init(Cipher.ENCRYPT_MODE, privateKey);<br>            <span class="hljs-keyword">byte</span>[] output = cipher.doFinal(plainTextData);<br>            <span class="hljs-keyword">return</span> output;<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“无此加密算法”</span>);<br>        } <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) {<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        } <span class="hljs-keyword">catch</span> (InvalidKeyException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“加密私钥非法,请检查”</span>);<br>        } <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“明文长度非法”</span>);<br>        } <span class="hljs-keyword">catch</span> (BadPaddingException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“明文数据已损坏”</span>);<br>        }<br>    }<br><br>    <span class="hljs-javadoc">/<strong><br>     <em> 私钥解密过程
     </em><br>     <em><span class="hljs-javadoctag"> @param</span> privateKey
     </em>            私钥<br>     <em><span class="hljs-javadoctag"> @param</span> cipherData
     </em>            密文数据<br>     <em><span class="hljs-javadoctag"> @return</span> 明文
     </em><span class="hljs-javadoctag"> @throws</span> Exception<br>     <em>             解密过程中的异常信息
     </em>/</strong></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">decrypt</span>(RSAPrivateKey privateKey, <span class="hljs-keyword">byte</span>[] cipherData)<br>            <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-keyword">if</span> (privateKey == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“解密私钥为空, 请设置”</span>);<br>        }<br>        Cipher cipher = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 使用默认RSA</span><br>            cipher = Cipher.getInstance(<span class="hljs-string">“RSA”</span>);<br>            <span class="hljs-comment">// cipher= Cipher.getInstance(“RSA”, new BouncyCastleProvider());</span><br>            cipher.init(Cipher.DECRYPT_MODE, privateKey);<br>            <span class="hljs-keyword">byte</span>[] output = cipher.doFinal(cipherData);<br>            <span class="hljs-keyword">return</span> output;<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“无此解密算法”</span>);<br>        } <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) {<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        } <span class="hljs-keyword">catch</span> (InvalidKeyException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“解密私钥非法,请检查”</span>);<br>        } <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“密文长度非法”</span>);<br>        } <span class="hljs-keyword">catch</span> (BadPaddingException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“密文数据已损坏”</span>);<br>        }<br>    }<br><br>    <span class="hljs-javadoc">/<br>     <em> 公钥解密过程
     </em><br>     <em><span class="hljs-javadoctag"> @param</span> publicKey
     </em>            公钥<br>     <em><span class="hljs-javadoctag"> @param</span> cipherData
     </em>            密文数据<br>     <em><span class="hljs-javadoctag"> @return</span> 明文
     </em><span class="hljs-javadoctag"> @throws</span> Exception<br>     <em>             解密过程中的异常信息
     </em>/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">decrypt</span>(RSAPublicKey publicKey, <span class="hljs-keyword">byte</span>[] cipherData)<br>            <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-keyword">if</span> (publicKey == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“解密公钥为空, 请设置”</span>);<br>        }<br>        Cipher cipher = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 使用默认RSA</span><br>            cipher = Cipher.getInstance(<span class="hljs-string">“RSA”</span>);<br>            <span class="hljs-comment">// cipher= Cipher.getInstance(“RSA”, new BouncyCastleProvider());</span><br>            cipher.init(Cipher.DECRYPT_MODE, publicKey);<br>            <span class="hljs-keyword">byte</span>[] output = cipher.doFinal(cipherData);<br>            <span class="hljs-keyword">return</span> output;<br>        } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“无此解密算法”</span>);<br>        } <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) {<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        } <span class="hljs-keyword">catch</span> (InvalidKeyException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“解密公钥非法,请检查”</span>);<br>        } <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“密文长度非法”</span>);<br>        } <span class="hljs-keyword">catch</span> (BadPaddingException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">“密文数据已损坏”</span>);<br>        }<br>    }<br><br>    <span class="hljs-javadoc">/<em>*
     </em> 字节数据转十六进制字符串<br>     <em>
     </em><span class="hljs-javadoctag"> @param</span> data<br>     <em>            输入数据
     </em><span class="hljs-javadoctag"> @return</span> 十六进制内容<br>     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteArrayToString</span>(<span class="hljs-keyword">byte</span>[] data) {<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) {<br>            <span class="hljs-comment">// 取出字节的高四位 作为索引得到相应的十六进制标识符 注意无符号右移</span><br>            stringBuilder.append(HEX_CHAR[(data[i] &amp; <span class="hljs-number">0xf0</span>) &gt;&gt;&gt; <span class="hljs-number">4</span>]);<br>            <span class="hljs-comment">// 取出字节的低四位 作为索引得到相应的十六进制标识符</span><br>            stringBuilder.append(HEX_CHAR[(data[i] &amp; <span class="hljs-number">0x0f</span>)]);<br>            <span class="hljs-keyword">if</span> (i &lt; data.length - <span class="hljs-number">1</span>) {<br>                stringBuilder.append(<span class="hljs-string">‘ ‘</span>);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    }<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> Exception {<br>        String filepath=<span class="hljs-string">“F:/temp/“</span>;<br>        File file=<span class="hljs-keyword">new</span> File(filepath);<br>        <span class="hljs-keyword">if</span>(!file.exists()){<br>            file.mkdir();<br>        }<br>        genKeyPair(filepath);<br>        System.out.println(<span class="hljs-string">“————–公钥加密私钥解密过程——————-“</span>);<br>        String plainText=<span class="hljs-string">“1223333323:8783737321232:dewejj28i33e92hhsxxxx”</span>;<br>        <span class="hljs-comment">//公钥加密过程</span><br>        <span class="hljs-keyword">byte</span>[] cipherData=encrypt(loadPublicKeyByStr(loadPublicKeyByFile(filepath)),plainText.getBytes());<br>        String cipher=<span class="hljs-keyword">new</span> String(Base64.getEncoder().encode(cipherData));<br>        <span class="hljs-comment">//私钥解密过程</span><br>        <span class="hljs-keyword">byte</span>[] res=decrypt(loadPrivateKeyByStr(loadPrivateKeyByFile(filepath)), Base64.getDecoder().decode(cipher));<br>        String restr=<span class="hljs-keyword">new</span> String(res);<br>        System.out.println(<span class="hljs-string">“原文：”</span>+plainText);<br>        System.out.println(<span class="hljs-string">“加密密文：”</span>+cipher);<br>        System.out.println(<span class="hljs-string">“解密：”</span>+restr);<br>        System.out.println();<br>    }<br>}<br></code></pre><br><br><p>注： 文字部分复制了《大型电商分布式系统实践 第一版 讲师 陈康贤》的第三课。代码来源于自己的整理，全部测试通过，应该没有坑。</p></div><br>        <script type="text/javascript"><br>            $(function () {<br>                $(‘pre.prettyprint code’).each(function () {<br>                    var lines = $(this).text().split(‘\n’).length;<br>                    var $numbering = $(‘<ul/>‘).addClass(‘pre-numbering’).hide();<br>                    $(this).addClass(‘has-numbering’).parent().append($numbering);<br>                    for (i = 1; i &lt;= lines; i++) {<br>                        $numbering.append($(‘<li/>‘).text(i));<br>                    };<br>                    $numbering.fadeIn(1700);<br>                });<br>            });<br>        </script><br><br></div>



          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/11/08/hdAlgorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/08/hdAlgorithm/" itemprop="url">转载:[JAVA加解密]DH算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-08T17:05:44+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content csdn-tracking-statistics" data-mod="popu_519" data-dsm="post"><br><br><p>一、算法描述：</p><br><p>1.简介：</p><br><p>Diffie-Hellman:一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm).这个机制的巧妙在于需要安全通信的双方可以<span style="color:#ff0000">用这个方法确定<strong>对称密钥</strong></span>。然后可以用这个密钥进行加密和解密。但是注意，<span style="color:#ff0000">这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密</span>。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。<br><br></p><br><p>就是说，DH算法是用来安全地交换密钥的</p><br><p>2.算法描述：</p><br><p>基于原根的定义及性质，可以定义Diffie-Hellman密钥交换算法.该算法描述如下：<br><br>1，有两个全局公开的参数，一个素数q和一个整数a,a是q的一个原根.<br><br>2，假设用户A和B希望交换一个密钥，用户A选择一个作为私有密钥的随机数XA(XA&lt;q)，并计算公开密钥YA=a^XA mod q。A对XA的&#20540;保密存放而使YA能被B公开获得。类&#20284;地，用户B选择一个私有的随机数XB&lt;q，并计算公开密钥YB=a^XB mod q。B对XB的&#20540;保密存放而使YB能被A公开获得.<br><br>3，用户A产生共享秘密密钥的计算方式是K = (YB)^XA mod q.同样，用户B产生共享秘密密钥的计算是K = (YA)^XB mod q.这两个计算产生相同的结果： K = (YB)^XA mod q = (a^XB mod q)^XA mod q = (a^XB)^XA mod q （根据取模运算规则得到） = a^(XBXA) mod q = (a^XA)^XB mod q = (a^XA mod q)^XB mod q = (YA)^XB mod q 因此相当于双方已经交换了一个相同的秘密密钥.<br><br>4，因为XA和XB是保密的，一个敌对方可以利用的参数只有q,a,YA和YB.因而敌对方被迫取离散对数来确定密钥.例如，要获取用户B的秘密密钥，敌对方必须先计算 XB = inda,q(YB) 然后再使用用户B采用的同样方法计算其秘密密钥K. Diffie-Hellman密钥交换算法的安全性依赖于这样一个事实：<span style="color:#ff0000">虽然计算以一个素数为模的指数相对容易，但计算离散对数却很困难</span>.对于大的素数，计算出离散对数几乎是不可能的. 下面给出例子.密钥交换基于素数q<br> = 97和97的一个原根a = 5.A和B分别选择私有密钥XA = 36和XB = 58.每人计算其公开密钥 YA = 5^36 = 50 mod 97 YB = 5^58 = 44 mod 97 在他们相互获取了公开密钥之后，各自通过计算得到双方共享的秘密密钥如下： K = (YB)^XA mod 97 = 44^36 = 75 mod 97 K = (YA)^XB mod 97 = 50^58 = 75 mod 97 从|50,44|出发，攻击者要计算出75很不容易. 下图给出了一个利用Diffie-Hellman计算的简单协议.<br><br></p><br><p><br><br></p><br><p>二、算法JAVA实现：</p><br><p>开始之前声明一下有一点还是不太明白：</p><br><p>假设甲方给乙方传数据，算法的实现要求乙方构建密钥时必须用甲方公钥构建乙方密钥。我自己是这样理解的：在实际实现的过程中，很难传递双方共享素数q及其元根α，因此采取这样的措施。</p><br><p>那么我们在接下的实现约定以下几个原则：</p><br><p>1.本地密钥：加密数据用的密钥</p><br><p>2.密钥=公钥&#43;私钥，甲乙有自己的不相同的密钥，用来加密本地密钥</p><br><p>3.一方的密钥由Init()直接产生，另一方的密钥构建需用到已构建方的公钥</p><br><p><br><br></p><br><p>首先，对全局变量声明：</p><br><p><pre name="code" class="java">&lt;span style=&quot;white-space:pre&quot;&gt;    &lt;/span&gt;private static final String KEY_ALGORITHM = &quot;DH&quot;;<br>    private static final String SECRET_ALGORITHM = &quot;AES&quot;;<br>    private static final int KEY_SIZE=512;<br>    private static final String PUBLIC_KEY=&quot;DHPublicKey&quot;;<br>    private static final String PRIVATE_KEY=&quot;DHPrivateKey&quot;;</pre><br><br></p><br><p>复习一下对称加密中产生密钥的三种方法：</p><br><p><pre name="code" class="plain">产生secretKey的三种方法：<br>a.凭空产生：KeyGenerator类对象获得SecretKey类对象：init()-&gt;generatorKey()<br>b.通过byte[]数组产生：密钥工厂利用密钥材料生成SecretKey：secretKeyFactory.generateSecretKey(dks);<br>c.通过byte[]数组产生：密钥材料类初始化成父类SecretKey</pre><br><br><br><br></p><br><p>构建DH甲方密钥对：凭空产生：<strong><span style="color:#ff0000">keyGenerator </span></strong>-&gt; keyPair -&gt;publicKey,privateKey. 最后用map对象返回，分别对应键: PUBLIC_KEY,PRIVATE_KEY</p><br><p><pre name="code" class="java">&lt;span style=&quot;white-space:pre&quot;&gt;    &lt;/span&gt;public static Map&lt;String,Object&gt; initKey() throws NoSuchAlgorithmException{<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM);<br>        keyPairGenerator.initialize(KEY_SIZE);<br>        KeyPair keyPair = keyPairGenerator.generateKeyPair();<br>        PublicKey publicKey = keyPair.getPublic();<br>        PrivateKey privateKey = keyPair.getPrivate();<br>        Map&lt;String,Object&gt; keyMap = new HashMap&lt;String,Object&gt;(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }</pre><br><br>构建DH乙方密钥对：由甲方公钥产生：由byte[]-&gt;密钥材料-&gt;密钥工厂还原甲方公钥-&gt;-&gt;密钥材料DHParameterSpec-&gt;keyPariGenerator初始化成keyPairGenerator</p><br><p>就是一个byte[]-&gt;材料-&gt;密钥-&gt;材料-&gt;密钥；2.3步为还原甲密钥，4.5步产生乙密钥</p><br><p><strong><span style="color:#ff0000">至此得出一个结论：密钥共厂可以把密钥材料转换成密钥</span></strong></p><br><p><strong><span style="color:#ff0000"><em>Spec这样的材料类可以把byte[]或密钥转成密钥材料</em></span></strong></p><br><p><pre name="code" class="java">public static Map&lt;String,Object&gt; initKey(byte[] key) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidAlgorithmParameterException{<br>        //拿到传进来的公钥<br>        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(key);<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        PublicKey pubKey = keyFactory.generatePublic(x509EncodedKeySpec);//Cannot make a static reference to the non-static method generatePublic(KeySpec) from the type KeyFactory<br><br>        //传进来的公钥构造密钥材料<br>        DHParameterSpec dhParameter = ((DHPublicKey)pubKey).getParams();<br><br>        //产生乙方公钥，私钥<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyFactory.getAlgorithm());<br>        keyPairGenerator.initialize(dhParameter);<br>        KeyPair keyPair = keyPairGenerator.genKeyPair();<br>        DHPublicKey publicKey = (DHPublicKey)keyPair.getPublic();<br>        DHPrivateKey privateKey = (DHPrivateKey)keyPair.getPrivate();<br><br>        Map&lt;String,Object&gt; keyMap = new HashMap&lt;String,Object&gt;(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }</pre><br><br>构建本地密钥代码：</p><br><p><pre name="code" class="java">&lt;span style=&quot;white-space:pre&quot;&gt;    &lt;/span&gt;public static byte[] getSecretKey(byte[] publicKey,byte[] privateKey) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException{<br>        //通过KeyFactory还原密钥，注意公私钥的材料类<br>        //byte[] -&gt;密钥材料-&gt;密钥<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(publicKey);<br>        PublicKey pubKey = keyFactory.generatePublic(x509EncodedKeySpec);<br><br>        PKCS8EncodedKeySpec  pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKey);<br>        PrivateKey priKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec);<br><br>        //实例化<br>        KeyAgreement keyAgree = KeyAgreement.getInstance(KEY_ALGORITHM);<br>        keyAgree.init(priKey);<br>        keyAgree.doPhase(pubKey, true);<br><br>        SecretKey secretKey = keyAgree.generateSecret(SECRET_ALGORITHM);<br>        return secretKey.getEncoded();<br>    }</pre><br><br>keyAgreement类实现公钥密码学产生本地密钥SecretKey</p><br><p>keyAgree,init(私钥)-&gt;doPhase(公钥，true)-&gt;generateSecretKey()</p><br><p><br><br></p><br><p>DHCoder实现：</p><br><p><pre name="code" class="java">public abstract class DHCoder {<br>    private static final String KEY_ALGORITHM = &quot;DH&quot;;<br>    private static final String SECRET_ALGORITHM = &quot;AES&quot;;<br>    private static final int KEY_SIZE=512;<br>    private static final String PUBLIC_KEY=&quot;DHPublicKey&quot;;<br>    private static final String PRIVATE_KEY=&quot;DHPrivateKey&quot;;<br><br>    public static Map&lt;String,Object&gt; initKey() throws NoSuchAlgorithmException{<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM);<br>        keyPairGenerator.initialize(KEY_SIZE);<br>        KeyPair keyPair = keyPairGenerator.generateKeyPair();<br>        PublicKey publicKey = keyPair.getPublic();<br>        PrivateKey privateKey = keyPair.getPrivate();<br>        Map&lt;String,Object&gt; keyMap = new HashMap&lt;String,Object&gt;(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }<br><br>    public static Map&lt;String,Object&gt; initKey(byte[] key) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidAlgorithmParameterException{<br>        //拿到传进来的公钥<br>        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(key);<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        PublicKey pubKey = keyFactory.generatePublic(x509EncodedKeySpec);//Cannot make a static reference to the non-static method generatePublic(KeySpec) from the type KeyFactory<br><br>        //传进来的公钥构造密钥材料<br>        DHParameterSpec dhParameter = ((DHPublicKey)pubKey).getParams();<br><br>        //产生乙方公钥，私钥<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyFactory.getAlgorithm());<br>        keyPairGenerator.initialize(dhParameter);<br>        KeyPair keyPair = keyPairGenerator.genKeyPair();<br>        DHPublicKey publicKey = (DHPublicKey)keyPair.getPublic();<br>        DHPrivateKey privateKey = (DHPrivateKey)keyPair.getPrivate();<br><br>        Map&lt;String,Object&gt; keyMap = new HashMap&lt;String,Object&gt;(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br><br><br>    }<br><br><br>    public static byte[] encrypt(byte[] data,byte[]key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{<br>        SecretKey secretKey = new SecretKeySpec(key,SECRET_ALGORITHM);<br>        Cipher cipher = Cipher.getInstance(SECRET_ALGORITHM);<br>        cipher.init(Cipher.ENCRYPT_MODE, secretKey);<br>        return cipher.doFinal(data);<br>    }<br><br>    public static byte[] decrypt(byte[] data,byte[]key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{<br>        SecretKey secretKey = new SecretKeySpec(key,SECRET_ALGORITHM);<br>        Cipher cipher = Cipher.getInstance(SECRET_ALGORITHM);<br>        cipher.init(Cipher.DECRYPT_MODE, secretKey);<br>        return cipher.doFinal(data);<br>    }<br><br>    public static byte[] getSecretKey(byte[] publicKey,byte[] privateKey) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException{<br>        //通过KeyFactory还原密钥，注意公私钥的材料类<br>        //byte[] -&gt;密钥材料-&gt;密钥<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(publicKey);<br>        PublicKey pubKey = keyFactory.generatePublic(x509EncodedKeySpec);<br><br>        PKCS8EncodedKeySpec  pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKey);<br>        PrivateKey priKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec);<br><br>        //实例化<br>        KeyAgreement keyAgree = KeyAgreement.getInstance(KEY_ALGORITHM);<br>        keyAgree.init(priKey);<br>        keyAgree.doPhase(pubKey, true);<br><br>        SecretKey secretKey = keyAgree.generateSecret(SECRET_ALGORITHM);<br>        return secretKey.getEncoded();<br>    }<br><br>    public static byte[] getPrivateKey(Map&lt;String,Object&gt; keyMap){<br>        Key key = (Key)keyMap.get(PRIVATE_KEY);<br>        return key.getEncoded();<br>    }<br><br>    public static byte[] getPublicKey(Map&lt;String,Object&gt; keyMap){<br>        Key key = (Key)keyMap.get(PUBLIC_KEY);<br>        return key.getEncoded();<br>    }<br><br><br><br>}</pre><br><br><br><br></p><br><p>三、DH算法测试用例：</p><br><p>测试两个东西：</p><br><p>1.甲乙方本地密钥应相同；</p><br><p>2.加解密能否互相实现；</p><br><p><pre name="code" class="java">public class DHCoderTest {<br>    private byte[] publicKey1;<br>    private byte[] privateKey1;<br>    private byte[] key1;<br>    private byte[] publicKey2;<br>    private byte[] privateKey2;<br>    private byte[] key2;<br><br>    @Before<br>    public final void initKey() throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidAlgorithmParameterException, InvalidKeyException{<br>        Map&lt;String,Object&gt; keyMap1 = DHCoder.initKey();<br>        publicKey1 = DHCoder.getPublicKey(keyMap1);<br>        privateKey1 = DHCoder.getPrivateKey(keyMap1);<br>        System.err.println(&quot;甲方公钥：\n&quot;+Base64.encodeBase64String(publicKey1));<br>        System.err.println(&quot;甲方私钥：\n&quot;+Base64.encodeBase64String(privateKey1));<br><br>        //甲方公钥产生乙方公私钥<br>        Map&lt;String,Object&gt; keyMap2 = DHCoder.initKey(publicKey1);<br>        publicKey2 = DHCoder.getPublicKey(keyMap2);<br>        privateKey2 = DHCoder.getPrivateKey(keyMap2);<br>        System.err.println(&quot;乙方公钥：\n&quot;+Base64.encodeBase64String(publicKey2));<br>        System.err.println(&quot;乙方私钥：\n&quot;+Base64.encodeBase64String(privateKey2));<br><br>        key1 = DHCoder.getSecretKey(publicKey2, privateKey1);<br>        key2 = DHCoder.getSecretKey(publicKey1, privateKey2);<br>        System.err.println(&quot;甲方本地密钥：\n&quot;+Base64.encodeBase64String(key1));<br>        System.err.println(&quot;乙方本地密钥：\n&quot;+Base64.encodeBase64String(key2));<br><br>        assertArrayEquals(key1,key2);<br><br>    }<br><br>    @Test<br>    public final void test() throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {<br>        System.err.println(&quot;\n=====甲方向乙方发送加密数据=====&quot;);<br>        String input1=&quot;密钥交换算法&quot;;<br>        System.err.println(&quot;原文： &quot;+input1);<br>        System.err.println(&quot;—使用甲方密钥对本地数据加密—&quot;);<br><br>        byte[] code1=DHCoder.encrypt(input1.getBytes(), key1);<br>        System.err.println(&quot;加密： &quot;+Base64.encodeBase64String(code1));<br>        System.err.println(&quot;—使用乙方密钥对本地数据解密—&quot;);<br><br>        byte[] decode1 = DHCoder.decrypt(code1, key2);<br>        String output1= new String(decode1);<br>        System.err.println(&quot;解密：  &quot;+output1);<br><br>        assertEquals(input1,output1);<br><br>        System.err.println(&quot;\n=====乙方向甲方发送加密数据=====&quot;);<br>        String input2=&quot;DH&quot;;<br>        System.err.println(&quot;原文： &quot;+input2);<br>        System.err.println(&quot;—使用乙方密钥对本地数据加密—&quot;);<br><br>        byte[] code2=DHCoder.encrypt(input2.getBytes(), key2);<br>        System.err.println(&quot;加密： &quot;+Base64.encodeBase64String(code2));<br>        System.err.println(&quot;—使用甲方密钥对本地数据解密—&quot;);<br><br>        byte[] decode2 = DHCoder.decrypt(code2, key1);<br>        String output2= new String(decode2);<br>        System.err.println(&quot;解密：  &quot;+output2);<br><br>        assertEquals(input2,output2);<br><br>    }<br></pre><br><br><strong>输出：</strong></p><br><p>甲方公钥：<br><br>MIHgMIGXBgkqhkiG9w0BAwEwgYkCQQD8poLOjhLKuibvzPcRDlJtsHiwXt7LzR60ogjzrhYXrgHzW5Gkfm32NBPF4S7QiZvNEyrNUNmRUb3EPuc3WS4XAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC&#43;eUykAgIBgANEAAJBAJv7XJrlaOYCIPZ1vZc2Ol5GnvYQNWWcoeNPjNbzPW5keT5p1rl3mwLJdDnOI1Qwh9pw3vmQirNsBMhacKvu0I4=<br><br>甲方私钥：<br><br>MIHSAgEAMIGXBgkqhkiG9w0BAwEwgYkCQQD8poLOjhLKuibvzPcRDlJtsHiwXt7LzR60ogjzrhYXrgHzW5Gkfm32NBPF4S7QiZvNEyrNUNmRUb3EPuc3WS4XAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC&#43;eUykAgIBgAQzAjEA9dZOTVebQERSfblRNYIRob8g6g24V2DINCnEXwJTlYVdHIV5PLyjbWzn48eb2NIg<br><br>乙方公钥：<br><br>MIHgMIGXBgkqhkiG9w0BAwEwgYkCQQD8poLOjhLKuibvzPcRDlJtsHiwXt7LzR60ogjzrhYXrgHzW5Gkfm32NBPF4S7QiZvNEyrNUNmRUb3EPuc3WS4XAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC&#43;eUykAgIBgANEAAJBAJZ304pW1u5XRkEgyasNNV3Vy74yPPjTCNU5tbqbSnGDKKsBhjagSoMdJ21HiAPeU0NFIeZdPPYI2vu55ETQJOA=<br><br>乙方私钥：<br><br>MIHSAgEAMIGXBgkqhkiG9w0BAwEwgYkCQQD8poLOjhLKuibvzPcRDlJtsHiwXt7LzR60ogjzrhYXrgHzW5Gkfm32NBPF4S7QiZvNEyrNUNmRUb3EPuc3WS4XAkBnhHGyepz0TukaScUUfbGpqvJE8FpDTWSGkx0tFCcbnjUDC3H9c9oXkGmzLik1Yw4cIGI1TQ2iCmxBblC&#43;eUykAgIBgAQzAjEA2jSKn/s21Yirb9HBIxrH2l9B6HI59s7Nvk5FOafpr0VqpigbdFV6fLUDURUUWOdb<br><br>甲方本地密钥：<br><br>gJyxRUpxSSxl6ibLr6LfIs9rTr7k9XxFKwhGqaOFy5U=<br><br>乙方本地密钥：<br><br>gJyxRUpxSSxl6ibLr6LfIs9rTr7k9XxFKwhGqaOFy5U=<br><br><br><br><br><br>=====甲方向乙方发送加密数据=====<br><br>原文： 密钥交换算法<br><br>—使用甲方密钥对本地数据加密—<br><br>加密： VqM0WkF0M8j1UURMOd9QRg==<br><br>—使用乙方密钥对本地数据解密—<br><br>解密： &nbsp;密钥交换算法<br><br><br><br><br><br>=====乙方向甲方发送加密数据=====<br><br>原文： DH<br><br>—使用乙方密钥对本地数据加密—<br><br>加密： faq8AO4Joy1s6k6/k3JVUw==<br><br>—使用甲方密钥对本地数据解密—<br><br>解密： &nbsp;DH<br><br></p><br><p><br><br></p><br><p>这里选择的密钥长度是512位，若选择1024位就更长了</p><br><p>DH算法支持密钥长度为64倍数，512~1024.长度与安全强度正比，运算时间反比</p><br><p>对称加密算法可选择DES，DESede,AES 等</p><br><p>合理选择密钥长度及算法是构建DH算法密码系统关键。</p><br><p><br><br></p><br><p>四、System.out.println()与System.err.println();</p><br><p>System.out.println();是标准输出，输出黑色<br><br>System.err.println();是标准错误输出，输出红色<br><br><br><br><br><br>默认的话都是写往控制台，从操作系统的实现上讲<br><br>标准输出 一般有默认有缓存<br><br>标准错误输出 一般没有缓存<br><br></p><br><p><br><br></p><br><p>System.out.println 能重定向到别的输出流，这样的话你在屏幕上将看不到打印的东西了，<br><br>而System.err.println只能在屏幕上实现打印，即使你重定向了也一样。<br><br></p><br><link rel="stylesheet" href="http://static.blog.csdn.net/public/res-min/markdown_views.css?v=2.0"><br>            </div><br>        <br>        <div class="readall_box csdn-tracking-statistics" data-mod="popu_376"><br>            <div class="read_more_mask"></div><br>            <a class="btn btn-large btn-gray-fred read_more_btn" target="_self">阅读全文</a><br>        </div><br>        <div class="article_copyright"><br>            <h4>实例代码</h4><br>    DHCoder.java<br>    <pre name="code" class="java"><br>      package com.dtb.member.test;<br><br>import java.security.Key;<br>import java.security.KeyFactory;<br>import java.security.KeyPair;<br>import java.security.KeyPairGenerator;<br>import java.security.PrivateKey;<br>import java.security.PublicKey;<br>import java.security.spec.PKCS8EncodedKeySpec;<br>import java.security.spec.X509EncodedKeySpec;<br>import java.util.HashMap;<br>import java.util.Map;<br><br>import javax.crypto.Cipher;<br>import javax.crypto.KeyAgreement;<br>import javax.crypto.SecretKey;<br>import javax.crypto.interfaces.DHPrivateKey;<br>import javax.crypto.interfaces.DHPublicKey;<br>import javax.crypto.spec.DHParameterSpec;<br>import javax.crypto.spec.SecretKeySpec;<br><br>import com.sun.org.apache.xml.internal.security.utils.Base64;<br><br>public class DHCoder {<br>    /<strong><br>     <em> 非对称加密密钥算法 
     </em>/<br>    private static final String KEY_ALGORITHM = “DH”;<br>    /</strong><br>     <em> 本地密钥算法，即对称加密密钥算法 
     </em> 可选DES、DESede或者AES<br>     <em>/<br>    private static final String SELECT_ALGORITHM = “AES”;<br>    /** 
     </em> 密钥长度<br>     <em>/<br>    private static final int KEY_SIZE = 512;<br>    //公钥<br>    private static final String PUBLIC_KEY = “DHPublicKey”;<br>    //私钥<br>    private static final String PRIVATE_KEY = “DHPrivateKey”;<br><br>    /** 
     </em> 初始化甲方密钥<br>     <em> @return Map 甲方密钥Map 
     </em> @throws Exception<br>     <em>/<br>    public static Map<string, object=""> initKey() throws Exception{<br>        //实例化密钥对生成器<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM);<br>        //初始化密钥对生成器<br>        keyPairGenerator.initialize(KEY_SIZE);<br>        //生成密钥对<br>        KeyPair keyPair = keyPairGenerator.generateKeyPair();<br>        //甲方公钥<br>        DHPublicKey publicKey = (DHPublicKey)keyPair.getPublic();<br>        //甲方私钥<br>        DHPrivateKey privateKey = (DHPrivateKey)keyPair.getPrivate();<br>        //将密钥对存储在Map中<br>        Map<string, object=""> keyMap = new HashMap<string, object="">(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }<br><br>    /** 
     </string,></string,></string,></em> 初始化乙方密钥<br>     <em> @param key 甲方公钥 
     </em> @return Map 乙方密钥Map<br>     <em> @throws Exception 
     </em>/<br>    public static Map<string, object=""> initKey(byte[] key) throws Exception{<br>        //解析甲方公钥<br>        //转换公钥材料<br>        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(key);<br>        //实例化密钥工厂<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        //产生公钥<br>        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);<br>        //由甲方公钥构建乙方密钥<br>        DHParameterSpec dhParameterSpec = ((DHPublicKey)pubKey).getParams();<br>        //实例化密钥对生成器<br>        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM);<br>        //初始化密钥对生成器<br>        keyPairGenerator.initialize(dhParameterSpec);<br>        //产生密钥对<br>        KeyPair keyPair = keyPairGenerator.generateKeyPair();<br>        //乙方公钥<br>        DHPublicKey publicKey = (DHPublicKey) keyPair.getPublic();<br>        //乙方私约<br>        DHPrivateKey privateKey = (DHPrivateKey) keyPair.getPrivate();<br>        //将密钥对存储在Map中<br>        Map<string, object=""> keyMap = new HashMap<string, object="">(2);<br>        keyMap.put(PUBLIC_KEY, publicKey);<br>        keyMap.put(PRIVATE_KEY, privateKey);<br>        return keyMap;<br>    }<br><br>    /<strong><br>     <em> 加密 
     </em> @param data 待加密数据<br>     <em> @param key 密钥 
     </em> @return byte[] 加密数据<br>     <em> @throws Exception 
     </em>/<br>    public static byte[] encrypt(byte[] data, byte[] key) throws Exception{<br>        //生成本地密钥<br>        SecretKey secretKey = new SecretKeySpec(key, SELECT_ALGORITHM);<br>        //数据加密  -这里使用到加密算法超长，所以简单用代码演示加密解密 ，其重点在于 双方都能使用同一个密匙<br>//        Cipher cipher = Cipher.getInstance(SELECT_ALGORITHM);<br>//        cipher.init(Cipher.ENCRYPT_MODE, secretKey);<br>//        return cipher.doFinal(data);<br>        return (new String(data)+Base64.encode(key)).getBytes();<br>    }<br><br>    /</strong><br>     <em> 解密 
     </em> @param data 待解密数据<br>     <em> @param key 密钥 
     </em> @return byte[] 解密数据<br>     <em> @throws Exception 
     </em>/<br>    public static byte[] decrypt(byte[] data, byte[] key) throws Exception{<br>        //生成本地密钥<br>        SecretKey secretKey = new SecretKeySpec(key, SELECT_ALGORITHM);<br>        //数据揭秘  -这里使用到加密算法超长，所以简单用代码演示加密解密 ，其重点在于 双方都能使用同一个密匙<br>//        Cipher cipher = Cipher.getInstance(secretKey.getAlgorithm());<br>//        cipher.init(Cipher.DECRYPT_MODE, secretKey);<br>//        return cipher.doFinal(data);<br>        String encode = Base64.encode(key);<br>        String dataStr = new String(data);<br>        String resultStr = dataStr.split(encode)[0];<br>        return resultStr.getBytes();<br>    }<br><br>    /<strong><br>     <em> 构建密钥 
     </em> @param publicKey 公钥<br>     <em> @param privateKey 私钥 
     </em> @return byte[] 本地密钥<br>     <em> @throws Exception 
     </em>/<br>    public static byte[] getSecretKey(byte[] publicKey, byte[] privateKey) throws Exception{<br>        //实例化密钥工厂<br>        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);<br>        //初始化公钥<br>        //密钥材料转换<br>        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKey);<br>        //产生公钥<br>        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);<br>        //初始化私钥<br>        //密钥材料转换<br>        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(privateKey);<br>        //产生私钥<br>        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);<br>        //实例化<br>        KeyAgreement keyAgree = KeyAgreement.getInstance(keyFactory.getAlgorithm());<br>        //初始化<br>        keyAgree.init(priKey);<br>        keyAgree.doPhase(pubKey, true);<br>        //生成本地密钥<br>        SecretKey secretKey = keyAgree.generateSecret(SELECT_ALGORITHM);<br>        return secretKey.getEncoded();<br>    }<br><br>    /</strong><br>     <em> 取得私钥 
     </em> @param keyMap 密钥Map<br>     <em> @return byte[] 私钥 
     </em> @throws Exception<br>     <em>/<br>    public static byte[] getPrivateKey(Map<string, object=""> keyMap) throws Exception{<br>        Key key = (Key) keyMap.get(PRIVATE_KEY);<br>        return key.getEncoded();<br>    }<br><br>    /** 
     </string,></em> 取得公钥<br>     <em> @param keyMap 密钥Map 
     </em> @return byte[] 公钥<br>     <em> @throws Exception 
     </em>/<br>    public static byte[] getPublicKey(Map<string, object=""> keyMap) throws Exception{<br>        Key key = (Key) keyMap.get(PUBLIC_KEY);<br>        return key.getEncoded();<br>    }<br>}<br><br>    </string,></string,></string,></string,></pre><br>    DHTest.java<br>    <pre name="code" class="java"><br>    package com.dtb.member.test;<br><br>import java.util.Map;<br><br>import com.sun.org.apache.xml.internal.security.utils.Base64;<br><br><br>public class DHTest {<br>    //甲方公钥<br>    private static byte[] publicKey1;<br>    //甲方私钥<br>    private static byte[] privateKey1;<br>    //甲方本地密钥<br>    private static byte[] key1;<br>    //乙方公钥<br>    private static byte[] publicKey2;<br>    //乙方私钥<br>    private static byte[] privateKey2;<br>    //乙方本地密钥<br>    private static byte[] key2;<br><br>    /<strong><br>     <em> 初始化密钥 
     </em> @throws Exception<br>     */<br>    public static final void initKey() throws Exception{<br>        //生成甲方密钥对<br>        Map<string, object=""> keyMap1 = DHCoder.initKey();<br>        publicKey1 = DHCoder.getPublicKey(keyMap1);<br>        privateKey1 = DHCoder.getPrivateKey(keyMap1);<br>//        System.out.println(“甲方公钥:\n” + Base64.encodeBase64String(publicKey1));<br>//        System.out.println(“甲方私钥:\n” + Base64.encodeBase64String(privateKey1));<br>        System.out.println(“甲方公钥:\n” + Base64.encode(publicKey1));<br>        System.out.println(“甲方私钥:\n” + Base64.encode(privateKey1));<br>        //由甲方公钥产生本地密钥对<br>        Map<string, object=""> keyMap2 = DHCoder.initKey(publicKey1);<br>        publicKey2 = DHCoder.getPublicKey(keyMap2);<br>        privateKey2 = DHCoder.getPrivateKey(keyMap2);<br>        System.out.println(“乙方公钥:\n” + Base64.encode(publicKey2));<br>        System.out.println(“乙方私钥:\n” + Base64.encode(privateKey2));<br>        key1 = DHCoder.getSecretKey(publicKey2, privateKey1);<br>        System.out.println(“甲方本地密钥:\n” + Base64.encode(key1));<br>        key2 = DHCoder.getSecretKey(publicKey1, privateKey2);<br>        System.out.println(“乙方本地密钥:\n” + Base64.encode(key2));<br>    }<br><br>    /</string,></string,></strong><br>     <em> 主方法 
     </em> @param args<br>     <em> @throws Exception 
     </em>/<br>    public static void main(String[] args) throws Exception {<br>        // TODO Auto-generated method stub<br>        initKey();<br>        System.out.println();<br>        System.out.println(“===甲方向乙方发送加密数据===”);<br>        String input1 = “求知若饥，虚心若愚。”;<br>        System.out.println(“原文:\n” + input1);<br>        System.out.println(“—使用甲方本地密钥对数据进行加密—“);<br>        //使用甲方本地密钥对数据加密<br>        byte[] encode1 = DHCoder.encrypt(input1.getBytes(), key1);<br>        System.out.println(“加密:\n” + Base64.encode(encode1));<br>        System.out.println(“—使用乙方本地密钥对数据库进行解密—“);<br>        //使用乙方本地密钥对数据进行解密<br>        byte[] decode1 = DHCoder.decrypt(encode1, key2);<br>        String output1 = new String(decode1);<br>        System.out.println(“解密:\n” + output1);<br><br>        System.out.println(“/~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~..~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~.~/“);<br>        initKey();<br>        System.out.println(“===乙方向甲方发送加密数据===”);<br>        String input2 = “好好学习，天天向上。”;<br>        System.out.println(“原文:\n” + input2);<br>        System.out.println(“—使用乙方本地密钥对数据进行加密—“);<br>        //使用乙方本地密钥对数据进行加密<br>        byte[] encode2 = DHCoder.encrypt(input2.getBytes(), key2);<br>        System.out.println(“加密:\n” + Base64.encode(encode2));<br>        System.out.println(“—使用甲方本地密钥对数据进行解密—“);<br>        //使用甲方本地密钥对数据进行解密<br>        byte[] decode2 = DHCoder.decrypt(encode2, key1);<br>        String output2 = new String(decode2);<br>        System.out.println(“解密:\n” + output2);<br>    }<br>}<br><br>    </pre><br>        </div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/10/13/zookeeper-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/13/zookeeper-01/" itemprop="url">基于Zookeeper的Redis Cache 高可用易扩容集群方案设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-13T15:11:38+08:00">
                2017-10-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="t_fsz"><br><table cellspacing="0" cellpadding="0"><tr><td class="t_f" id="postmessage_1473713"><br><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif">本文目标是设计高可用，易伸缩的<a href="http://www.dataguru.cn/article-8569-1.html?union_site=innerlink" target="_blank" class="relatedlink">Redis</a>Cache集群方案，需求： </font></font><br><br><ul><li>故障转移：某个Redis实例故障应当可以把负责的key转移到其他实例。故障实例保存的数据可能丢失，这是符合Cache应用场景需求的。</li><li>动态水平伸缩：应当可以在运行时动态增加Redis实例，以达到容量水平扩容。水平扩容可能造成部分Cache Key丢失。<br><br></li></ul><br><br><br><br><font color="blue"><font face="Tahoma, Helvetica, SimSun, sans-serif">1. 总体架构</font></font><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><img id="aimg_Z4e1d" onclick="zoom(this, this.src, 0, 0, 0)" class="zoom" height="25" file="http://dl.iteye.com/upload/picture/pic/132436/8005f6ac-fef4-3087-99f9-765d0c997963.png" border="0" alt=""><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><ul><li>每一个Redis实例都在Zookeeper当中注册一个EPHEMERAL SEQUENTIAL节点。</li><li>Zookeeper就可以负责维护Redis实例是否可用的状态信息，支持动态增减Redis实例</li><li>每个Redis实例获得一个ID方便一致性哈希<a href="http://www.dataguru.cn/article-5747-1.html?union_site=innerlink" target="_blank" class="relatedlink">算法</a>的实现</li><li>每个Redis实例都需要有一个Keeper，代理维护其与Zookeeper之间的连接<br><br></li></ul><br><br><br><br><font color="blue"><font face="Tahoma, Helvetica, SimSun, sans-serif">2. Keeper</font></font><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif">负责在Zookeeper中注册维护Redis实例的信息。Keeper和Redis位于同一台机器，Keeper通过LOCAL HOST地址访问它维护的Redis实例。 </font></font><br><br><br><br><font color="blue"><font face="Tahoma, Helvetica, SimSun, sans-serif">2.1. 启动</font></font><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif">Keeper启动过程的输入： </font></font><br><br><ul><li>Zookeeper IP</li><li>Zookeeper 端口</li><li>redis-server程序的路径</li><li>Redis实例端口</li><li>Client应当通过什么IP访问Redis实例<br><br></li></ul><br><br><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif">Keeper启动完成的工作： </font></font><br><br><ul><li>启动本机Redis实例</li><li>与Zookeeper建立Session</li><li>在Zookeeper中创建EPHEMERAL SEQUENTIAL节点，并保存Redis实例的IP、Port<br><br></li></ul><br><br><br><br><font color="blue"><font face="Tahoma, Helvetica, SimSun, sans-serif">2.2. Redis实例故障的检测与转移</font></font><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><ul><li>Keeper每隔一段时间就向它的Redis实例发送一个PING命令</li><li>若Keeper连续几次都PING失败则删除Zookeeper中对应的节点</li><li>若Keeper与Redis实例一起发生故障，则在Zookeeper检测到Session关闭之后自动删除节点</li><li>若Keeper故障Redis实例未故障，则逻辑上也认为Redis实例故障，将其移除<br><br></li></ul><br><br><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif">故障转移耗时评估： </font></font><br><br><ul><li>假设配置Zookeeper集群tickTime为500ms</li><li>要求Zookeeper Session 超市时间为tickTime的：2~20倍，配置为3倍</li><li>配置Keeper Ping Redis实例的间隔为500ms，故障重试次数也未3次</li><li>则故障转移最长耗时评估为：1.5s<br><br></li></ul><br><br><br><br><font color="blue"><font face="Tahoma, Helvetica, SimSun, sans-serif">2.3 水平扩容的过程</font></font><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif">水平扩容十分简便，过程如下 </font></font><br><br><ul><li>分配机器，在上面安装好Redis和Keeper程序</li><li>配置好Keeper启动需要的输入参数（见2.1）</li><li>启动Keeper<br><br></li></ul><br><br><br><br><font color="blue"><font face="Tahoma, Helvetica, SimSun, sans-serif">3.Client</font></font><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><font color="blue"><font face="Tahoma, Helvetica, SimSun, sans-serif">3.1 数据分片</font></font><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif">通过一致性哈希算法，在Client端实现数据分片。 </font></font><br><br><br><br><font color="blue"><font face="Tahoma, Helvetica, SimSun, sans-serif">3.2 动态容错</font></font><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif">Client访问Redis实例的过程可以分为三步： </font></font><br><br><ul><li>1.在Zookeeper中查询Redis集群的动态配置信息</li><li>2.根据一致性哈希算法计算Key-&gt;Redis实例的映射</li><li>3.访问Redis实例进行数据操作<br><br></li></ul><br><br><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif">可能在上述的第1步之后，第3步之前发生Redis集群的动态变化，导致Redis实例访问失败。此时需要进行重试访问，超过一定次数之后，向上层返回错误。具体流程图如下所示： </font></font><br><br><img id="aimg_xhMMb" onclick="zoom(this, this.src, 0, 0, 0)" class="zoom" height="25" file="http://dl.iteye.com/upload/picture/pic/132440/75565a88-379f-3bdb-8906-16fb171d3e80.png" border="0" alt=""><font color="#000"><font face="Tahoma, Helvetica, SimSun, sans-serif"> </font></font><br><br><br><br><br><br></td></tr></table><br><br><br></div><br><div id="comment_1473713" class="cm"><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://bloodorange2017.github.io/archives/2017/09/19/serialization-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XueCheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://bloodorange2017.github.io/images/img_head_001.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XueCheng Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/19/serialization-02/" itemprop="url">转载：Java Serializable接口（序列化）理解及自定义序列化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-19T11:43:17+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="postBody"><br>            <div id="cnblogs_post_body"><p><em><strong>&nbsp; 1&nbsp;Serializable接口</strong></em></p><br><p>&nbsp; （1）简单地说，就是可以将一个对象(标志对象的类型)及其状态转换为字节码，保存起来（可以保存在数据库，内存，文件等）,然后可以在适当的时候再将其状态恢复(也就是反序列化)。serialization 不但可以在本机做，而且可以经由网络操作。它自动屏蔽了操作系统的差异，字节顺序等。比如，在 Windows 平台生成一个对象并序列化之，然后通过网络传到一台 Unix 机器上，然后可以在这台Unix机器上正确地重构（deserialization）这个对象。 不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。<br>&nbsp;<br>另外，还应明白以下几点：<br>&nbsp;<br>&nbsp; &nbsp; a. java.io.Serializable接口没有任何方法属性域，实现它的类只是从语义上表明自己是可以序列化的。<br>&nbsp;<br>&nbsp; &nbsp; b. 在对一个 Serializable（可序列化）对象进行重新装配的过程中，不会调用任何构建器（甚至默认构建器）。整个对象都是通过从 InputStream 中取得数据恢复的。<br>&nbsp;<br>&nbsp; &nbsp; c. 如是要一个类是可序列化的，那么它的子类也是可序列化的。</p><br><p>（2）serialVersionUID</p><br><p>serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。<br>类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的serialVersionUID，也有可能相同。为了提高哦啊serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。显式地定义serialVersionUID有两种用途：<br>&nbsp;<br>　　a. 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；<br>&nbsp;<br>　　b. 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p><br><p>&nbsp;</p><br><p><em><strong>2 自定义序列化：</strong></em></p><br><p>&nbsp; &nbsp; &nbsp; 自定义序列化是由ObjectInput/OutputStream在序列化/反序列化时候通过反射检查该类是否存在以下方法（0个或多个）：执行顺序从上往下，序列化调用1和2，反序列调用3和4；transient关键字当某个字段被声明为transient后，默认序列化机制就会忽略该字段。</p><br><p>1Object writeReplace() throws ObjectStreamException;可以通过此方法修改序列化的对象</p><br><p>2void&nbsp;writeObject(java.io.ObjectOutputStream out) throws IOException; 方法中调用defaultWriteObject（） 使用writeObject的默认的序列化方式，除此之外可以加上一些其他的操作，如添加额外的序列化对象到输出：out.writeObject(“XX”)</p><br><p>3void readObject(java.io.ObjectInputStream in) throws Exception; 方法中调用defaultReadObject（）使用readObject默认的反序列化方式，除此之外可以加上一些其他的操作，如读入额外的序列化对象到输入：in.readObject()</p><br><p>4Object readResolve() throws ObjectStreamException;可以通过此方法修改返回的对象</p><br><p>&nbsp;</p><br><p>例子：单例模式的类实现序列化接口，若使用默认的序列化策略，则在反序列化返回的对象不符合单利模式（反射创建了新的对象，如下PersonSington对象），可以通过修改序列化的readResolve来实现自定义序列化返回结果来实现单例对象唯一（相当于1,2,3方法对4的结果毫无作用）。</p><br><div class="cnblogs_code"><br><pre><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> PersonSingleton <span style="color: #0000ff">implements</span><span style="color: #000000"> Serializable {</span><br>    <span style="color: #0000ff">private</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">final</span> <span style="color: #0000ff">long</span> serialVersionUID = 1L<span style="color: #000000">;<br>    </span><span style="color: #0000ff">private</span><span style="color: #000000"> String name;<br>    </span><span style="color: #0000ff">private</span><span style="color: #000000"> PersonSingleton(String name) {<br>        </span><span style="color: #0000ff">this</span>.name =<span style="color: #000000"> name;<br>    };<br>    </span><span style="color: #0000ff">private</span> <span style="color: #0000ff">static</span> PersonSingleton person = <span style="color: #0000ff">null</span>;<br><br>    <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">synchronized</span><span style="color: #000000"> PersonSingleton getInstance() {<br>        </span><span style="color: #0000ff">if</span> (person == <span style="color: #0000ff">null</span><span style="color: #000000">)<br>            </span><span style="color: #0000ff">return</span> person = <span style="color: #0000ff">new</span> PersonSingleton(“cgl”<span style="color: #000000">);<br>        </span><span style="color: #0000ff">return</span><span style="color: #000000"> person;<br>    }<br><br>    </span><span style="color: #0000ff">private</span> Object writeReplace() <span style="color: #0000ff">throws</span><span style="color: #000000"> ObjectStreamException {<br>        System.out.println(</span>“1 write replace start”<span style="color: #000000">);<br>        </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span><span style="color: #000000">;//可修改为其他对象<br>    }<br><br>    </span><span style="color: #0000ff">private</span> <span style="color: #0000ff">void</span> writeObject(java.io.ObjectOutputStream out) <span style="color: #0000ff">throws</span><span style="color: #000000"> IOException {<br>        System.out.println(</span>“2 write object start”<span style="color: #000000">);<br>        out.defaultWriteObject();<br>       //out.writeInt(1);<br>    }<br><br>    </span><span style="color: #0000ff">private</span> <span style="color: #0000ff">void</span> readObject(java.io.ObjectInputStream in) <span style="color: #0000ff">throws</span><span style="color: #000000"> IOException, ClassNotFoundException {<br>        System.out.println(</span>“3 read object start”<span style="color: #000000">);<br>        in.defaultReadObject();<br>       //int i=in.readInt();<br>    }<br><br>    </span><span style="color: #0000ff">private</span> Object readResolve() <span style="color: #0000ff">throws</span><span style="color: #000000"> ObjectStreamException {<br>        System.out.println(</span>“4 read resolve start”<span style="color: #000000">);<br>        </span><span style="color: #0000ff">return</span><span style="color: #000000"> PersonSingleton.getInstance();//不管序列化的操作是什么，返回的都是本地的单例对象<br>    }<br><br>    </span><span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) <span style="color: #0000ff">throws</span><span style="color: #000000"> Exception {<br><br>        FileOutputStream out </span>= <span style="color: #0000ff">new</span> FileOutputStream(<span style="color: #0000ff">new</span> File(“D://person.dat”<span style="color: #000000">));<br>        ObjectOutputStream op </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> ObjectOutputStream(out);<br>        op.writeObject(PersonSingleton.getInstance());<br>        op.close();<br><br>        FileInputStream in </span>= <span style="color: #0000ff">new</span> FileInputStream(<span style="color: #0000ff">new</span> File(“D://person.dat”<span style="color: #000000">));<br>        ObjectInputStream oi </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> ObjectInputStream(in);<br>        Object person </span>=<span style="color: #000000"> oi.readObject();<br>        in </span>= <span style="color: #0000ff">new</span> FileInputStream(<span style="color: #0000ff">new</span> File(“D://person.dat”<span style="color: #000000">));<br>        oi </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> ObjectInputStream(in);<br>        PersonSinglton person1 </span>=<span style="color: #000000"> (PersonSinglton) oi.readObject();<br><br>        System.out.println(</span>“sington person hashcode:” +<span style="color: #000000"> person.hashCode());<br>        System.out.println(</span>“sington person1 hashcode:” +<span style="color: #000000"> person1.hashCode());<br>        System.out.println(</span>“singleton getInstance hashcode:” +<span style="color: #000000"> PersonSingleton.getInstance().hashCode());<br>        System.out.println(</span>“singleton person equals:” + (person ==<span style="color: #000000"> PersonSingleton.getInstance()));<br>        System.out.println(</span>“person equals1:” + (person1 ==<span style="color: #000000"> person));<br>    }<br>}</span></pre><br></div><br><p>&nbsp;</p><br><p>运行结果：</p><br><hr><br><p>&nbsp;</p><br><p>1 write replace start<br>2 write object start<br>3 read object start<br>4 read resolve start<br>3 read object start<br>4 read resolve start<br>sington person hashcode:1550089733<br>sington person1 hashcode:1550089733<br>sington getInstance hashcode:1550089733<br>sington person equals:true<br>person equals1:true</p><br><hr><br><p>&nbsp;</p><br><p><em><strong>3&nbsp;Externalizable接口</strong></em></p><br><p>&nbsp; &nbsp;Externalizable继承于Serializable，当使用该接口时，序列化的细节需要由程序员去完成。若writeExternal()与readExternal()方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段。出结果中所有字段的值均为空。<br>&nbsp;&nbsp;&nbsp; 另外，若使用Externalizable进行序列化，当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。由于这个原因，实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。</p><br><p>&nbsp;</p></div><div id="MySignature"></div><br><div class="clear"></div><br><div id="blog_post_info_block"><br><div id="BlogPostCategory"></div><br><div id="EntryTag"></div><br><div id="blog_post_info"><br></div>

</div></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://bloodorange2017.github.io/images/img_head_001.jpg"
               alt="XueCheng" />
          <p class="site-author-name" itemprop="name">XueCheng</p>
           
              <p class="site-description motion-element" itemprop="description">Do one thing at a time, and do well.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XueCheng</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

<script type="text/javascript"
color="160,160,233" opacity='0.4' zIndex="-2" count="16" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
